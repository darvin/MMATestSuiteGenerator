(* Created by Wolfram Mathematica 10.0 : www.wolfram.com *)
Import["CompatTests.m"]; 
TapSuite[TapComment["Remainders mod 3:"], 
 TapTestSame[Mod[{1, 2, 3, 4, 5, 6, 7}, 3], {1, 2, 0, 1, 2, 0, 1}], 
 TapComment["Remainders mod 3 offset to start with 1:"], 
 TapTestSame[Mod[{1, 2, 3, 4, 5, 6, 7}, 3, 1], {1, 2, 3, 1, 2, 3, 1}], 
 TapComment["Plot the sequence with fixed modulus: "], 
 TapTestSame[HoldComplete[DiscretePlot[Mod[n, 8], {n, 50}]], $Failed], 
 TapComment["Plot the sequence, varying the modulus: "], 
 TapTestSame[HoldComplete[DiscretePlot[Mod[100, m], {m, 50}]], $Failed], 
 TapComment["Reduce an approximate number:"], 
 TapTestSame[Mod[4.56, 2], 0.56], 
 TapComment["Reduce an exact numeric quantity:"], 
 TapTestSame[Mod[Exp[Pi], 2], -22 + E^Pi], TapTestSameBROKEN[N[%], 1.14069], 
 TapComment["Reduce mod \\[Pi]:"], TapTestSame[Mod[20, Pi], 20 - 6*Pi], 
 TapComment["Complex number:"], TapTestSame[Mod[Sqrt[-113], 2], 
  -10*I + I*Sqrt[113]], TapTestSame[Simplify[Mod[2*n + 1, 2], 
   Element[n, Integers]], 1], TapTestSame[Simplify[Mod[(1 + x)^16, 2], 
   Element[x, Integers]], Mod[1 + x^8, 2]], TapComment["Wilson's theorem:"], 
 TapTestSame[FunctionExpand[Mod[(p - 1)!, p], Element[p, Primes]], -1 + p], 
 TapComment["Solve a modular equation:"], 
 TapTestSame[Reduce[Mod[2*x + 1, 5] == Mod[x, 7] && 0 < x < 50, x], 
  x == 4 || x == 7 || x == 15 || x == 23 || x == 31 || x == 39 || x == 42], 
 TapComment["Evaluate an integral:"], 
 TapTestSame[Integrate[Mod[x^2, 2], {x, 0, 4}], 
  (2/3)*(-46 + 9*Sqrt[2] + 6*Sqrt[3] + 3*Sqrt[6] + 3*Sqrt[10] + 3*Sqrt[14])], 
 TapComment["Extract parts cyclically:"], 
 TapTestSame[{a, b, c}[[Mod[Range[10], 3, 1]]], 
  {a, b, c, a, b, c, a, b, c, a}], 
 TapComment["Select primes below 100 having the form of 6 k+1:"], 
 TapTestSame[Select[Array[Prime, PrimePi[100]], Mod[#1, 6] == 1 & ], 
  {7, 13, 19, 31, 37, 43, 61, 67, 73, 79, 97}], 
 TapComment["Simulate a particle bouncing in a non-commensurate box:"], 
 TapTestSameBROKEN[HoldComplete[
   Graphics[Line[Table[Mod[t, {Sqrt[2], 1}], {t, 0, 20, 0.001}]]]], $Failed], 
 TapComment["Define a notation for addition mod 2:"], 
 TapTestSame[(x_) \[CirclePlus] (y_) := Mod[x + y, 2]; 
   (1 \[CirclePlus] 0) \[CirclePlus] 1, 0], 
 TapComment["The results have the same sign as the second argument:"], 
 TapTestSame[Mod[{-3, -2, -1, 0, 1, 2, 3}, 3], {0, 1, 2, 0, 1, 2, 0}], 
 TapTestSame[Mod[{-3, -2, -1, 0, 1, 2, 3}, -3], {0, -2, -1, 0, -2, -1, 0}], 
 TapTestSame[HoldComplete[Plot[Mod[x, 2], {x, -6, 6}]], $Failed], 
 TapComment["Expressions generated by RefLink[Mod,paclet:ref/Mod] can be \
difficult to evaluate with machine precision:"], 
 TapTestSame[Mod[GoldenRatio^100, 1], -792070839848372253126 + 
   GoldenRatio^100], TapComment[
  "Machine-precision numerical evaluation gives the wrong answer:"], 
 TapTestSameBROKEN[N[%], 2.62144*10^6], 
 TapComment["Arbitrary precision gives the correct answer:"], 
 TapTestSameBROKEN[N[%%, 30], 0.999999999999999999998737486662`30.], 
 TapComment[
  "Some computations may require higher internal precision than the default:"]\
, TapTestSame[Mod[GoldenRatio^1000, 1], GoldenRatio^1000 - 
   Floor[GoldenRatio^1000]], TapTestSame[
  Block[{$MaxExtraPrecision = Infinity}, Mod[GoldenRatio^1000, 1]], 
  -97194177735908175207981982079326473737797879155345685082728081084772518818\
44481526908061914904596829767957830540320934740116303690766057397174086246375\
1801641201490284097309096322681531675707666695323797578126 + 
   GoldenRatio^1000], TapTestSame[HoldComplete[
   ArrayPlot[Table[Mod[i, j], {i, 30}, {j, 30}]]], $Failed], 
 TapComment["Binomial coefficients mod 2:"], 
 TapTestSame[HoldComplete[ArrayPlot[Table[Mod[Binomial[i, j], 2], {i, 0, 63}, 
     {j, 0, 63}]]], $Failed], 
 TapComment["Mod 4 additive cellular automaton:"], 
 TapTestSame[HoldComplete[ArrayPlot[CellularAutomaton[
     {Mod[Total[#1], 4] & , {}, 1}, {{1}, 0}, 50]]], $Failed]]
