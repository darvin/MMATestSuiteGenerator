(* Created by Wolfram Mathematica 10.0 : www.wolfram.com *)
Import["CompatTests.m"]; 
TapSuite[TapTestSame[f @@ {a, b, c, d}, f[a, b, c, d]], 
 TapTestSame[f @@ {a, b, c, d}, f[a, b, c, d]], 
 TapTestSame[Plus @@ {a, b, c, d}, a + b + c + d], 
 TapComment["RefLink[Apply,paclet:ref/Apply] gets rid of a level of lists:"], 
 TapTestSame[f @@ {{a, b}, {c}, d}, f[{a, b}, {c}, d]], 
 TapComment["Use the operator form of RefLink[Apply,paclet:ref/Apply]:"], 
 TapTestSame[(Apply[f])[{{a, b}, {c}, d}], f[{a, b}, {c}, d]], 
 TapComment["Apply f to an RefLink[Association,paclet:ref/Association]:"], 
 TapTestSame[List @@ \[LeftAssociation] 1 -> a, 2 -> b, 3 -> c, 
    4 -> {d} \[RightAssociation], {a, b, c, {d}}], 
 TapComment["RefLink[Apply,paclet:ref/Apply] is equivalent to \
RefLink[Values,paclet:ref/Values]:"], 
 TapTestSame[Values[\[LeftAssociation] 1 -> a, 2 -> b, 3 -> c, 
    4 -> {d} \[RightAssociation]], {a, b, c, {d}}], 
 TapComment["RefLink[Apply,paclet:ref/Apply] f at the second level:"], 
 TapTestSame[Apply[f, \[LeftAssociation] 1 -> a, 2 -> b, 3 -> c, 
    4 -> {d, {e}} \[RightAssociation], {2}], \[LeftAssociation] 1 -> a, 
   2 -> b, 3 -> c, 4 -> {d, f[e]} \[RightAssociation]], 
 TapComment["Apply f at several levels:"], 
 TapTestSameBROKEN[Apply[f, \[LeftAssociation] 1 -> a, 2 -> b, 3 -> c, 
    4 -> {d, {e}} \[RightAssociation], {0, 2}], f[{a, b, c, f[d, f[e]]}]], 
 TapComment["Apply at level 0 (default):"], 
 TapTestSame[f @@ {{a, b, c}, {d, e}}, f[{a, b, c}, {d, e}]], 
 TapTestSame[f @@ {{a, b, c}, {d, e}}, f[{a, b, c}, {d, e}]], 
 TapComment["Apply at level 1:"], TapTestSame[Apply[f, {{a, b, c}, {d, e}}, 
   {1}], {f[a, b, c], f[d, e]}], 
 TapComment["The short form @@@ is equivalent to applying at level 1:"], 
 TapTestSame[Apply[f, {{a, b, c}, {d, e}}, {1}], {f[a, b, c], f[d, e]}], 
 TapComment["Apply at levels 0 and 1:"], 
 TapTestSame[Apply[f, {{a, b, c}, {d, e}}, {0, 1}], f[f[a, b, c], f[d, e]]], 
 TapComment["Apply down to level 2 (excluding level 0):"], 
 TapTestSame[Apply[f, {{{{{a}}}}}, 2], {f[f[{{a}}]]}], 
 TapComment["Apply at levels 0 through 2:"], 
 TapTestSame[Apply[f, {{{{{a}}}}}, {0, 2}], f[f[f[{{a}}]]]], 
 TapComment["Apply at all levels, starting at level 1:"], 
 TapTestSame[Apply[f, {{{{{a}}}}}, Infinity], {f[f[f[f[a]]]]}], 
 TapComment["Apply also at level 0:"], 
 TapTestSame[Apply[f, {{{{{a}}}}}, {0, Infinity}], f[f[f[f[f[a]]]]]], 
 TapComment["Negative levels:"], TapTestSame[Apply[f, {{{{{a}}}}}, -1], 
  {f[f[f[f[a]]]]}], TapTestSame[Apply[f, {{{{{a}}}}}, -2], {f[f[f[f[a]]]]}], 
 TapTestSame[Apply[f, {{{{{a}}}}}, -3], {f[f[f[{a}]]]}], 
 TapComment["Positive and negative levels can be mixed:"], 
 TapTestSame[Apply[f, {{{{{a}}}}}, {2, -3}], {{f[f[{a}]]}}], 
 TapComment["Different heads at each level:"], 
 TapTestSame[Apply[f, h0[h1[h2[h3[h4[a]]]]], {2, -3}], h0[h1[f[f[h4[a]]]]]], 
 TapComment["Apply also inside heads at the levels specified:"], 
 TapTestSame[Apply[f, p[x][q[y]], {1}, Heads -> True], f[x][f[y]]], 
 TapComment["RefLink[Apply,paclet:ref/Apply] works with any head, not just \
RefLink[List,paclet:ref/List]:"], TapTestSame[Plus @@ g[x, y, z], x + y + z], 
 TapComment["RefLink[Apply,paclet:ref/Apply] works on sparse arrays:"], 
 TapTestSame[List @@ SparseArray[{1 -> 1, 2 -> 2, 10 -> 10}], 
  {1, 2, 0, 0, 0, 0, 0, 0, 0, 10}], 
 TapComment["Apply inside heads as well as arguments:"], 
 TapTestSame[Apply[f, p[x][q[y]], {1}, Heads -> True], f[x][f[y]]], 
 TapTestSame[Apply[f, p[x][q[y]], {1}], p[x][f[y]]], 
 TapComment["Display the factorization of an integer using superscripts:"], 
 TapTestSame[FactorInteger[20!], {{2, 18}, {3, 8}, {5, 4}, {7, 2}, {11, 1}, 
   {13, 1}, {17, 1}, {19, 1}}], TapTestSameBROKEN[
  CenterDot @@ Apply[Superscript, %, {1}], 2^18 \[CenterDot] 3^8 \[CenterDot] 
   5^4 \[CenterDot] 7^2 \[CenterDot] 11^1 \[CenterDot] 13^1 \[CenterDot] 
   17^1 \[CenterDot] 19^1], 
 TapComment["Create a table from a list of range specifications:"], 
 TapTestSame[(Table[i^j, ##1] & ) @@ {{i, 3}, {j, 4}}, 
  {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}], 
 TapTestSameBROKEN[cplus[{a, b, c}], a + b + c], 
 TapComment["Find random co-prime integers:"], 
 TapTestSameBROKEN[Select[RandomInteger[10, {20, 2}], Apply[CoprimeQ]], 
  {{5, 1}, {6, 7}, {9, 8}, {3, 10}, {7, 6}, {1, 8}, {1, 4}, {2, 3}, {1, 3}, 
   {2, 1}, {1, 10}, {5, 8}, {4, 5}}], TapComment["RefLink[Total,paclet:ref/To\
tal] does effectively the same thing as applying \
RefLink[Plus,paclet:ref/Plus] to a list:"], TapTestSame[Total[{a, b, c, d}], 
  a + b + c + d], TapTestSame[Plus @@ {a, b, c, d}, a + b + c + d], 
 TapComment["Using ## in a pure function has the same effect as using \
RefLink[Apply,paclet:ref/Apply]:"], TapTestSame[Plus @@ {1, 2, 3, 4}, 10], 
 TapTestSame[(Plus[##1] & )[1, 2, 3, 4], 10], 
 TapComment["Three ways to apply a function at level 1:"], 
 TapTestSame[Apply[f, {{a, b}, {c, d}}, {1}], {f[a, b], f[c, d]}], 
 TapTestSame[(f @@ #1 & ) /@ {{a, b}, {c, d}}, {f[a, b], f[c, d]}], 
 TapTestSame[Apply[f, {{a, b}, {c, d}}, {1}], {f[a, b], f[c, d]}], 
 TapComment[
  "Ordinary function application takes the list as a single argument:"], 
 TapTestSame[f[{a, b, c}], f[{a, b, c}]], TapComment["RefLink[Apply,paclet:re\
f/Apply] takes the elements of the list as separate arguments:"], 
 TapTestSame[f @@ {a, b, c}, f[a, b, c]], TapComment["Applying to atomic \
objects that do not have subparts effectively does nothing:"], 
 TapTestSame[f @@ a, a], TapTestSameBROKEN[Apply[f, {a, "string", 3}, {-1}], 
  {a, string, 3}]]
