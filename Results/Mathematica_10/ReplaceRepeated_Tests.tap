#! DOCKER > wolfram -script output/Tests/ReplaceRepeated_Tests.m
#! TextForm[ColonForm[MessageName[ReplaceRepeated, reps], StringForm[`1` is neither a list of replacement rules nor a valid dispatch table, and so cannot be used for replacing., Short[HoldForm[{rules}], 3]]]]
#! TextForm[ColonForm[MessageName[$RecursionLimit, reclim], StringForm[Recursion depth of `1` exceeded., Short[HoldForm[1024], 3]]]]
#! TextForm[ColonForm[MessageName[$RecursionLimit, reclim], StringForm[Recursion depth of `1` exceeded., Short[HoldForm[1024], 3]]]]
#! TextForm[ColonForm[MessageName[ReplaceAll, reps], StringForm[`1` is neither a list of replacement rules nor a valid dispatch table, and so cannot be used for replacing., Short[HoldForm[{Hold[Span[{Log[(x_)*(y_)] :> Log[x] + Log[y], Log[(x_)^(k_)] :> k*Log[x]}, Log[Sqrt[a*(b*c^d)^e]]]]}], 3]]]]
#! TextForm[ColonForm[MessageName[ReplaceAll, reps], StringForm[`1` is neither a list of replacement rules nor a valid dispatch table, and so cannot be used for replacing., Short[HoldForm[{Hold[Span[{Log[(x_)*(y_)] :> Log[x] + Log[y], Log[(x_)^(k_)] :> k*Log[x]}, Log[Sqrt[a*(b*c^d)^e]]]]}], 3]]]]
#! TextForm[ColonForm[MessageName[ReplaceAll, reps], StringForm[`1` is neither a list of replacement rules nor a valid dispatch table, and so cannot be used for replacing., Short[HoldForm[{Hold[Span[{Log[(x_)*(y_)] :> Log[x] + Log[y], Log[(x_)^(k_)] :> k*Log[x]}, Log[Sqrt[a*(b*c^d)^e]]]]}], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[ReplaceAll, reps]], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
# SYSTEM: Mathematica_10
# TEST: ReplaceRepeated_Tests
# Apply rules for the power and product laws for logarithms of real numbers recursively:
ok  rules = {Log[(x_)*(y_)] :> Log[x] + Log[y], Log[(x_)^(k_)] :> k*Log[x]} ;; Log[Sqrt[a*(b*c^d)^e]] //. rules    ==>     (1/2)*(Log[a] + e*(Log[b] + d*Log[c])) # skip
# RefLink[ReplaceAll,paclet:ref/ReplaceAll] does just a single replacement:
ok  Log[Sqrt[a*(b*c^d)^e]] /. rules    ==>     (1/2)*Log[a*(b*c^d)^e] # skip
# Undo "currying" of function arguments:
ok  f[a][b][c][d] //. (g_)[x_][y__] -> g[x, y]    ==>     f[a, b, c, d]
    ---
    data:
        got: f[a, b, c, d]
        expect: f[a, b, c, d]
        expect_evaluated: f[a, b, c, d]
    ...
