#! DOCKER > wolfram -script output/Tests/Mod_Tests.m
#! TextForm[ColonForm[MessageName[Floor, meprec], StringForm[Internal precision limit $MaxExtraPrecision = `1` reached while evaluating `2`., Short[HoldForm[50.], 3], Short[HoldForm[Floor[GoldenRatio^1000]], 3]]]]
#! TextForm[ColonForm[MessageName[Floor, meprec], StringForm[Internal precision limit $MaxExtraPrecision = `1` reached while evaluating `2`., Short[HoldForm[50.], 3], Short[HoldForm[Floor[GoldenRatio^1000]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: Mod_Tests
# Remainders mod 3:
ok  Mod[{1, 2, 3, 4, 5, 6, 7}, 3]    ==>     {1, 2, 0, 1, 2, 0, 1}
    ---
    data:
        got: {1, 2, 0, 1, 2, 0, 1}
        expect: {1, 2, 0, 1, 2, 0, 1}
        expect_evaluated: {1, 2, 0, 1, 2, 0, 1}
    ...
# Remainders mod 3 offset to start with 1:
ok  Mod[{1, 2, 3, 4, 5, 6, 7}, 3, 1]    ==>     {1, 2, 3, 1, 2, 3, 1}
    ---
    data:
        got: {1, 2, 3, 1, 2, 3, 1}
        expect: {1, 2, 3, 1, 2, 3, 1}
        expect_evaluated: {1, 2, 3, 1, 2, 3, 1}
    ...
# Plot the sequence with fixed modulus: 
ok  HoldComplete[DiscretePlot[Mod[n, 8], {n, 50}]]    ==>     $Failed # skip
# Plot the sequence, varying the modulus: 
ok  HoldComplete[DiscretePlot[Mod[100, m], {m, 50}]]    ==>     $Failed # skip
# Reduce an approximate number:
ok  Mod[4.56, 2]    ==>     0.56 # skip
# Reduce an exact numeric quantity:
ok  Mod[Exp[Pi], 2]    ==>     -22 + E^Pi
    ---
    data:
        got: -22 + E^Pi
        expect: -22 + E^Pi
        expect_evaluated: -22 + E^Pi
    ...
ok  N[%]    ==>     1.14069 # skip
# Reduce mod \[Pi]:
ok  Mod[20, Pi]    ==>     20 - 6*Pi
    ---
    data:
        got: 20 - 6*Pi
        expect: 20 - 6*Pi
        expect_evaluated: 20 - 6*Pi
    ...
# Complex number:
ok  Mod[Sqrt[-113], 2]    ==>     -10*I + I*Sqrt[113]
    ---
    data:
        got: -10*I + I*Sqrt[113]
        expect: -10*I + I*Sqrt[113]
        expect_evaluated: -10*I + I*Sqrt[113]
    ...
ok  Simplify[Mod[2*n + 1, 2], Element[n, Integers]]    ==>     1
    ---
    data:
        got: 1
        expect: 1
        expect_evaluated: 1
    ...
ok  Simplify[Mod[(1 + x)^16, 2], Element[x, Integers]]    ==>     Mod[1 + x^8, 2]
    ---
    data:
        got: Mod[1 + x^8, 2]
        expect: Mod[1 + x^8, 2]
        expect_evaluated: Mod[1 + x^8, 2]
    ...
# Wilson's theorem:
ok  FunctionExpand[Mod[(p - 1)!, p], Element[p, Primes]]    ==>     -1 + p
    ---
    data:
        got: -1 + p
        expect: -1 + p
        expect_evaluated: -1 + p
    ...
# Solve a modular equation:
ok  Reduce[Mod[2*x + 1, 5] == Mod[x, 7] && 0 < x < 50, x]    ==>     x == 4 || x == 7 || x == 15 || x == 23 || x == 31 || x == 39 || x == 42
    ---
    data:
        got: x == 4 || x == 7 || x == 15 || x == 23 || x == 31 || x == 39 || x == 42
        expect: x == 4 || x == 7 || x == 15 || x == 23 || x == 31 || x == 39 || x == 42
        expect_evaluated: x == 4 || x == 7 || x == 15 || x == 23 || x == 31 || x == 39 || x == 42
    ...
# Evaluate an integral:
ok  Integrate[Mod[x^2, 2], {x, 0, 4}]    ==>     (2/3)*(-46 + 9*Sqrt[2] + 6*Sqrt[3] + 3*Sqrt[6] + 3*Sqrt[10] + 3*Sqrt[14])
    ---
    data:
        got: (2*(-46 + 9*Sqrt[2] + 6*Sqrt[3] + 3*Sqrt[6] + 3*Sqrt[10] + 3*Sqrt[14]))/3
        expect: (2/3)*(-46 + 9*Sqrt[2] + 6*Sqrt[3] + 3*Sqrt[6] + 3*Sqrt[10] + 3*Sqrt[14])
        expect_evaluated: (2*(-46 + 9*Sqrt[2] + 6*Sqrt[3] + 3*Sqrt[6] + 3*Sqrt[10] + 3*Sqrt[14]))/3
    ...
# Extract parts cyclically:
ok  {a, b, c}[[Mod[Range[10], 3, 1]]]    ==>     {a, b, c, a, b, c, a, b, c, a}
    ---
    data:
        got: {a, b, c, a, b, c, a, b, c, a}
        expect: {a, b, c, a, b, c, a, b, c, a}
        expect_evaluated: {a, b, c, a, b, c, a, b, c, a}
    ...
# Select primes below 100 having the form of 6 k+1:
ok  Select[Array[Prime, PrimePi[100]], Mod[#1, 6] == 1 & ]    ==>     {7, 13, 19, 31, 37, 43, 61, 67, 73, 79, 97}
    ---
    data:
        got: {7, 13, 19, 31, 37, 43, 61, 67, 73, 79, 97}
        expect: {7, 13, 19, 31, 37, 43, 61, 67, 73, 79, 97}
        expect_evaluated: {7, 13, 19, 31, 37, 43, 61, 67, 73, 79, 97}
    ...
# Simulate a particle bouncing in a non-commensurate box:
ok  HoldComplete[Graphics[Line[Table[Mod[t, {Sqrt[2], 1}], {t, 0, 20, 0.001}]]]]    ==>     $Failed # skip
ok  (1 (+) 0) (+) 1    ==>     0 # skip
# The results have the same sign as the second argument:
ok  Mod[{-3, -2, -1, 0, 1, 2, 3}, 3]    ==>     {0, 1, 2, 0, 1, 2, 0}
    ---
    data:
        got: {0, 1, 2, 0, 1, 2, 0}
        expect: {0, 1, 2, 0, 1, 2, 0}
        expect_evaluated: {0, 1, 2, 0, 1, 2, 0}
    ...
ok  Mod[{-3, -2, -1, 0, 1, 2, 3}, -3]    ==>     {0, -2, -1, 0, -2, -1, 0}
    ---
    data:
        got: {0, -2, -1, 0, -2, -1, 0}
        expect: {0, -2, -1, 0, -2, -1, 0}
        expect_evaluated: {0, -2, -1, 0, -2, -1, 0}
    ...
ok  HoldComplete[Plot[Mod[x, 2], {x, -6, 6}]]    ==>     $Failed # skip
# Expressions generated by RefLink[Mod,paclet:ref/Mod] can be difficult to evaluate with machine precision:
ok  Mod[GoldenRatio^100, 1]    ==>     -792070839848372253126 + GoldenRatio^100
    ---
    data:
        got: -792070839848372253126 + GoldenRatio^100
        expect: -792070839848372253126 + GoldenRatio^100
        expect_evaluated: -792070839848372253126 + GoldenRatio^100
    ...
# Machine-precision numerical evaluation gives the wrong answer:
ok  N[%]    ==>     2.62144*10^6 # skip
# Arbitrary precision gives the correct answer:
ok  N[%%, 30]    ==>     0.999999999999999999998737486662`30. # skip
# Some computations may require higher internal precision than the default:
ok  Mod[GoldenRatio^1000, 1]    ==>     GoldenRatio^1000 - Floor[GoldenRatio^1000]
    ---
    data:
        got: GoldenRatio^1000 - Floor[GoldenRatio^1000]
        expect: GoldenRatio^1000 - Floor[GoldenRatio^1000]
        expect_evaluated: GoldenRatio^1000 - Floor[GoldenRatio^1000]
    ...
ok  Block[{$MaxExtraPrecision = Infinity}, Mod[GoldenRatio^1000, 1]]    ==>     -97194177735908175207981982079326473737797879155345685082728081084772518818444815269080619149045968297679578305403209347401163036907660573971740862463751801641201490284097309096322681531675707666695323797578126 + GoldenRatio^1000
    ---
    data:
        got: -97194177735908175207981982079326473737797879155345685082728081084772518818444815269080619149045968297679578305403209347401163036907660573971740862463751801641201490284097309096322681531675707666695323797578126 + GoldenRatio^1000
        expect: -97194177735908175207981982079326473737797879155345685082728081084772518818444815269080619149045968297679578305403209347401163036907660573971740862463751801641201490284097309096322681531675707666695323797578126 + GoldenRatio^1000
        expect_evaluated: -97194177735908175207981982079326473737797879155345685082728081084772518818444815269080619149045968297679578305403209347401163036907660573971740862463751801641201490284097309096322681531675707666695323797578126 + GoldenRatio^1000
    ...
ok  HoldComplete[ArrayPlot[Table[Mod[i, j], {i, 30}, {j, 30}]]]    ==>     $Failed # skip
# Binomial coefficients mod 2:
ok  HoldComplete[ArrayPlot[Table[Mod[Binomial[i, j], 2], {i, 0, 63}, {j, 0, 63}]]]    ==>     $Failed # skip
# Mod 4 additive cellular automaton:
ok  HoldComplete[ArrayPlot[CellularAutomaton[{Mod[Total[#1], 4] & , {}, 1}, {{1}, 0}, 50]]]    ==>     $Failed # skip
