#! DOCKER > wolfram -script output/Tests/DownValues_Tests.m
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[SetDelayed, write], StringForm[Tag `1` in `2` is Protected., Short[HoldForm[Span], 3], Short[HoldForm[Span[{g[1] :> 1, g[x_] :> 2*g[x - 1]}, g[1]]], 3]]]]
#! TextForm[ColonForm[MessageName[DownValues, vlist], StringForm[Cannot set `1` to `2`; value must be a list of rules., Short[HoldForm[DownValues[g]], 3], Short[HoldForm[$Failed], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
#! TextForm[ColonForm[MessageName[RuleDelayed, rhs], StringForm[Pattern `1` appears on the right-hand side of rule `2`., Short[HoldForm[x_], 3], Short[HoldForm[f[x_ /; x > -2] :> (g1[x]*f[x_ /; x < 2] := g2[x])], 3]]]]
#! TextForm[ColonForm[MessageName[RuleDelayed, rhs], StringForm[Pattern `1` appears on the right-hand side of rule `2`., Short[HoldForm[x_], 3], Short[HoldForm[HoldPattern[f[x_ /; x > -2]] :> (g1[x]*f[x_ /; x < 2] := g2[x])], 3]]]]
#! TextForm[ColonForm[MessageName[RuleDelayed, rhs], StringForm[Pattern `1` appears on the right-hand side of rule `2`., Short[HoldForm[x_], 3], Short[HoldForm[(x_ /; x > -2)^2 :> (g1[x]*f[x_ /; x < 2] := g2[x])], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[RuleDelayed, rhs]], 3]]]]
#! TextForm[ColonForm[MessageName[SetDelayed, write], StringForm[Tag `1` in `2` is Protected., Short[HoldForm[Times], 3], Short[HoldForm[(Pattern[0, _] /; 0 < 2)^2*g1[0]], 3]]]]
#! TextForm[ColonForm[MessageName[$RecursionLimit, reclim], StringForm[Recursion depth of `1` exceeded., Short[HoldForm[1024], 3]]]]
#! TextForm[ColonForm[MessageName[$RecursionLimit, reclim], StringForm[Recursion depth of `1` exceeded., Short[HoldForm[1024], 3]]]]
#! TextForm[ColonForm[MessageName[$RecursionLimit, reclim], StringForm[Recursion depth of `1` exceeded., Short[HoldForm[1024], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$RecursionLimit, reclim]], 3]]]]
#! TextForm[ColonForm[MessageName[SetDelayed, write], StringForm[Tag `1` in `2` is Protected., Short[HoldForm[Times], 3], Short[HoldForm[1*(x_)^3], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[SetDelayed, write]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: DownValues_Tests
# These are the downvalues associated with f:
ok  DownValues[f]    ==>     {HoldPattern[f[1]] :> 2, HoldPattern[f[2]] :> 3, HoldPattern[f[x_]] :> x^2} # skip
# RefLink[DownValues,paclet:ref/DownValues] returns rules corresponding to definitions made for a symbol:
ok  f[x_] := x^2; DownValues[f]    ==>     {HoldPattern[f[x_]] :> x^2}
    ---
    data:
        got:      2     2
#! {(x_)  :> x }
        expect: {HoldPattern[f[x_]] :> x^2}
        expect_evaluated:      2     2
#! {(x_)  :> x }
    ...
# RefLink[DownValues,paclet:ref/DownValues] can be used to set the values directly:
ok  DownValues[g] = {g[1] :> 1, g[x_] :> 2*g[x - 1]} ;; g[1] := 1*g[x_] := 2*g[x - 1]*g[x_ /; x < 2] := g2[x]*g[x_ /; x > -2] := g1[x]    ==>     g[1] := 1*g[x_] := 2*g[x - 1] # skip
not ok  g[5]    ==>     16
    ---
    data:
        got: g[5]
        expect: 16
        expect_evaluated: 16
    ...
# The resulting rules are in the order given: 
ok  f[x_ /; x > -2] := g1[x]*f[x_ /; x < 2] := g2[x]; DownValues[f]    ==>     {HoldPattern[f[x_ /; x > -2]] :> g1[x], HoldPattern[f[x_ /; x < 2]] :> g2[x]} # skip
not ok  f[0]    ==>     g1[0]
    ---
    data:
        got: $Failed
        expect: g1[0]
        expect_evaluated: g1[0]
    ...
# Now reorder the definitions: 
ok  DownValues[f] = Reverse[DownValues[f]]    ==>     {HoldPattern[f[x_ /; x < 2]] :> g2[x], HoldPattern[f[x_ /; x > -2]] :> g1[x]} # skip
ok  f[0]    ==>     g2[0] # skip
# Copy a symbol's definitions to another symbol:
ok  f[1] = 1; f[x_] := 2*f[x - 1]; DownValues[g] = DownValues[f] /. f -> g    ==>     {HoldPattern[g[1]] :> 1, HoldPattern[g[x_]] :> 2*g[x - 1]} # skip
ok  g[10]    ==>     512
    ---
    data:
        got: 512
        expect: 512
        expect_evaluated: 512
    ...
# Values can be defined by immediate or delayed assignments:
ok  f[1] = 1; f[n_] := n*f[n - 1]; DownValues[f]    ==>     {HoldPattern[f[1]] :> 1, HoldPattern[f[n_]] :> n*f[n - 1]} # skip
# RefLink[HoldPattern,paclet:ref/HoldPattern] is used to protect the rules from their own definitions:
ok  f[x_] := x^2; DownValues[f]    ==>     {HoldPattern[f[x_]] :> x^2} # skip
ok  f[x_] :> x^2    ==>     (x_)^2 :> x^2
    ---
    data:
        got:     2     2
#! (x_)  :> x
        expect: (x_)^2 :> x^2
        expect_evaluated:     2     2
#! (x_)  :> x
    ...
# RefLink[Definition,paclet:ref/Definition] and RefLink[Information,paclet:ref/Information] display downvalues but do not return them as values:
ok  f[x_] := x^3; f[1] = 1*f[x_] := x^3*f[x_ /; x < 2] := g2[x]*f[x_ /; x > -2] := g1[x]    ==>     f[x_] := x^3 # skip
# RefLink[DownValues,paclet:ref/DownValues] returns a value that can be used in a program:
ok  DownValues[f]    ==>     {HoldPattern[f[x_]] :> x^3} # skip
# Evaluation of an expression involves applying rules for its head:
ok  f[x_] := x^3; Hold[f[2]] /. DownValues[f]    ==>     Hold[2^3]
    ---
    data:
        got: 8
        expect: Hold[2^3]
        expect_evaluated: 8
    ...
