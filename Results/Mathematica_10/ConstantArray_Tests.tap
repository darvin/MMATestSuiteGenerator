#! DOCKER > wolfram -script output/Tests/ConstantArray_Tests.m
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
#! TextForm[ColonForm[MessageName[ListPlot, lpn], StringForm[`1` is not a list of numbers or pairs of numbers., Short[HoldForm[sol], 3]]]]
#! TextForm[ColonForm[MessageName[$RecursionLimit, reclim], StringForm[Recursion depth of `1` exceeded., Short[HoldForm[1024], 3]]]]
#! TextForm[ColonForm[MessageName[Set, write], StringForm[Tag `1` in `2` is Protected., Short[HoldForm[Span], 3], Short[HoldForm[Span[{2, 2, 4, 2, 1}, s]], 3]]]]
#! TextForm[ColonForm[MessageName[ConstantArray, ilsmn], StringForm[Single or list of non-negative machine-sized integers expected at position `2` of `1`., Short[HoldForm[ConstantArray[c, SparseArray[Automatic, Raw[System`Private`PackedList, 307148ee], c, {1, {Raw[System`Private`PackedList, 60db70ee], {}}, {}}]]], 3], Short[HoldForm[2], 3]]]]
#! TextForm[ColonForm[MessageName[ConstantArray, ilsmn], StringForm[Single or list of non-negative machine-sized integers expected at position `2` of `1`., Short[HoldForm[ConstantArray[c, SparseArray[Automatic, Raw[System`Private`PackedList, 307148ee], c, {1, {Raw[System`Private`PackedList, 60db70ee], {}}, {}}]]], 3], Short[HoldForm[2], 3]]]]
#! TextForm[ColonForm[MessageName[ConstantArray, ilsmn], StringForm[Single or list of non-negative machine-sized integers expected at position `2` of `1`., Short[HoldForm[ConstantArray[c, SparseArray[Automatic, Raw[System`Private`PackedList, 307148ee], c, {1, {Raw[System`Private`PackedList, 60db70ee], {}}, {}}]]], 3], Short[HoldForm[2], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[ConstantArray, ilsmn]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: ConstantArray_Tests
# Make a vector of 10 c's:
ok  ConstantArray[c, 10]    ==>     {c, c, c, c, c, c, c, c, c, c}
    ---
    data:
        got: {c, c, c, c, c, c, c, c, c, c}
        expect: {c, c, c, c, c, c, c, c, c, c}
        expect_evaluated: {c, c, c, c, c, c, c, c, c, c}
    ...
# Make a 3*4 array of c's:
ok  ConstantArray[c, {3, 4}]    ==>     {{c, c, c, c}, {c, c, c, c}, {c, c, c, c}}
    ---
    data:
        got: {{c, c, c, c}, {c, c, c, c}, {c, c, c, c}}
        expect: {{c, c, c, c}, {c, c, c, c}, {c, c, c, c}}
        expect_evaluated: {{c, c, c, c}, {c, c, c, c}, {c, c, c, c}}
    ...
# A machine-zero vector:
ok  ConstantArray[0., 10]    ==>     {0., 0., 0., 0., 0., 0., 0., 0., 0., 0.}
    ---
    data:
        got: {0., 0., 0., 0., 0., 0., 0., 0., 0., 0.}
        expect: {0., 0., 0., 0., 0., 0., 0., 0., 0., 0.}
        expect_evaluated: {0., 0., 0., 0., 0., 0., 0., 0., 0., 0.}
    ...
# A vector of exact zeros:
ok  ConstantArray[0, 10]    ==>     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    ---
    data:
        got: {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        expect: {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        expect_evaluated: {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    ...
# A machine-zero matrix:
ok  zm = ConstantArray[0., {3, 3}]    ==>     {{0., 0., 0.}, {0., 0., 0.}, {0., 0., 0.}}
    ---
    data:
        got: {{0., 0., 0.}, {0., 0., 0.}, {0., 0., 0.}}
        expect: {{0., 0., 0.}, {0., 0., 0.}, {0., 0., 0.}}
        expect_evaluated: {{0., 0., 0.}, {0., 0., 0.}, {0., 0., 0.}}
    ...
# A matrix of exact zeros:
ok  ConstantArray[0, {3, 3}]    ==>     {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}
    ---
    data:
        got: {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}
        expect: {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}
        expect_evaluated: {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}
    ...
# A vector of ones:
ok  ConstantArray[1, 10]    ==>     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
    ---
    data:
        got: {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
        expect: {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
        expect_evaluated: {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
    ...
# A machine-number vector of ones:
ok  ConstantArray[1., 10]    ==>     {1., 1., 1., 1., 1., 1., 1., 1., 1., 1.}
    ---
    data:
        got: {1., 1., 1., 1., 1., 1., 1., 1., 1., 1.}
        expect: {1., 1., 1., 1., 1., 1., 1., 1., 1., 1.}
        expect_evaluated: {1., 1., 1., 1., 1., 1., 1., 1., 1., 1.}
    ...
# A deeply nested constant array:
ok  ConstantArray[x, {2, 1, 2, 1, 2}]    ==>     {{{{{x, x}}, {{x, x}}}}, {{{{x, x}}, {{x, x}}}}}
    ---
    data:
        got: {{{{{x, x}}, {{x, x}}}}, {{{{x, x}}, {{x, x}}}}}
        expect: {{{{{x, x}}, {{x, x}}}}, {{{{x, x}}, {{x, x}}}}}
        expect_evaluated: {{{{{x, x}}, {{x, x}}}}, {{{{x, x}}, {{x, x}}}}}
    ...
# Numerically solve x'[t]==1/(t+x[t]^2) using Euler's method:
ok  HoldComplete[sol = esteps[Function[{t, x}, 1/(t + x^2)], 1, 0.01, 100] ;; ListPlot[sol, DataRange -> {0, 1}]]    ==>     $Failed # skip
# Find the sum of the elements in a list:
ok  list = RandomInteger[9, 20]    ==>     {4, 0, 2, 3, 9, 3, 2, 9, 8, 2, 2, 7, 1, 6, 7, 9, 2, 3, 1, 1} # skip
ok  list . ConstantArray[1, Length[list]]    ==>     81 # skip
# This can also be done with RefLink[Total,paclet:ref/Total]:
ok  Total[list]    ==>     81 # skip
# Use a vector of ones to see the effects of conditioning on the solution of a linear system:
ok  ones = ConstantArray[1, 10]    ==>     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
    ---
    data:
        got: {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
        expect: {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
        expect_evaluated: {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
    ...
# The solution at machine precision has significant errors:
ok  x = LinearSolve[N[m], b]    ==>     {1., 1., 1., 0.999971, 1.00014, 0.999631, 1.0006, 0.999422, 1.0003, 0.999934} # skip
ok  Norm[x - ones]    ==>     0.00097329 # skip
# At higher precision, the solution is much better:
ok  x30 = LinearSolve[N[m, 30], b]; Norm[Block[{$MaxPrecision = 30, $MinPrecision = 30}, x30 - ones]]    ==>     3.42707739967263571112712880383`29.5349239129712/10^36 # skip
# RefLink[ConstantArray,paclet:ref/ConstantArray][c,dims] has RefLink[Dimensions,paclet:ref/Dimensions][dims]:
ok  dims = RandomInteger[{1, 4}, 5]    ==>     {3, 1, 3, 4, 3} # skip
ok  Dimensions[ConstantArray[c, dims]]    ==>     {3, 1, 3, 4, 3} # skip
# RefLink[ConstantArray,paclet:ref/ConstantArray][c,dims] is equal to RefLink[SparseArray,paclet:ref/SparseArray][{},dims,c]:
ok  HoldComplete[dims = RandomInteger[{1, 4}, 5] ;; s = SparseArray[{}, dims, c]]    ==>     $Failed # skip
ok  ConstantArray[c, dims] == s    ==>     True # skip
# RefLink[Normal,paclet:ref/Normal][s] is identical to RefLink[ConstantArray,paclet:ref/ConstantArray][c,dims]:
ok  ConstantArray[c, dims] === Normal[s]    ==>     True # skip
# RefLink[ConstantArray,paclet:ref/ConstantArray][c,dims] is equivalent to RefLink[Apply,paclet:ref/Apply][RefLink[Table,paclet:ref/Table][c,##]&,RefLink[Map,paclet:ref/Map][RefLink[List,paclet:ref/List],dims]]:
ok  dims = RandomInteger[{1, 4}, 5] ;; ConstantArray[c, dims] === (Table[c, ##1] & ) @@ List /@ dims    ==>     True # skip
