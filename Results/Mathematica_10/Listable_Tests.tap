#! DOCKER > wolfram -script output/Tests/Listable_Tests.m
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
#! TextForm[ColonForm[MessageName[Table, iterb], StringForm[Iterator `1` does not have appropriate bounds., Short[HoldForm[{x, v}], 3]]]]
#! TextForm[ColonForm[MessageName[SparseArray, adims], StringForm[Array dimension specification `1` should be Automatic, a non-negative machine integer, or a list of non-negative machine integers., Short[HoldForm[{1 + n, 1 + n}], 3], Short[HoldForm[SparseArray[{{i_, i_} -> -2., {i_, j_} /; Abs[i - j] == 1 -> 1.}, {1 + n, 1 + n}, 0.]], 3]]]]
#! TextForm[ColonForm[MessageName[Power, indet], StringForm[Indeterminate expression `1` encountered., Short[HoldForm[0.^0.], 3]]]]
#! TextForm[ColonForm[MessageName[SparseArray, adims], StringForm[Array dimension specification `1` should be Automatic, a non-negative machine integer, or a list of non-negative machine integers., Short[HoldForm[0.], 3], Short[HoldForm[SparseArray[{{i_, i_} -> -2., {i_, j_} /; Abs[i - j] == 1 -> 1.}, 0., 0.]], 3]]]]
#! TextForm[ColonForm[MessageName[SparseArray, list], StringForm[List expected at position `2` in `1`., Short[HoldForm[SparseArray[Indeterminate]], 3], Short[HoldForm[1], 3]]]]
#! TextForm[ColonForm[MessageName[ListPlot, lpn], StringForm[`1` is not a list of numbers or pairs of numbers., Short[HoldForm[UnitStep[-0.5 + x]], 3]]]]
#! TextForm[ColonForm[MessageName[ListPlot, lpn], StringForm[`1` is not a list of numbers or pairs of numbers., Short[HoldForm[UnitStep[-0.5 + x]], 3]]]]
#! TextForm[ColonForm[MessageName[ListPlot, lpn], StringForm[`1` is not a list of numbers or pairs of numbers., Short[HoldForm[LinearSolve[IdentityMatrix[1 + n, SparseArray] - 0.001*SparseArray[Indeterminate]][LinearSolve[IdentityMatrix[1 + n, SparseArray] - 0.001*SparseArray[Indeterminate]][LinearSolve[IdentityMatrix[1 + n, SparseArray] - 0.001*SparseArray[Indeterminate]][LinearSolve[IdentityMatrix[1 + n, SparseArray] - 0.001*SparseArray[Indeterminate]][LinearSolve[IdentityMatrix[1 + n, SparseArray] - 0.001*SparseArray[Indeterminate]][LinearSolve[IdentityMatrix[1 + n, SparseArray] - 0.001*SparseArray[Indeterminate]][LinearSolve[IdentityMatrix[1 + n, SparseArray] - 0.001*SparseArray[Indeterminate]][LinearSolve[IdentityMatrix[1 + n, SparseArray] - 0.001*SparseArray[Indeterminate]][LinearSolve[IdentityMatrix[1 + n, SparseArray] - 0.001*SparseArray[Indeterminate]][LinearSolve[IdentityMatrix[1 + n, SparseArray] - 0.001*SparseArray[Indeterminate]][UnitStep[-0.5 + x]]]]]]]]]]]], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[ListPlot, lpn]], 3]]]]
#! TextForm[ColonForm[MessageName[Thread, tdlen], StringForm[Objects of unequal length in `1` cannot be combined., Short[HoldForm[{a, b, c}^{1, 2}], 3]]]]
#! TextForm[ColonForm[MessageName[Thread, tdlen], StringForm[Objects of unequal length in `1` cannot be combined., Short[HoldForm[{Log[a], Log[b], Log[c]}*{1, 2}], 3]]]]
#! TextForm[ColonForm[MessageName[Thread, tdlen], StringForm[Objects of unequal length in `1` cannot be combined., Short[HoldForm[{a, b, c}^{1, 2}], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[Thread, tdlen]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: Listable_Tests
# RefLink[Log,paclet:ref/Log] is listable:
ok  Log[{a, b, c}]    ==>     {Log[a], Log[b], Log[c]}
    ---
    data:
        got: {Log[a], Log[b], Log[c]}
        expect: {Log[a], Log[b], Log[c]}
        expect_evaluated: {Log[a], Log[b], Log[c]}
    ...
ok  Attributes[Log]    ==>     {Listable, NumericFunction, Protected}
    ---
    data:
        got: {Listable, NumericFunction, Protected}
        expect: {Listable, NumericFunction, Protected}
        expect_evaluated: {Listable, NumericFunction, Protected}
    ...
# Listable functions combine corresponding elements:
ok  {a, b, c} + {x, y, z}    ==>     {a + x, b + y, c + z}
    ---
    data:
        got: {a + x, b + y, c + z}
        expect: {a + x, b + y, c + z}
        expect_evaluated: {a + x, b + y, c + z}
    ...
# Arguments that are not lists are replicated as needed:
ok  {a, b, c} + x    ==>     {a + x, b + x, c + x}
    ---
    data:
        got: {a + x, b + x, c + x}
        expect: {a + x, b + x, c + x}
        expect_evaluated: {a + x, b + x, c + x}
    ...
ok  {{a, b}, {c, d}} + x    ==>     {{a + x, b + x}, {c + x, d + x}}
    ---
    data:
        got: {{a + x, b + x}, {c + x, d + x}}
        expect: {{a + x, b + x}, {c + x, d + x}}
        expect_evaluated: {{a + x, b + x}, {c + x, d + x}}
    ...
# Define a function to be listable:
ok  f[x_] := If[x > 0, Sqrt[x], Sqrt[-x]]; SetAttributes[f, Listable] ;; f[{3, 0, -2}]    ==>     {Sqrt[3], 0, Sqrt[2]} # skip
# Most built-in mathematical functions are listable:
ok  Attributes[Power]    ==>     {Listable, NumericFunction, OneIdentity, Protected}
    ---
    data:
        got: {Listable, NumericFunction, OneIdentity, Protected}
        expect: {Listable, NumericFunction, OneIdentity, Protected}
        expect_evaluated: {Listable, NumericFunction, OneIdentity, Protected}
    ...
ok  {a, b, c}^{1, 2, 3}    ==>     {a, b^2, c^3}
    ---
    data:
        got:      2   3
#! {a, b , c }
        expect: {a, b^2, c^3}
        expect_evaluated:      2   3
#! {a, b , c }
    ...
ok  {a, b, c}^5    ==>     {a^5, b^5, c^5}
    ---
    data:
        got:   5   5   5
#! {a , b , c }
        expect: {a^5, b^5, c^5}
        expect_evaluated:   5   5   5
#! {a , b , c }
    ...
# Listability works for any nesting depth of lists:
ok  Sqrt[{{1, 2}, {3, 4}}]    ==>     {{1, Sqrt[2]}, {Sqrt[3], 2}}
    ---
    data:
        got: {{1, Sqrt[2]}, {Sqrt[3], 2}}
        expect: {{1, Sqrt[2]}, {Sqrt[3], 2}}
        expect_evaluated: {{1, Sqrt[2]}, {Sqrt[3], 2}}
    ...
# The nesting level of the different arguments need not be the same:
ok  {{a, b}, {c, d}}^{2, 3}    ==>     {{a^2, b^2}, {c^3, d^3}}
    ---
    data:
        got:    2   2     3   3
#! {{a , b }, {c , d }}
        expect: {{a^2, b^2}, {c^3, d^3}}
        expect_evaluated:    2   2     3   3
#! {{a , b }, {c , d }}
    ...
# Listability works also with sparse arrays:
ok  HoldComplete[Exp[SparseArray[{1 -> 1, 2 -> 2, 10 -> 10}]]]    ==>     $Failed # skip
ok  Normal[%]    ==>     {E, E^2, 1, 1, 1, 1, 1, 1, 1, E^10} # skip
# Use the listability of RefLink[Plus,paclet:ref/Plus], RefLink[Power,paclet:ref/Power], RefLink[Sin,paclet:ref/Sin], and RefLink[Times,paclet:ref/Times]:
ok  Timing[fvl = Sin[2*Pi*(v - 0.5)^2]; ]    ==>     {0.151, Null} # skip
# Use RefLink[Map,paclet:ref/Map]:
ok  Timing[fvm = (Sin[2*Pi*(#1 - 0.5)^2] & ) /@ v; ]    ==>     {0.53, Null} # skip
# Use RefLink[Table,paclet:ref/Table]:
ok  Timing[fvt = Table[Sin[2*Pi*(x - 0.5)^2], {x, v}]; ]    ==>     {0.571, Null} # skip
# Use RefLink[Table,paclet:ref/Table] and RefLink[Part,paclet:ref/Part] to access elements of v as might be done in a lower-level language:
ok  Timing[fvp = Table[Sin[2*Pi*(v[[i]] - 0.5)^2], {i, Length[v]}]; ]    ==>     {0.631, Null} # skip
# The results are the same up to numerical roundoff:
ok  {Norm[fvl - fvm], Norm[fvl - fvt], Norm[fvl - fvp]}    ==>     {1.12688/10^15, 1.12688/10^15, 1.12688/10^15} # skip
# Matrix for a second-order approximation to the second derivative on the grid x:
ok  HoldComplete[d2 = n^2*SparseArray[{{i_, i_} -> -2., {i_, j_} /; Abs[i - j] == 1 -> 1.}, {n + 1, n + 1}, 0.]]    ==>     $Failed # skip
# Incorporate Dirichlet boundary conditions to form the Jacobian J:
ok  HoldComplete[j = d2; j[[1,{1, 2}]] = 0.; j[[-1,{-1, -2}]] = 0.; j = SparseArray[j]]    ==>     $Failed # skip
# The sparse identity matrix:
ok  HoldComplete[id = IdentityMatrix[n + 1, SparseArray]]    ==>     $Failed # skip
# Form sparse matrix m=I-h J for h=0.01 using the listability of arithmetic:
ok  HoldComplete[m = id - 0.001*j]    ==>     $Failed # skip
# LU decomposition of m in a functional form:
ok  HoldComplete[lu = LinearSolve[m]]    ==>     $Failed # skip
# Step initial condition on spatial grid x using the listability of RefLink[UnitStep,paclet:ref/UnitStep]:
ok  HoldComplete[init = UnitStep[x - 0.5]; ListPlot[init, DataRange -> {0, 1}]]    ==>     $Failed # skip
# Get the solution at t=10, h=0.01 using the backward Euler method:
ok  HoldComplete[sol = init; Do[sol = lu[sol], {10}]; ListPlot[sol, DataRange -> {0, 1}]]    ==>     $Failed # skip
# Listability is the same as automatic threading:
ok  SetAttributes[f, Listable] ;; f[{1, 2, 3}]    ==>     {f[1], f[2], f[3]} # skip
ok  g[{1, 2, 3}]    ==>     g[{1, 2, 3}]
    ---
    data:
        got: g[{1, 2, 3}]
        expect: g[{1, 2, 3}]
        expect_evaluated: g[{1, 2, 3}]
    ...
ok  Thread[g[{1, 2, 3}]]    ==>     {g[1], g[2], g[3]}
    ---
    data:
        got: {g[1], g[2], g[3]}
        expect: {g[1], g[2], g[3]}
        expect_evaluated: {g[1], g[2], g[3]}
    ...
# A function implemented in terms of a listable operation may not need the RefLink[Listable,paclet:ref/Listable] attribute:
ok  g[x_] := x^2; g[{1, 2, 3}]    ==>     {1, 4, 9}
    ---
    data:
        got: {1, 4, 9}
        expect: {1, 4, 9}
        expect_evaluated: {1, 4, 9}
    ...
ok  Attributes[Power]    ==>     {Listable, NumericFunction, OneIdentity, Protected}
    ---
    data:
        got: {Listable, NumericFunction, OneIdentity, Protected}
        expect: {Listable, NumericFunction, OneIdentity, Protected}
        expect_evaluated: {Listable, NumericFunction, OneIdentity, Protected}
    ...
# The system symbols with the RefLink[Listable,paclet:ref/Listable] attribute: 
ok  HoldComplete[listable = Select[Names["System`*"], MemberQ[Attributes[#1], Listable] & ]; Short[listable, 4]]    ==>     $Failed # skip
# Many of these are arithmetic or numerical functions:
ok  {Length[listable], Length[Select[listable, MemberQ[Attributes[#1], NumericFunction] & ]]}    ==>     {308, 191} # skip
# The inner product of two vectors:
ok  u . v    ==>     a + 2*b + 3*c + 4*d # skip
# The vector resulting from the product of corresponding elements:
ok  u*v    ==>     {a, 2*b, 3*c, 4*d} # skip
# The matrix resulting from the outer product of the vectors:
ok  MatrixForm[KroneckerProduct[u, v]]    ==>     a*2*a*3*a*4*a*b*2*b*3*b*4*b*c*2*c*3*c*4*c*d*2*d*3*d*4*d # skip
# All list arguments must have the same length:
ok  {a, b, c}^{1, 2}    ==>     {a, b, c}^{1, 2}
    ---
    data:
        got:          {1, 2}
#! {a, b, c}
        expect: {a, b, c}^{1, 2}
        expect_evaluated:          {1, 2}
#! {a, b, c}
    ...
