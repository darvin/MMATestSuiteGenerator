#! DOCKER > wolfram -script output/Tests/PolynomialQuotientRemainder_Tests.m
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
#! TextForm[ColonForm[MessageName[Set, write], StringForm[Tag `1` in `2` is Protected., Short[HoldForm[Span], 3], Short[HoldForm[Span[{1 + 2*x + x^2, 2 + x}, {q, r}]], 3]]]]
#! TextForm[ColonForm[MessageName[$RecursionLimit, reclim], StringForm[Recursion depth of `1` exceeded., Short[HoldForm[1024], 3]]]]
#! TextForm[ColonForm[MessageName[$RecursionLimit, reclim], StringForm[Recursion depth of `1` exceeded., Short[HoldForm[1024], 3]]]]
#! TextForm[ColonForm[MessageName[$RecursionLimit, reclim], StringForm[Recursion depth of `1` exceeded., Short[HoldForm[1024], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$RecursionLimit, reclim]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: PolynomialQuotientRemainder_Tests
# Find the quotient and remainder after dividing one polynomial by another:
ok  PolynomialQuotientRemainder[x^2, x + a, x]    ==>     {-a + x, a^2}
    ---
    data:
        got:           2
#! {-a + x, a }
        expect: {-a + x, a^2}
        expect_evaluated:           2
#! {-a + x, a }
    ...
# The resulting polynomial will have coefficients that are rational expressions of input coefficients:
ok  PolynomialQuotientRemainder[x^2 + x + 1, 2*x + 1, x]    ==>     {1/4 + x/2, 3/4}
    ---
    data:
        got:  1   x  3
#! {- + -, -}
#!  4   2  4
        expect: {1/4 + x/2, 3/4}
        expect_evaluated:  1   x  3
#! {- + -, -}
#!  4   2  4
    ...
ok  PolynomialQuotientRemainder[x^2 + b*x + 1, a*x + 1, x]    ==>     {-(1/a^2) + b/a + x/a, 1 + 1/a^2 - b/a}
    ---
    data:
        got:    -2   b   x       -2   b
#! {-a   + - + -, 1 + a   - -}
        a   a            a
        expect: {-(1/a^2) + b/a + x/a, 1 + 1/a^2 - b/a}
        expect_evaluated:    -2   b   x       -2   b
#! {-a   + - + -, 1 + a   - -}
        a   a            a
    ...
ok  PolynomialQuotientRemainder[x^2 + x + 1, Pi*x + 1, x]    ==>     {-(1/Pi^2) + 1/Pi + x/Pi, 1 + 1/Pi^2 - 1/Pi}
    ---
    data:
        got:     -2   1    x         -2   1
#! {-Pi   + -- + --, 1 + Pi   - --}
         Pi   Pi             Pi
        expect: {-(1/Pi^2) + 1/Pi + x/Pi, 1 + 1/Pi^2 - 1/Pi}
        expect_evaluated:     -2   1    x         -2   1
#! {-Pi   + -- + --, 1 + Pi   - --}
         Pi   Pi             Pi
    ...
# RefLink[PolynomialQuotientRemainder,paclet:ref/PolynomialQuotientRemainder] also works for rational functions:
ok  PolynomialQuotientRemainder[(x + 1)/(x + 2), (x + 1)/(x + 3), x]    ==>     {(3 + x)/(2 + x), 0}
    ---
    data:
        got:  3 + x
#! {-----, 0}
#!  2 + x
        expect: {(3 + x)/(2 + x), 0}
        expect_evaluated:  3 + x
#! {-----, 0}
#!  2 + x
    ...
# Use a prime modulus:
ok  PolynomialQuotientRemainder[x^2 + 4*x + 1, 2*x + 1, x, Modulus -> 2]    ==>     {1 + x^2, 0}
    ---
    data:
        got:       2
#! {1 + x , 0}
        expect: {1 + x^2, 0}
        expect_evaluated:       2
#! {1 + x , 0}
    ...
ok  PolynomialQuotientRemainder[x^2 + 4*x + 1, 2*x + 1, x, Modulus -> 3]    ==>     {1 + 2*x, 0}
    ---
    data:
        got: {1 + 2 x, 0}
        expect: {1 + 2*x, 0}
        expect_evaluated: {1 + 2 x, 0}
    ...
# Express the rational function as a polynomial and simple fraction:
ok  {f, g} = {x^2 + 2*x + 1, x + 2} ;; {q, r} = PolynomialQuotientRemainder[f, g, x]    ==>     {x, 1} # skip
# The transformed rational function:
ok  f/g == q + r/g    ==>     (1 + 2*x + x^2)/(2 + x) == x + 1/(2 + x) # skip
ok  Simplify[%]    ==>     True # skip
# For a polynomial f, f==g q+r:
ok  {f, g} = {x^2 + 4*x + 1, x + 2} ;; {q, r} = PolynomialQuotientRemainder[f, g, x]    ==>     {2 + x, -3} # skip
# Use RefLink[Expand,paclet:ref/Expand] to verify identity:
ok  Expand[q*g + r] == f    ==>     True # skip
# RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient] and RefLink[PolynomialRemainder,paclet:ref/PolynomialRemainder]: 
ok  {PolynomialQuotient[f, g, x], PolynomialRemainder[f, g, x]}    ==>     {2 + x, -3} # skip
# RefLink[PolynomialReduce,paclet:ref/PolynomialReduce] generalizes RefLink[PolynomialQuotientRemainder,paclet:ref/PolynomialQuotientRemainder] for multivariate polynomials:
ok  PolynomialReduce[x^2 + 4*x + 1, {x + 2}, {x}]    ==>     {{2 + x}, -3}
    ---
    data:
        got: {{2 + x}, -3}
        expect: {{2 + x}, -3}
        expect_evaluated: {{2 + x}, -3}
    ...
ok  PolynomialQuotientRemainder[x^2 + 4*x + 1, x + 2, x]    ==>     {2 + x, -3}
    ---
    data:
        got: {2 + x, -3}
        expect: {2 + x, -3}
        expect_evaluated: {2 + x, -3}
    ...
