#! DOCKER > wolfram -script output/Tests/PolynomialQuotientRemainder_Tests.m
# SYSTEM: Mathematica_10
# TEST: PolynomialQuotientRemainder_Tests
# Find the quotient and remainder after dividing one polynomial by another:
ok  PolynomialQuotientRemainder[x^2, x + a, x]    ==>     {-a + x, a^2}
    ---
    data:
        got: {-a + x, a^2}
        expect: {-a + x, a^2}
        expect_evaluated: {-a + x, a^2}
    ...
# The resulting polynomial will have coefficients that are rational expressions of input coefficients:
ok  PolynomialQuotientRemainder[x^2 + x + 1, 2*x + 1, x]    ==>     {1/4 + x/2, 3/4}
    ---
    data:
        got: {1/4 + x/2, 3/4}
        expect: {1/4 + x/2, 3/4}
        expect_evaluated: {1/4 + x/2, 3/4}
    ...
ok  PolynomialQuotientRemainder[x^2 + b*x + 1, a*x + 1, x]    ==>     {-(1/a^2) + b/a + x/a, 1 + 1/a^2 - b/a}
    ---
    data:
        got: {-a^(-2) + b/a + x/a, 1 + a^(-2) - b/a}
        expect: {-(1/a^2) + b/a + x/a, 1 + 1/a^2 - b/a}
        expect_evaluated: {-a^(-2) + b/a + x/a, 1 + a^(-2) - b/a}
    ...
ok  PolynomialQuotientRemainder[x^2 + x + 1, Pi*x + 1, x]    ==>     {-(1/Pi^2) + 1/Pi + x/Pi, 1 + 1/Pi^2 - 1/Pi}
    ---
    data:
        got: {-Pi^(-2) + Pi^(-1) + x/Pi, 1 + Pi^(-2) - Pi^(-1)}
        expect: {-(1/Pi^2) + 1/Pi + x/Pi, 1 + 1/Pi^2 - 1/Pi}
        expect_evaluated: {-Pi^(-2) + Pi^(-1) + x/Pi, 1 + Pi^(-2) - Pi^(-1)}
    ...
# RefLink[PolynomialQuotientRemainder,paclet:ref/PolynomialQuotientRemainder] also works for rational functions:
ok  PolynomialQuotientRemainder[(x + 1)/(x + 2), (x + 1)/(x + 3), x]    ==>     {(3 + x)/(2 + x), 0}
    ---
    data:
        got: {(3 + x)/(2 + x), 0}
        expect: {(3 + x)/(2 + x), 0}
        expect_evaluated: {(3 + x)/(2 + x), 0}
    ...
# Use a prime modulus:
ok  PolynomialQuotientRemainder[x^2 + 4*x + 1, 2*x + 1, x, Modulus -> 2]    ==>     {1 + x^2, 0}
    ---
    data:
        got: {1 + x^2, 0}
        expect: {1 + x^2, 0}
        expect_evaluated: {1 + x^2, 0}
    ...
ok  PolynomialQuotientRemainder[x^2 + 4*x + 1, 2*x + 1, x, Modulus -> 3]    ==>     {1 + 2*x, 0}
    ---
    data:
        got: {1 + 2*x, 0}
        expect: {1 + 2*x, 0}
        expect_evaluated: {1 + 2*x, 0}
    ...
ok  {q, r} = PolynomialQuotientRemainder[f, g, x]    ==>     {x, 1} # skip
# The transformed rational function:
ok  f/g == q + r/g    ==>     (1 + 2*x + x^2)/(2 + x) == x + 1/(2 + x) # skip
ok  Simplify[%]    ==>     True # skip
ok  {q, r} = PolynomialQuotientRemainder[f, g, x]    ==>     {2 + x, -3} # skip
# Use RefLink[Expand,paclet:ref/Expand] to verify identity:
not ok  Expand[q*g + r] == f    ==>     True
    ---
    data:
        got: g*q + r == f
        expect: True
        expect_evaluated: True
    ...
# RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient] and RefLink[PolynomialRemainder,paclet:ref/PolynomialRemainder]: 
ok  {PolynomialQuotient[f, g, x], PolynomialRemainder[f, g, x]}    ==>     {2 + x, -3} # skip
# RefLink[PolynomialReduce,paclet:ref/PolynomialReduce] generalizes RefLink[PolynomialQuotientRemainder,paclet:ref/PolynomialQuotientRemainder] for multivariate polynomials:
ok  PolynomialReduce[x^2 + 4*x + 1, {x + 2}, {x}]    ==>     {{2 + x}, -3}
    ---
    data:
        got: {{2 + x}, -3}
        expect: {{2 + x}, -3}
        expect_evaluated: {{2 + x}, -3}
    ...
ok  PolynomialQuotientRemainder[x^2 + 4*x + 1, x + 2, x]    ==>     {2 + x, -3}
    ---
    data:
        got: {2 + x, -3}
        expect: {2 + x, -3}
        expect_evaluated: {2 + x, -3}
    ...
