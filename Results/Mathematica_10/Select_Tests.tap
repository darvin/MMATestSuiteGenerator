#! DOCKER > wolfram -script output/Tests/Select_Tests.m
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: Select_Tests
# Select elements that are even:
ok  Select[{1, 2, 4, 7, 6, 2}, EvenQ]    ==>     {2, 4, 6, 2}
    ---
    data:
        got: {2, 4, 6, 2}
        expect: {2, 4, 6, 2}
        expect_evaluated: {2, 4, 6, 2}
    ...
# Use a pure function to test each element:
ok  Select[{1, 2, 4, 7, 6, 2}, #1 > 2 & ]    ==>     {4, 7, 6}
    ---
    data:
        got: {4, 7, 6}
        expect: {4, 7, 6}
        expect_evaluated: {4, 7, 6}
    ...
# Return only the first expression selected:
ok  Select[{1, 2, 4, 7, 6, 2}, #1 > 2 & , 1]    ==>     {4}
    ---
    data:
        got: {4}
        expect: {4}
        expect_evaluated: {4}
    ...
# Use the operator form of RefLink[Select,paclet:ref/Select]:
ok  Select[EvenQ][{1, 2, 4, 7, 6, 2}]    ==>     {2, 4, 6, 2}
    ---
    data:
        got: {2, 4, 6, 2}
        expect: {2, 4, 6, 2}
        expect_evaluated: {2, 4, 6, 2}
    ...
# RefLink[Select,paclet:ref/Select] operates on values in an RefLink[Association,paclet:ref/Association]:
not ok  HoldComplete[Select[<| a -> 1, b -> 2, c -> 3, d -> 4 |>, #1 > 2 & ]]    ==>     $Failed
    ---
    data:
        got: <|c -> 3, d -> 4|>
        expect: $Failed
        expect_evaluated: $Failed
    ...
# RefLink[Select,paclet:ref/Select] picks out elements for which applying the criterion explicitly yields RefLink[True,paclet:ref/True]:
ok  Select[{1, 2, 4, 7, x}, #1 > 2 & ]    ==>     {4, 7}
    ---
    data:
        got: {4, 7}
        expect: {4, 7}
        expect_evaluated: {4, 7}
    ...
# Applying the criterion to the symbolic object x does not explicitly yield RefLink[True,paclet:ref/True]:
ok  x > 2    ==>     x > 2
    ---
    data:
        got: x > 2
        expect: x > 2
        expect_evaluated: x > 2
    ...
# Find pairs containing x:
ok  Select[{{1, y}, {2, x}, {3, x}, {4, z}, {5, x}}, MemberQ[#1, x] & ]    ==>     {{2, x}, {3, x}, {5, x}}
    ---
    data:
        got: {{2, x}, {3, x}, {5, x}}
        expect: {{2, x}, {3, x}, {5, x}}
        expect_evaluated: {{2, x}, {3, x}, {5, x}}
    ...
# Find up to 2 pairs containing x:
ok  Select[{{1, y}, {2, x}, {3, x}, {4, z}, {5, x}}, MemberQ[#1, x] & , 2]    ==>     {{2, x}, {3, x}}
    ---
    data:
        got: {{2, x}, {3, x}}
        expect: {{2, x}, {3, x}}
        expect_evaluated: {{2, x}, {3, x}}
    ...
# Fewer than the requested elements may be returned:
ok  Select[{{1, y}, {2, x}, {3, x}, {4, z}, {5, x}}, MemberQ[#1, z] & , 2]    ==>     {{4, z}}
    ---
    data:
        got: {{4, z}}
        expect: {{4, z}}
        expect_evaluated: {{4, z}}
    ...
# RefLink[Select,paclet:ref/Select] works with any head, not just RefLink[List,paclet:ref/List]:
ok  Select[f[1, a, 2, b, 3], IntegerQ]    ==>     f[1, 2, 3]
    ---
    data:
        got: f[1, 2, 3]
        expect: f[1, 2, 3]
        expect_evaluated: f[1, 2, 3]
    ...
# RefLink[Select,paclet:ref/Select] works with RefLink[SparseArray,paclet:ref/SparseArray] objects:
ok  HoldComplete[s = SparseArray[Table[2^i -> i, {i, 0, 5}]]]    ==>     $Failed # skip
ok  HoldComplete[Select[s, EvenQ]]    ==>     $Failed # skip
# The result may be a list if it is not sparse:
ok  Select[s, OddQ]    ==>     {1, 3, 5}
    ---
    data:
        got: {1, 3, 5}
        expect: {1, 3, 5}
        expect_evaluated: {1, 3, 5}
    ...
# Select numbers up to 100 that equal 1 modulo both 3 and 5:
ok  Select[Range[100], Mod[#1, 3] == 1 && Mod[#1, 5] == 1 & ]    ==>     {1, 16, 31, 46, 61, 76, 91}
    ---
    data:
        got: {1, 16, 31, 46, 61, 76, 91}
        expect: {1, 16, 31, 46, 61, 76, 91}
        expect_evaluated: {1, 16, 31, 46, 61, 76, 91}
    ...
# Select 4-tuples that read the same in reverse:
ok  Select[Tuples[{a, b}, 4], #1 == Reverse[#1] & ]    ==>     {{a, a, a, a}, {a, b, b, a}, {b, a, a, b}, {b, b, b, b}}
    ---
    data:
        got: {{a, a, a, a}, {a, b, b, a}, {b, a, a, b}, {b, b, b, b}}
        expect: {{a, a, a, a}, {a, b, b, a}, {b, a, a, b}, {b, b, b, b}}
        expect_evaluated: {{a, a, a, a}, {a, b, b, a}, {b, a, a, b}, {b, b, b, b}}
    ...
# Find the first four 3*3 matrices of 0s and 1s that have determinant 1:
ok  Select[Tuples[{0, 1}, {3, 3}], Det[#1] == 1 & , 4]    ==>     {{{0, 0, 1}, {1, 0, 0}, {0, 1, 0}}, {{0, 0, 1}, {1, 0, 0}, {0, 1, 1}}, {{0, 0, 1}, {1, 0, 0}, {1, 1, 0}}, {{0, 0, 1}, {1, 0, 0}, {1, 1, 1}}}
    ---
    data:
        got: {{{0, 0, 1}, {1, 0, 0}, {0, 1, 0}}, {{0, 0, 1}, {1, 0, 0}, {0, 1, 1}}, {{0, 0, 1}, {1, 0, 0}, {1, 1, 0}}, {{0, 0, 1}, {1, 0, 0}, {1, 1, 1}}}
        expect: {{{0, 0, 1}, {1, 0, 0}, {0, 1, 0}}, {{0, 0, 1}, {1, 0, 0}, {0, 1, 1}}, {{0, 0, 1}, {1, 0, 0}, {1, 1, 0}}, {{0, 0, 1}, {1, 0, 0}, {1, 1, 1}}}
        expect_evaluated: {{{0, 0, 1}, {1, 0, 0}, {0, 1, 0}}, {{0, 0, 1}, {1, 0, 0}, {0, 1, 1}}, {{0, 0, 1}, {1, 0, 0}, {1, 1, 0}}, {{0, 0, 1}, {1, 0, 0}, {1, 1, 1}}}
    ...
# Select eigenvalues that lie within the unit circle:
ok  Select[Eigenvalues[RandomReal[1, {5, 5}]], Abs[#1] < 1 & ]    ==>     {0.632848 + 0.0944893*I, 0.632848 - 0.0944893*I, -0.442441 + 0.0657295*I, -0.442441 - 0.0657295*I} # skip
# Find built-in Wolfram Language objects whose names are less than 3 characters long:
ok  Select[Names["*"], StringLength[#1] < 3 & ]    ==>     {C, D, Do, Dt, E, I, If, Im, In, K, N, O, On, Or, Pi, Re, Tr, Up, $, \[SpanFromAbove], \[SpanFromBoth], \[SpanFromLeft]} # skip
# Select numeric quantities from a product:
ok  Select[7*Pi^2*x^2*y^2, NumericQ]    ==>     7*Pi^2
    ---
    data:
        got:     2
#! 7 Pi
        expect: 7*Pi^2
        expect_evaluated:     2
#! 7 Pi
    ...
# Find an approximation to \[Pi] by finding the proportion of points that lie within a disk:
ok  app[n_] := 4*N[Length[Select[RandomReal[{-1, 1}, {n, 2}], #1 . #1 <= 1 & ]]/n]; TableForm[Table[n = 10^k; p = app[n]; {n, p, Pi - p}, {k, 1, 6}], TableHeadings -> {{}, {"n", "approximation", "error"}}]    ==>     *n*approximation*error**10*2.4*0.741593**100*2.92*0.221593**1000*3.216 - 0.0744073**10000*3.1544 - 0.0128073**100000*3.14812 - 0.00652735**1000000*3.14213 - 0.000535346 # skip
# RefLink[Select,paclet:ref/Select] is similar to RefLink[Cases,paclet:ref/Cases] except that it uses a function instead of a pattern:
ok  list = RandomInteger[9, {10, 2}]    ==>     {{0, 7}, {5, 9}, {8, 7}, {2, 8}, {6, 8}, {4, 1}, {1, 8}, {3, 9}, {9, 7}, {8, 5}} # skip
# Select the lists that have sum of elements less than 10:
ok  f = (Total[#1] < 10 & ) ;; Select[list, f]    ==>     {{0, 7}, {4, 1}, {1, 8}} # skip
# Use RefLink[Cases,paclet:ref/Cases] to get the same result:
ok  Cases[list, x_ /; f[x]]    ==>     {{0, 7}, {4, 1}, {1, 8}} # skip
