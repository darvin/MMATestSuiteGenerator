#! DOCKER > wolfram -script output/Tests/ReplacePart_Tests.m
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: ReplacePart_Tests
# Replace part 3:
ok  ReplacePart[{a, b, c, d, e}, 3 -> xxx]    ==>     {a, b, xxx, d, e}
    ---
    data:
        got: {a, b, xxx, d, e}
        expect: {a, b, xxx, d, e}
        expect_evaluated: {a, b, xxx, d, e}
    ...
# Replace parts 2 and 5:
ok  ReplacePart[{a, b, c, d, e}, {2 -> xx, 5 -> yy}]    ==>     {a, xx, c, d, yy}
    ---
    data:
        got: {a, xx, c, d, yy}
        expect: {a, xx, c, d, yy}
        expect_evaluated: {a, xx, c, d, yy}
    ...
# Replace part {2,1} of an array:
ok  ReplacePart[{{a, b}, {c, d}}, {2, 1} -> xx]    ==>     {{a, b}, {xx, d}}
    ---
    data:
        got: {{a, b}, {xx, d}}
        expect: {{a, b}, {xx, d}}
        expect_evaluated: {{a, b}, {xx, d}}
    ...
# Replace parts whose positions match a pattern:
ok  ReplacePart[{{a, b}, {c, d}}, {i_, i_} -> xx]    ==>     {{xx, b}, {c, xx}}
    ---
    data:
        got: {{xx, b}, {c, xx}}
        expect: {{xx, b}, {c, xx}}
        expect_evaluated: {{xx, b}, {c, xx}}
    ...
# Replace parts in any expression:
ok  ReplacePart[a + b + c^n, {{3, 2} -> x + y, 2 -> b^100}]    ==>     a + b^100 + c^(x + y)
    ---
    data:
        got:      100    x + y
#! a + b    + c
        expect: a + b^100 + c^(x + y)
        expect_evaluated:      100    x + y
#! a + b    + c
    ...
# Replace a part 3 from the end:
ok  ReplacePart[{a, b, c, d, e, f, g}, -3 -> xxx]    ==>     {a, b, c, d, xxx, f, g}
    ---
    data:
        got: {a, b, c, d, xxx, f, g}
        expect: {a, b, c, d, xxx, f, g}
        expect_evaluated: {a, b, c, d, xxx, f, g}
    ...
# Replace several parts by the same expression:
ok  ReplacePart[{a, b, c, d, e, f, g}, {{1}, {3}, {5}} -> xxx]    ==>     {xxx, b, xxx, d, xxx, f, g}
    ---
    data:
        got: {xxx, b, xxx, d, xxx, f, g}
        expect: {xxx, b, xxx, d, xxx, f, g}
        expect_evaluated: {xxx, b, xxx, d, xxx, f, g}
    ...
# Part specifications can be patterns:
ok  ReplacePart[{a, b, c, d, e, f, g}, 1 | 3 | 5 -> xxx]    ==>     {xxx, b, xxx, d, xxx, f, g}
    ---
    data:
        got: {xxx, b, xxx, d, xxx, f, g}
        expect: {xxx, b, xxx, d, xxx, f, g}
        expect_evaluated: {xxx, b, xxx, d, xxx, f, g}
    ...
# Replace every part except those with indices 1, 3, or 5:
ok  ReplacePart[{a, b, c, d, e, f, g}, Except[1 | 3 | 5] -> xxx]    ==>     {a, xxx, c, xxx, e, xxx, xxx}
    ---
    data:
        got: {a, xxx, c, xxx, e, xxx, xxx}
        expect: {a, xxx, c, xxx, e, xxx, xxx}
        expect_evaluated: {a, xxx, c, xxx, e, xxx, xxx}
    ...
# Replace every part whose index is even:
ok  ReplacePart[{a, b, c, d, e, f, g}, _?EvenQ -> xxx]    ==>     {a, xxx, c, xxx, e, xxx, g}
    ---
    data:
        got: {a, xxx, c, xxx, e, xxx, g}
        expect: {a, xxx, c, xxx, e, xxx, g}
        expect_evaluated: {a, xxx, c, xxx, e, xxx, g}
    ...
# Replace all elements in the first sublist:
ok  ReplacePart[{{a, b, c}, {d, e}, {f}}, {1, _} -> xx]    ==>     {{xx, xx, xx}, {d, e}, {f}}
    ---
    data:
        got: {{xx, xx, xx}, {d, e}, {f}}
        expect: {{xx, xx, xx}, {d, e}, {f}}
        expect_evaluated: {{xx, xx, xx}, {d, e}, {f}}
    ...
# Replace the last element in each sublist:
ok  ReplacePart[{{a, b, c}, {d, e}, {f}}, {_, -1} -> xx]    ==>     {{a, b, xx}, {d, xx}, {xx}}
    ---
    data:
        got: {{a, b, xx}, {d, xx}, {xx}}
        expect: {{a, b, xx}, {d, xx}, {xx}}
        expect_evaluated: {{a, b, xx}, {d, xx}, {xx}}
    ...
# Replace elements on the diagonal:
ok  ReplacePart[{{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}, {i_, i_} -> x]    ==>     {{x, 0, 0}, {0, x, 0}, {0, 0, x}}
    ---
    data:
        got: {{x, 0, 0}, {0, x, 0}, {0, 0, x}}
        expect: {{x, 0, 0}, {0, x, 0}, {0, 0, x}}
        expect_evaluated: {{x, 0, 0}, {0, x, 0}, {0, 0, x}}
    ...
# Part specification patterns can contain variables that are used in the replacements:
ok  ReplacePart[{{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}, {i_, i_} -> f[i]]    ==>     {{f[1], 0, 0}, {0, f[2], 0}, {0, 0, f[3]}}
    ---
    data:
        got: {{f[1], 0, 0}, {0, f[2], 0}, {0, 0, f[3]}}
        expect: {{f[1], 0, 0}, {0, f[2], 0}, {0, 0, f[3]}}
        expect_evaluated: {{f[1], 0, 0}, {0, f[2], 0}, {0, 0, f[3]}}
    ...
# Patterns can represent part lists of variable length: 
ok  ReplacePart[{{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}, {___, 2, ___} -> x]    ==>     {{0, x, 0}, x, {0, x, 0}}
    ---
    data:
        got: {{0, x, 0}, x, {0, x, 0}}
        expect: {{0, x, 0}, x, {0, x, 0}}
        expect_evaluated: {{0, x, 0}, x, {0, x, 0}}
    ...
ok  ReplacePart[{{a, b, c}, {d, e}, {f}}, i__ -> s[i]]    ==>     {s[1], s[2], s[3]}
    ---
    data:
        got: {s[1], s[2], s[3]}
        expect: {s[1], s[2], s[3]}
        expect_evaluated: {s[1], s[2], s[3]}
    ...
# The right-hand side of the rule is evaluated separately for each replacement done:
ok  ReplacePart[{{a, b}, {c, d}}, {i_, i_} :> RandomReal[]]    ==>     {{0.519879, b}, {c, 0.319308}} # skip
# RefLink[ReplacePart,paclet:ref/ReplacePart] works with RefLink[SparseArray,paclet:ref/SparseArray] objects:
ok  HoldComplete[ReplacePart[SparseArray[5 -> a, 10], 7 -> b]]    ==>     $Failed # skip
ok  Normal[%]    ==>     {0, 0, 0, 0, a, 0, b, 0, 0, 0} # skip
# RefLink[ReplacePart,paclet:ref/ReplacePart] works on heads:
ok  ReplacePart[f[x, y], 0 -> g]    ==>     g[x, y]
    ---
    data:
        got: g[x, y]
        expect: g[x, y]
        expect_evaluated: g[x, y]
    ...
ok  ReplacePart[f[g][x, y], {0, 1} -> hh]    ==>     f[hh][x, y]
    ---
    data:
        got: f[hh][x, y]
        expect: f[hh][x, y]
        expect_evaluated: f[hh][x, y]
    ...
# Replace all heads by RefLink[List,paclet:ref/List]:
ok  ReplacePart[a*x^2 + y^2 + c*z^2, {___, 0} -> List]    ==>     {{a, {x, 2}}, {y, 2}, {c, {z, 2}}}
    ---
    data:
        got: {{a, {x, 2}}, {y, 2}, {c, {z, 2}}}
        expect: {{a, {x, 2}}, {y, 2}, {c, {z, 2}}}
        expect_evaluated: {{a, {x, 2}}, {y, 2}, {c, {z, 2}}}
    ...
# Replace all ordinary parts, but not heads:
ok  ReplacePart[f[x, y], _ -> g]    ==>     f[g, g]
    ---
    data:
        got: f[g, g]
        expect: f[g, g]
        expect_evaluated: f[g, g]
    ...
# Also replace heads:
ok  ReplacePart[f[x, y], _ -> g, Heads -> True]    ==>     g[g, g]
    ---
    data:
        got: g[g, g]
        expect: g[g, g]
        expect_evaluated: g[g, g]
    ...
# Never replace heads:
ok  ReplacePart[f[x, y], 0 -> g, Heads -> False]    ==>     f[x, y]
    ---
    data:
        got: f[x, y]
        expect: f[x, y]
        expect_evaluated: f[x, y]
    ...
# Border a matrix with x's:
ok  MatrixForm[ReplacePart[IdentityMatrix[5], {_, 1 | 5} -> x]]    ==>     x*0*0*0*x*x*1*0*0*x*x*0*1*0*x*x*0*0*1*x*x*0*0*0*x # skip
# Highlight two squares in an array:
not ok  HoldComplete[ArrayPlot[ReplacePart[Array[GCD, {15, 15}], {{6, 6}, {12, 12}} -> Red]]]    ==>     $Failed
    ---
    data:
        got: -Graphics-
        expect: $Failed
        expect_evaluated: $Failed
    ...
# Generate a difference pattern for two cellular automaton initial conditions differing by one bit:
not ok  HoldComplete[With[{u = RandomInteger[1, 100]}, ArrayPlot[Sum[(-1)^i*CellularAutomaton[30, ReplacePart[u, 50 -> i], 50], {i, 0, 1}]]]]    ==>     $Failed
    ---
    data:
        got: -Graphics-
        expect: $Failed
        expect_evaluated: $Failed
    ...
# Insert a black cell at a random position at each step:
not ok  HoldComplete[ArrayPlot[NestList[ReplacePart[#1, RandomInteger[{1, 30}] -> 1] & , Table[0, {30}], 20], Mesh -> All]]    ==>     $Failed
    ---
    data:
        got: -Graphics-
        expect: $Failed
        expect_evaluated: $Failed
    ...
# Successively replace parts of a list:
ok  FoldList[ReplacePart[#1, #2 -> x] & , {a, b, c, d, e}, {5, 2, 3, 1, 4}]    ==>     {{a, b, c, d, e}, {a, b, c, d, x}, {a, x, c, d, x}, {a, x, x, d, x}, {x, x, x, d, x}, {x, x, x, x, x}}
    ---
    data:
        got: {{a, b, c, d, e}, {a, b, c, d, x}, {a, x, c, d, x}, {a, x, x, d, x}, {x, x, x, d, x}, {x, x, x, x, x}}
        expect: {{a, b, c, d, e}, {a, b, c, d, x}, {a, x, c, d, x}, {a, x, x, d, x}, {x, x, x, d, x}, {x, x, x, x, x}}
        expect_evaluated: {{a, b, c, d, e}, {a, b, c, d, x}, {a, x, c, d, x}, {a, x, x, d, x}, {x, x, x, d, x}, {x, x, x, x, x}}
    ...
# Successively replace disks in a graphic by circles:
not ok  HoldComplete[g = Graphics[{Gray, Table[Disk[RandomReal[5, 2]], {5}]}, ImageSize -> Tiny]]    ==>     $Failed
    ---
    data:
        got: -Graphics-
        expect: $Failed
        expect_evaluated: $Failed
    ...
ok  Position[g, Disk]    ==>     {{1, 2, 1, 0}, {1, 2, 2, 0}, {1, 2, 3, 0}, {1, 2, 4, 0}, {1, 2, 5, 0}}
    ---
    data:
        got: {{1, 2, 1, 0}, {1, 2, 2, 0}, {1, 2, 3, 0}, {1, 2, 4, 0}, {1, 2, 5, 0}}
        expect: {{1, 2, 1, 0}, {1, 2, 2, 0}, {1, 2, 3, 0}, {1, 2, 4, 0}, {1, 2, 5, 0}}
        expect_evaluated: {{1, 2, 1, 0}, {1, 2, 2, 0}, {1, 2, 3, 0}, {1, 2, 4, 0}, {1, 2, 5, 0}}
    ...
ok  HoldComplete[FoldList[ReplacePart[#1, #2 -> Circle] & , g, %]]    ==>     $Failed # skip
# Successively replace entries in a 2D array:
ok  HoldComplete[(ArrayPlot[#1, Mesh -> True, ImageSize -> 50] & ) /@ NestList[ReplacePart[#1, RandomInteger[{1, 5}, {2}] -> 1] & , ConstantArray[0, {5, 5}], 10]]    ==>     $Failed # skip
# Replace elements whose indices are not relatively prime:
ok  ReplacePart[ConstantArray[0, {5, 5}], {x_, y_} /; CoprimeQ[x, y] -> x + y]    ==>     {{2, 3, 4, 5, 6}, {3, 0, 5, 0, 7}, {4, 5, 0, 7, 8}, {5, 0, 7, 0, 9}, {6, 7, 8, 9, 0}}
    ---
    data:
        got: {{2, 3, 4, 5, 6}, {3, 0, 5, 0, 7}, {4, 5, 0, 7, 8}, {5, 0, 7, 0, 9}, {6, 7, 8, 9, 0}}
        expect: {{2, 3, 4, 5, 6}, {3, 0, 5, 0, 7}, {4, 5, 0, 7, 8}, {5, 0, 7, 0, 9}, {6, 7, 8, 9, 0}}
        expect_evaluated: {{2, 3, 4, 5, 6}, {3, 0, 5, 0, 7}, {4, 5, 0, 7, 8}, {5, 0, 7, 0, 9}, {6, 7, 8, 9, 0}}
    ...
# RefLink[ReplacePart,paclet:ref/ReplacePart] uses rules in the order given:
ok  ReplacePart[{a, b, c, d, e}, {3 -> u, _ -> x}]    ==>     {x, x, u, x, x}
    ---
    data:
        got: {x, x, u, x, x}
        expect: {x, x, u, x, x}
        expect_evaluated: {x, x, u, x, x}
    ...
# RefLink[ReplacePart,paclet:ref/ReplacePart] takes lists of positions in the same form as generated by RefLink[Position,paclet:ref/Position]:
ok  Position[{a, b, x, c, d, x, e}, x]    ==>     {{3}, {6}}
    ---
    data:
        got: {{3}, {6}}
        expect: {{3}, {6}}
        expect_evaluated: {{3}, {6}}
    ...
ok  ReplacePart[{a, b, x, c, d, x, e}, {{3}, {6}} -> yy]    ==>     {a, b, yy, c, d, yy, e}
    ---
    data:
        got: {a, b, yy, c, d, yy, e}
        expect: {a, b, yy, c, d, yy, e}
        expect_evaluated: {a, b, yy, c, d, yy, e}
    ...
# RefLink[ReplacePart,paclet:ref/ReplacePart] takes the same part rules as RefLink[SparseArray,paclet:ref/SparseArray]:
ok  Normal[SparseArray[{1 -> x, 5 -> y}, 10]]    ==>     {x, 0, 0, 0, y, 0, 0, 0, 0, 0}
    ---
    data:
        got: {x, 0, 0, 0, y, 0, 0, 0, 0, 0}
        expect: {x, 0, 0, 0, y, 0, 0, 0, 0, 0}
        expect_evaluated: {x, 0, 0, 0, y, 0, 0, 0, 0, 0}
    ...
ok  ReplacePart[Array[0 & , 10], {1 -> x, 5 -> y}]    ==>     {x, 0, 0, 0, y, 0, 0, 0, 0, 0}
    ---
    data:
        got: {x, 0, 0, 0, y, 0, 0, 0, 0, 0}
        expect: {x, 0, 0, 0, y, 0, 0, 0, 0, 0}
        expect_evaluated: {x, 0, 0, 0, y, 0, 0, 0, 0, 0}
    ...
# RefLink[ReplacePart,paclet:ref/ReplacePart] only affects parts that are already present:
ok  ReplacePart[{a, b, c, d}, 5 -> x]    ==>     {a, b, c, d}
    ---
    data:
        got: {a, b, c, d}
        expect: {a, b, c, d}
        expect_evaluated: {a, b, c, d}
    ...
# Particularly in an RefLink[Orderless,paclet:ref/Orderless] function, the order of parts may change when they are replaced:
ok  ReplacePart[ReplacePart[a + b + c, 1 -> x], 3 -> y]    ==>     b + c + y
    ---
    data:
        got: b + c + y
        expect: b + c + y
        expect_evaluated: b + c + y
    ...
