#! DOCKER > wolfram -script output/Tests/List_Tests.m
# SYSTEM: Mathematica_10
# TEST: List_Tests
ok  {a, b, c, d}    ==>     {a, b, c, d}
    ---
    data:
        got: {a, b, c, d}
        expect: {a, b, c, d}
        expect_evaluated: {a, b, c, d}
    ...
ok  FullForm[{a, b, c, d}]    ==>     {a, b, c, d} # skip
ok  VectorQ[v]    ==>     True # skip
# Many operations work on vectors, like RefLink[Dot,paclet:ref/Dot] and RefLink[Norm,paclet:ref/Norm]:
ok  v . v    ==>     6.29 + (4 + x)^2 # skip
ok  MatrixQ[m]    ==>     True # skip
# Many operations work with matrices, like RefLink[Dot,paclet:ref/Dot], RefLink[Transpose,paclet:ref/Transpose], and RefLink[Det,paclet:ref/Det]:
ok  m . Transpose[m]    ==>     {{14, 36}, {36, 98}} # skip
ok  Det[Transpose[m] . m]    ==>     0 # skip
ok  ArrayQ[ra]    ==>     True # skip
# Many operations work on arrays of any depth, like RefLink[Dot,paclet:ref/Dot] and RefLink[Fourier,paclet:ref/Fourier]:
ok  ra . {1, 2, 3}    ==>     {{14, 32}, {50, 68}, {86, 104}, {122, 140}} # skip
# The three-dimensional discrete Fourier transform:
ok  Fourier[ra]    ==>     {{{61.2372 + 0.*I, -2.44949 - 1.41421*I, -2.44949 + 1.41421*I}, {-7.34847 + 0.*I, 0. + 0.*I, 0. + 0.*I}}, {{-14.6969 - 14.6969*I, 0. + 0.*I, 0. + 0.*I}, {0. + 0.*I, 0. + 0.*I, 0. + 0.*I}}, {{-14.6969 + 0.*I, 0. + 0.*I, 0. + 0.*I}, {0. + 0.*I, 0. + 0.*I, 0. + 0.*I}}, {{-14.6969 + 14.6969*I, 0. + 0.*I, 0. + 0.*I}, {0. + 0.*I, 0. + 0.*I, 0. + 0.*I}}} # skip
# Many structural functions will work with ragged arrays:
ok  ragged[[All,1]]    ==>     {1, 4, 6} # skip
ok  Total /@ ragged    ==>     {6, 9, 6} # skip
# If the elements are at the same depth, you can use RefLink[PadRight,paclet:ref/PadRight] to make a rectangular array:
ok  PadRight[ragged]    ==>     {{1, 2, 3}, {4, 5, 0}, {6, 0, 0}} # skip
# RefLink[Range,paclet:ref/Range] constructs a list consisting of a range of values:
ok  Range[4]    ==>     {1, 2, 3, 4}
    ---
    data:
        got: {1, 2, 3, 4}
        expect: {1, 2, 3, 4}
        expect_evaluated: {1, 2, 3, 4}
    ...
ok  Range[4, -4, -2]    ==>     {4, 2, 0, -2, -4}
    ---
    data:
        got: {4, 2, 0, -2, -4}
        expect: {4, 2, 0, -2, -4}
        expect_evaluated: {4, 2, 0, -2, -4}
    ...
ok  Range[0., 1., 0.1]    ==>     {0., 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.}
    ---
    data:
        got: {0., 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9, 1.}
        expect: {0., 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.}
        expect_evaluated: {0., 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.}
    ...
# RefLink[Array,paclet:ref/Array] constructs lists using a function:
ok  Array[f, 4]    ==>     {f[1], f[2], f[3], f[4]}
    ---
    data:
        got: {f[1], f[2], f[3], f[4]}
        expect: {f[1], f[2], f[3], f[4]}
        expect_evaluated: {f[1], f[2], f[3], f[4]}
    ...
ok  Array[2^#1 & , 4]    ==>     {2, 4, 8, 16}
    ---
    data:
        got: {2, 4, 8, 16}
        expect: {2, 4, 8, 16}
        expect_evaluated: {2, 4, 8, 16}
    ...
# When given multiple dimensions, matrices or deeper arrays are constructed:
ok  h[i_, j_] := 1/(i + j - 1); Array[h, {4, 3}]    ==>     {{1, 1/2, 1/3}, {1/2, 1/3, 1/4}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6}}
    ---
    data:
        got: {{1, 1/2, 1/3}, {1/2, 1/3, 1/4}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6}}
        expect: {{1, 1/2, 1/3}, {1/2, 1/3, 1/4}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6}}
        expect_evaluated: {{1, 1/2, 1/3}, {1/2, 1/3, 1/4}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6}}
    ...
# RefLink[Table,paclet:ref/Table] constructs lists using an expression and an iterator:
ok  Table[f[i], {i, 4}]    ==>     {f[1], f[2], f[3], f[4]}
    ---
    data:
        got: {f[1], f[2], f[3], f[4]}
        expect: {f[1], f[2], f[3], f[4]}
        expect_evaluated: {f[1], f[2], f[3], f[4]}
    ...
ok  Table[2^i, {i, -4, 4}]    ==>     {1/16, 1/8, 1/4, 1/2, 1, 2, 4, 8, 16}
    ---
    data:
        got: {1/16, 1/8, 1/4, 1/2, 1, 2, 4, 8, 16}
        expect: {1/16, 1/8, 1/4, 1/2, 1, 2, 4, 8, 16}
        expect_evaluated: {1/16, 1/8, 1/4, 1/2, 1, 2, 4, 8, 16}
    ...
ok  Table[h[i, j], {i, 4}, {j, 3}]    ==>     {{1, 1/2, 1/3}, {1/2, 1/3, 1/4}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6}}
    ---
    data:
        got: {{1, 1/2, 1/3}, {1/2, 1/3, 1/4}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6}}
        expect: {{1, 1/2, 1/3}, {1/2, 1/3, 1/4}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6}}
        expect_evaluated: {{1, 1/2, 1/3}, {1/2, 1/3, 1/4}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6}}
    ...
ok  Table[h[i, j], {i, 4}, {j, i}]    ==>     {{1}, {1/2, 1/3}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6, 1/7}}
    ---
    data:
        got: {{1}, {1/2, 1/3}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6, 1/7}}
        expect: {{1}, {1/2, 1/3}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6, 1/7}}
        expect_evaluated: {{1}, {1/2, 1/3}, {1/3, 1/4, 1/5}, {1/4, 1/5, 1/6, 1/7}}
    ...
# Functional commands like RefLink[NestList,paclet:ref/NestList] create lists of the results:
ok  NestList[(3*#1)*(1 - #1) & , 0.1, 20]    ==>     {0.1, 0.27, 0.5913, 0.724993, 0.598135, 0.721109, 0.603333, 0.717967, 0.607471, 0.71535, 0.610873, 0.713121, 0.613738, 0.711191, 0.616195, 0.709496, 0.618334, 0.707991, 0.620219, 0.706642, 0.621897} # skip
ok  HoldComplete[ListPlot[%, Filling -> Axis]]    ==>     $Failed # skip
# Some trials of rolling a die until the same number comes up twice in a row:
ok  rolls    ==>     {5, 3, 2} # skip
ok  rolls    ==>     {5, 1} # skip
ok  rolls    ==>     {5, 1, 2, 4, 5, 1, 2} # skip
# Add two vectors:
ok  {1, 2, 3} + {a, b, c}    ==>     {1 + a, 2 + b, 3 + c}
    ---
    data:
        got: {1 + a, 2 + b, 3 + c}
        expect: {1 + a, 2 + b, 3 + c}
        expect_evaluated: {1 + a, 2 + b, 3 + c}
    ...
# Scalar multiple:
ok  2*{1, 2, 3}    ==>     {2, 4, 6}
    ---
    data:
        got: {2, 4, 6}
        expect: {2, 4, 6}
        expect_evaluated: {2, 4, 6}
    ...
# Sine of a vector:
ok  Sin[2*Pi*Range[0., 1., 1/13]]    ==>     {0., 0.464723, 0.822984, 0.992709, 0.935016, 0.663123, 0.239316, -0.239316, -0.663123, -0.935016, -0.992709, -0.822984, -0.464723, -2.44929/10^16} # skip
# Scalar multiple of a matrix:
ok  a*{{1, 2}, {3, 4}}    ==>     {{a, 2*a}, {3*a, 4*a}}
    ---
    data:
        got: {{a, 2*a}, {3*a, 4*a}}
        expect: {{a, 2*a}, {3*a, 4*a}}
        expect_evaluated: {{a, 2*a}, {3*a, 4*a}}
    ...
# Matrix plus a vector adds the component of the vector to the rows of the matrix:
ok  {{1, 2}, {3, 4}} + {a, b}    ==>     {{1 + a, 2 + a}, {3 + b, 4 + b}}
    ---
    data:
        got: {{1 + a, 2 + a}, {3 + b, 4 + b}}
        expect: {{1 + a, 2 + a}, {3 + b, 4 + b}}
        expect_evaluated: {{1 + a, 2 + a}, {3 + b, 4 + b}}
    ...
# Function applied element-wise to a matrix:
ok  Exp[{{1., 2., 3.}, {4., 5., 6.}}]    ==>     {{2.71828, 7.38906, 20.0855}, {54.5982, 148.413, 403.429}} # skip
ok  f[{1, 2, 3, 4}]    ==>     {f[1], f[2], f[3], f[4]} # skip
# RefLink[Apply,paclet:ref/Apply] makes the elements of a list the arguments of a function: 
ok  f @@ {1, 2, 3}    ==>     f[1, 2, 3]
    ---
    data:
        got: f[1, 2, 3]
        expect: f[1, 2, 3]
        expect_evaluated: f[1, 2, 3]
    ...
# If you have a nested list, applying at level 1 gives a list f applied to the sublists:
ok  Apply[f, {{1, 2}, {3, 4}, {5, 6}}, {1}]    ==>     {f[1, 2], f[3, 4], f[5, 6]}
    ---
    data:
        got: {f[1, 2], f[3, 4], f[5, 6]}
        expect: {f[1, 2], f[3, 4], f[5, 6]}
        expect_evaluated: {f[1, 2], f[3, 4], f[5, 6]}
    ...
# RefLink[Map,paclet:ref/Map] applies a function to the elements of a list:
ok  f /@ {1, 2, 3, 4}    ==>     {f[1], f[2], f[3], f[4]}
    ---
    data:
        got: {f[1], f[2], f[3], f[4]}
        expect: {f[1], f[2], f[3], f[4]}
        expect_evaluated: {f[1], f[2], f[3], f[4]}
    ...
# For a nested list, RefLink[Map,paclet:ref/Map] can apply f at any level or multiple levels:
ok  Map[f, {{1, 2}, {3, 4}, {5, 6}}, {2}]    ==>     {{f[1], f[2]}, {f[3], f[4]}, {f[5], f[6]}}
    ---
    data:
        got: {{f[1], f[2]}, {f[3], f[4]}, {f[5], f[6]}}
        expect: {{f[1], f[2]}, {f[3], f[4]}, {f[5], f[6]}}
        expect_evaluated: {{f[1], f[2]}, {f[3], f[4]}, {f[5], f[6]}}
    ...
ok  Map[f, {{1, 2}, {3, 4}, {5, 6}}, 2]    ==>     {f[{f[1], f[2]}], f[{f[3], f[4]}], f[{f[5], f[6]}]}
    ---
    data:
        got: {f[{f[1], f[2]}], f[{f[3], f[4]}], f[{f[5], f[6]}]}
        expect: {f[{f[1], f[2]}], f[{f[3], f[4]}], f[{f[5], f[6]}]}
        expect_evaluated: {f[{f[1], f[2]}], f[{f[3], f[4]}], f[{f[5], f[6]}]}
    ...
ok  Table[Log[2, i], {i, list}]    ==>     {0, 1, 2, 3} # skip
ok  Sum[k, {k, list}]    ==>     15 # skip
ok  list[[3]]    ==>     4 # skip
# You can get multiple parts by specifying a list of parts:
ok  list[[{1, -1}]]    ==>     {1, 8} # skip
# Or by using RefLink[Span,paclet:ref/Span]:
ok  list[[1 ;; -1 ;; 2]]    ==>     {1, 4} # skip
# Use RefLink[Outer,paclet:ref/Outer] to apply a function to elements of multiple lists: 
ok  Outer[f, {1, 2}, {a, b, c}]    ==>     {{f[1, a], f[1, b], f[1, c]}, {f[2, a], f[2, b], f[2, c]}}
    ---
    data:
        got: {{f[1, a], f[1, b], f[1, c]}, {f[2, a], f[2, b], f[2, c]}}
        expect: {{f[1, a], f[1, b], f[1, c]}, {f[2, a], f[2, b], f[2, c]}}
        expect_evaluated: {{f[1, a], f[1, b], f[1, c]}, {f[2, a], f[2, b], f[2, c]}}
    ...
ok  Complement[s1, s2]    ==>     {a, b} # skip
ok  Union[s1, s2]    ==>     {a, b, c, d, e} # skip
ok  Intersection[s1, s2]    ==>     {c} # skip
# Construct various combinatorial structures using RefLink[Subsets,paclet:ref/Subsets], RefLink[Tuples,paclet:ref/Tuples], and RefLink[IntegerPartitions,paclet:ref/IntegerPartitions]:
ok  Subsets[{1, 2, 3}]    ==>     {{}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}}
    ---
    data:
        got: {{}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}}
        expect: {{}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}}
        expect_evaluated: {{}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}}
    ...
ok  Tuples[{{0, 1}, {a, b}}]    ==>     {{0, a}, {0, b}, {1, a}, {1, b}}
    ---
    data:
        got: {{0, a}, {0, b}, {1, a}, {1, b}}
        expect: {{0, a}, {0, b}, {1, a}, {1, b}}
        expect_evaluated: {{0, a}, {0, b}, {1, a}, {1, b}}
    ...
ok  IntegerPartitions[5]    ==>     {{5}, {4, 1}, {3, 2}, {3, 1, 1}, {2, 2, 1}, {2, 1, 1, 1}, {1, 1, 1, 1, 1}}
    ---
    data:
        got: {{5}, {4, 1}, {3, 2}, {3, 1, 1}, {2, 2, 1}, {2, 1, 1, 1}, {1, 1, 1, 1, 1}}
        expect: {{5}, {4, 1}, {3, 2}, {3, 1, 1}, {2, 2, 1}, {2, 1, 1, 1}, {1, 1, 1, 1, 1}}
        expect_evaluated: {{5}, {4, 1}, {3, 2}, {3, 1, 1}, {2, 2, 1}, {2, 1, 1, 1}, {1, 1, 1, 1, 1}}
    ...
# Many commands use {var, vmin, vmax} as a specification of variable range:
ok  Integrate[Sin[x], {x, 0, Pi/2}]    ==>     1
    ---
    data:
        got: 1
        expect: 1
        expect_evaluated: 1
    ...
ok  HoldComplete[NDSolve[{Derivative[1][x][t] == x[t], x[0] == 1}, x, {t, 0, 1}]]    ==>     $Failed # skip
ok  Table[var^2, {var, -1, 3}]    ==>     {1, 0, 1, 4, 9}
    ---
    data:
        got: {1, 0, 1, 4, 9}
        expect: {1, 0, 1, 4, 9}
        expect_evaluated: {1, 0, 1, 4, 9}
    ...
# Many commands use {Subscript[v, 1],Subscript[v, 2],\[Ellipsis]} for a collection of variables:
ok  Solve[{x + y + z == 0, x + y == 1, y + z == 2}, {x, y, z}]    ==>     {{x -> -2, y -> 3, z -> -1}}
    ---
    data:
        got: {{x -> -2, y -> 3, z -> -1}}
        expect: {{x -> -2, y -> 3, z -> -1}}
        expect_evaluated: {{x -> -2, y -> 3, z -> -1}}
    ...
ok  DSolve[{Derivative[1][x][t] == y[t], Derivative[1][y][t] == -x[t]}, {x, y}, t]    ==>     {{x -> Function[{t}, C[1]*Cos[t] + C[2]*Sin[t]], y -> Function[{t}, C[2]*Cos[t] - C[1]*Sin[t]]}} # skip
# A list of rules is returned as a solution by many solving commands:
ok  r = FindRoot[{Cos[x^2 + y], x - 2*y}, {{x, 1}, {y, 2}}]    ==>     {x -> -1.528, y -> -0.764002} # skip
# You can use the values of the results with RefLink[ReplaceAll,paclet:ref/ReplaceAll]:
ok  {x, y} /. r    ==>     {-1.528, -0.764002} # skip
ok  {Cos[x^2 + y], x - 2*y} /. r    ==>     {-5.26784/10^15, 0.} # skip
# When multiple solutions are possible, the result is a list of rule lists:
ok  s2 = Solve[{x^2 + y^2 == 1, x + y == 0}, {x, y}]    ==>     {{x -> -(1/Sqrt[2]), y -> 1/Sqrt[2]}, {x -> 1/Sqrt[2], y -> -(1/Sqrt[2])}}
    ---
    data:
        got: {{x -> -(1/Sqrt[2]), y -> 1/Sqrt[2]}, {x -> 1/Sqrt[2], y -> -(1/Sqrt[2])}}
        expect: {{x -> -(1/Sqrt[2]), y -> 1/Sqrt[2]}, {x -> 1/Sqrt[2], y -> -(1/Sqrt[2])}}
        expect_evaluated: {{x -> -(1/Sqrt[2]), y -> 1/Sqrt[2]}, {x -> 1/Sqrt[2], y -> -(1/Sqrt[2])}}
    ...
# When a list of rule lists is used in RefLink[ReplaceAll,paclet:ref/ReplaceAll], you get a list of results:
ok  {x, y} /. s2    ==>     {{-(1/Sqrt[2]), 1/Sqrt[2]}, {1/Sqrt[2], -(1/Sqrt[2])}}
    ---
    data:
        got: {{-(1/Sqrt[2]), 1/Sqrt[2]}, {1/Sqrt[2], -(1/Sqrt[2])}}
        expect: {{-(1/Sqrt[2]), 1/Sqrt[2]}, {1/Sqrt[2], -(1/Sqrt[2])}}
        expect_evaluated: {{-(1/Sqrt[2]), 1/Sqrt[2]}, {1/Sqrt[2], -(1/Sqrt[2])}}
    ...
ok  x^2 + y^2 == 1 && x + y == 0 /. s2    ==>     {True, True}
    ---
    data:
        got: {True, True}
        expect: {True, True}
        expect_evaluated: {True, True}
    ...
# Even if there is only one solution, the extra RefLink[List,paclet:ref/List] is used for consistent structure:
ok  Solve[{x - y == 1, x + y == 0}, {x, y}]    ==>     {{x -> 1/2, y -> -(1/2)}}
    ---
    data:
        got: {{x -> 1/2, y -> -1/2}}
        expect: {{x -> 1/2, y -> -(1/2)}}
        expect_evaluated: {{x -> 1/2, y -> -1/2}}
    ...
# Sine of successive squares:
ok  ssq = N[Sin[Range[10]^2]]    ==>     {0.841471, -0.756802, 0.412118, -0.287903, -0.132352, -0.991779, -0.953753, 0.920026, -0.629888, -0.506366} # skip
# Plot the data:
ok  HoldComplete[ListPlot[ssq]]    ==>     $Failed # skip
# Data from a function sampled at points in two dimensions:
ok  HoldComplete[f[x_, y_] := Sin[2*Pi*x*y]; Short[data = Flatten[Table[{{x, y}, f[x, y]}, {x, 0., 1., 0.1}, {y, 0., 1., 0.1}], 1]]]    ==>     $Failed # skip
# A piecewise polynomial that interpolates the data:
ok  HoldComplete[ifun = Interpolation[data]]    ==>     $Failed # skip
# Plot the RefLink[InterpolatingFunction,paclet:ref/InterpolatingFunction]:
ok  HoldComplete[Plot3D[ifun[x, y], {x, 0, 1}, {y, 0, 1}]]    ==>     $Failed # skip
# Plot the data directly:
ok  HoldComplete[ListPlot3D[Flatten /@ data]]    ==>     $Failed # skip
ok  HoldComplete[slist = SparseArray[list]]    ==>     $Failed # skip
# They are RefLink[Equal,paclet:ref/Equal]:
ok  slist == list    ==>     True # skip
# They can be equivalently used in many commands:
ok  slist + 3 == list + 3    ==>     True # skip
ok  Sin[N[slist]] == Sin[N[list]]    ==>     True # skip
# They are not identical because the representation is different:
ok  slist === list    ==>     False
    ---
    data:
        got: False
        expect: False
        expect_evaluated: False
    ...
# RefLink[Normal,paclet:ref/Normal][slist] gives the RefLink[List,paclet:ref/List] representation:
ok  Normal[slist]    ==>     {1, 0, 1, 0, 0, 1, 0, 0, 0, 1} # skip
ok  % === list    ==>     True # skip
