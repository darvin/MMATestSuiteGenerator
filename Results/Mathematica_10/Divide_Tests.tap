# SYSTEM: Mathematica_10
# TEST: Divide_Tests
# OUTPUT: output/Results/Mathematica_10/Divide_Tests.json
ok  77/11    ==>     7
    ---
    data:
        got: 7
        expect: 7
        expect_evaluated: 7
    ...
# Enter in 2D form using Control+/:
ok  77/11    ==>     7
    ---
    data:
        got: 7
        expect: 7
        expect_evaluated: 7
    ...
# RefLink[Divide,paclet:ref/Divide] reduces fractions to lowest terms:
ok  616/33    ==>     56/3
    ---
    data:
        got: 56/3
        expect: 56/3
        expect_evaluated: 56/3
    ...
# Force a numerical result by including a decimal point in the input:
ok  616./33    ==>     18.6667 # skip
# / is applied sequentially:
ok  a/(b*c*d)    ==>     a/(b*c*d)
    ---
    data:
        got: a/(b*c*d)
        expect: a/(b*c*d)
        expect_evaluated: a/(b*c*d)
    ...
# x/y is always converted to products and powers:
ok  FullForm[a^2/b^3]    ==>     a^2/b^3 # skip
# Enter / using Esc\[ThinSpace]div\[ThinSpace]Esc:
ok  20/4    ==>     5
    ---
    data:
        got: 5
        expect: 5
        expect_evaluated: 5
    ...
# RefLink[Divide,paclet:ref/Divide] threads element-wise over lists:
ok  {2, 3, 4, 5}/3    ==>     {2/3, 1, 4/3, 5/3}
    ---
    data:
        got: {2/3, 1, 4/3, 5/3}
        expect: {2/3, 1, 4/3, 5/3}
        expect_evaluated: {2/3, 1, 4/3, 5/3}
    ...
ok  {x, y, z}/{a, b, c}    ==>     {x/a, y/b, z/c}
    ---
    data:
        got: {x/a, y/b, z/c}
        expect: {x/a, y/b, z/c}
        expect_evaluated: {x/a, y/b, z/c}
    ...
ok  FoldList[Divide, 1, Range[10]]    ==>     {1, 1, 1/2, 1/6, 1/24, 1/120, 1/720, 1/5040, 1/40320, 1/362880, 1/3628800}
    ---
    data:
        got: {1, 1, 1/2, 1/6, 1/24, 1/120, 1/720, 1/5040, 1/40320, 1/362880, 1/3628800}
        expect: {1, 1, 1/2, 1/6, 1/24, 1/120, 1/720, 1/5040, 1/40320, 1/362880, 1/3628800}
        expect_evaluated: {1, 1, 1/2, 1/6, 1/24, 1/120, 1/720, 1/5040, 1/40320, 1/362880, 1/3628800}
    ...
# Successive ratios in a list:
ok  Apply[Divide, Partition[{a, b, c, d, e}, 2, 1], {1}]    ==>     {a/b, b/c, c/d, d/e}
    ---
    data:
        got: {a/b, b/c, c/d, d/e}
        expect: {a/b, b/c, c/d, d/e}
        expect_evaluated: {a/b, b/c, c/d, d/e}
    ...
# Expand quotients:
ok  (x + y)/z    ==>     (x + y)/z
    ---
    data:
        got: (x + y)/z
        expect: (x + y)/z
        expect_evaluated: (x + y)/z
    ...
ok  Expand[%]    ==>     x/z + y/z # skip
# Cancel common factors in rational expressions:
ok  Cancel[(1 - x^2)/(1 - x)]    ==>     1 + x
    ---
    data:
        got: 1 + x
        expect: 1 + x
        expect_evaluated: 1 + x
    ...
# Split into partial fractions:
ok  Apart[1/(x^2 - 1)]    ==>     1/(2*(-1 + x)) - 1/(2*(1 + x))
    ---
    data:
        got: 1/(2*(-1 + x)) - 1/(2*(1 + x))
        expect: 1/(2*(-1 + x)) - 1/(2*(1 + x))
        expect_evaluated: 1/(2*(-1 + x)) - 1/(2*(1 + x))
    ...
ok  1/0    ==>     ComplexInfinity
    ---
    data:
        got: ComplexInfinity
        expect: ComplexInfinity
        expect_evaluated: ComplexInfinity
    ...
ok  0/0    ==>     Indeterminate
    ---
    data:
        got: Indeterminate
        expect: Indeterminate
        expect_evaluated: Indeterminate
    ...
ok  1/Infinity    ==>     0
    ---
    data:
        got: 0
        expect: 0
        expect_evaluated: 0
    ...
# Pattern matching relies on RefLink[FullForm,paclet:ref/FullForm]:
ok  Replace[x^2/y^3, (a_)/(b_) -> f[a, b]]    ==>     x^2/y^3
    ---
    data:
        got: x^2/y^3
        expect: x^2/y^3
        expect_evaluated: x^2/y^3
    ...
ok  FullForm[x^2/y^3]    ==>     x^2/y^3 # skip
ok  Replace[x^2/y^3, (a:_^(_.))*(b:_^(_.)) -> f[a, b]]    ==>     f[x^2, 1/y^3]
    ---
    data:
        got: f[x^2, y^(-3)]
        expect: f[x^2, 1/y^3]
        expect_evaluated: f[x^2, y^(-3)]
    ...
ok  NestList[1/(1 + #1) & , x, 5]    ==>     {x, 1/(1 + x), 1/(1 + 1/(1 + x)), 1/(1 + 1/(1 + 1/(1 + x))), 1/(1 + 1/(1 + 1/(1 + 1/(1 + x)))), 1/(1 + 1/(1 + 1/(1 + 1/(1 + 1/(1 + x)))))}
    ---
    data:
        got: {x, (1 + x)^(-1), (1 + (1 + x)^(-1))^(-1), (1 + (1 + (1 + x)^(-1))^(-1))^(-1), (1 + (1 + (1 + (1 + x)^(-1))^(-1))^(-1))^(-1), (1 + (1 + (1 + (1 + (1 + x)^(-1))^(-1))^(-1))^(-1))^(-1)}
        expect: {x, 1/(1 + x), 1/(1 + 1/(1 + x)), 1/(1 + 1/(1 + 1/(1 + x))), 1/(1 + 1/(1 + 1/(1 + 1/(1 + x)))), 1/(1 + 1/(1 + 1/(1 + 1/(1 + 1/(1 + x)))))}
        expect_evaluated: {x, (1 + x)^(-1), (1 + (1 + x)^(-1))^(-1), (1 + (1 + (1 + x)^(-1))^(-1))^(-1), (1 + (1 + (1 + (1 + x)^(-1))^(-1))^(-1))^(-1), (1 + (1 + (1 + (1 + (1 + x)^(-1))^(-1))^(-1))^(-1))^(-1)}
    ...
# Array of possible fractions:
ok  Array[Divide, {4, 4}]    ==>     {{1, 1/2, 1/3, 1/4}, {2, 1, 2/3, 1/2}, {3, 3/2, 1, 3/4}, {4, 2, 4/3, 1}}
    ---
    data:
        got: {{1, 1/2, 1/3, 1/4}, {2, 1, 2/3, 1/2}, {3, 3/2, 1, 3/4}, {4, 2, 4/3, 1}}
        expect: {{1, 1/2, 1/3, 1/4}, {2, 1, 2/3, 1/2}, {3, 3/2, 1, 3/4}, {4, 2, 4/3, 1}}
        expect_evaluated: {{1, 1/2, 1/3, 1/4}, {2, 1, 2/3, 1/2}, {3, 3/2, 1, 3/4}, {4, 2, 4/3, 1}}
    ...
# Integers that divide exactly:
ok  HoldComplete[ListPlot[Position[Array[Divide, {20, 20}], _Integer]]]    ==>     $Failed # skip
