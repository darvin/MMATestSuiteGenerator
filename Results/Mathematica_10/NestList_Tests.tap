#! DOCKER > wolfram -script output/Tests/NestList_Tests.m
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
#! TextForm[ColonForm[MessageName[ListLinePlot, lpn], StringForm[`1` is not a list of numbers or pairs of numbers., Short[HoldForm[Hold[Out[$Line - 1]]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: NestList_Tests
ok  $Failed    ==>     HoldComplete[{x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]]}] # skip
ok  NestList[Cos, 1., 10]    ==>     {1., 0.540302, 0.857553, 0.65429, 0.79348, 0.701369, 0.76396, 0.722102, 0.750418, 0.731404, 0.744237}
    ---
    data:
        got: {1., 0.540302, 0.857553, 0.65429, 0.79348, 0.701369, 0.76396, 0.722102, 0.750418, 0.731404, 0.744237}
        expect: {1., 0.540302, 0.857553, 0.65429, 0.79348, 0.701369, 0.76396, 0.722102, 0.750418, 0.731404, 0.744237}
        expect_evaluated: {1., 0.540302, 0.857553, 0.65429, 0.79348, 0.701369, 0.76396, 0.722102, 0.750418, 0.731404, 0.744237}
    ...
# The function to nest can be a pure function:
ok  NestList[(1 + #1)^2 & , x, 3]    ==>     {x, (1 + x)^2, (1 + (1 + x)^2)^2, (1 + (1 + (1 + x)^2)^2)^2}
    ---
    data:
        got:            2              2 2                   2 2 2
#! {x, (1 + x) , (1 + (1 + x) ) , (1 + (1 + (1 + x) ) ) }
        expect: {x, (1 + x)^2, (1 + (1 + x)^2)^2, (1 + (1 + (1 + x)^2)^2)^2}
        expect_evaluated:            2              2 2                   2 2 2
#! {x, (1 + x) , (1 + (1 + x) ) , (1 + (1 + (1 + x) ) ) }
    ...
# Nesting a function can build a formula:
ok  NestList[(1 + #1)^2 & , x, 3]    ==>     {x, (1 + x)^2, (1 + (1 + x)^2)^2, (1 + (1 + (1 + x)^2)^2)^2}
    ---
    data:
        got:            2              2 2                   2 2 2
#! {x, (1 + x) , (1 + (1 + x) ) , (1 + (1 + (1 + x) ) ) }
        expect: {x, (1 + x)^2, (1 + (1 + x)^2)^2, (1 + (1 + (1 + x)^2)^2)^2}
        expect_evaluated:            2              2 2                   2 2 2
#! {x, (1 + x) , (1 + (1 + x) ) , (1 + (1 + (1 + x) ) ) }
    ...
# Nesting can return a single number:
ok  NestList[Sqrt, 100., 4]    ==>     {100., 10., 3.16228, 1.77828, 1.33352}
    ---
    data:
        got: {100., 10., 3.16228, 1.77828, 1.33352}
        expect: {100., 10., 3.16228, 1.77828, 1.33352}
        expect_evaluated: {100., 10., 3.16228, 1.77828, 1.33352}
    ...
# The nested function can operate on a list:
ok  With[{\[Epsilon] = 0.1}, NestList[Function[xy, {2*\[Epsilon], 0} + {{1 - 2*\[Epsilon], 0}, {0, 1 - 2*\[Epsilon]}} . xy], {1., 1.}, 4]]    ==>     {{1., 1.}, {1., 0.8}, {1., 0.64}, {1., 0.512}, {1., 0.4096}}
    ---
    data:
        got: {{1., 1.}, {1., 0.8}, {1., 0.64}, {1., 0.512}, {1., 0.4096}}
        expect: {{1., 1.}, {1., 0.8}, {1., 0.64}, {1., 0.512}, {1., 0.4096}}
        expect_evaluated: {{1., 1.}, {1., 0.8}, {1., 0.64}, {1., 0.512}, {1., 0.4096}}
    ...
# To nest a function of more than one argument, the arguments can be put into a list:
ok  NestList[{(#1[[1]] + #1[[2]])/2, Sqrt[#1[[1]]*#1[[2]]]} & , {0.5, 1.}, 4]    ==>     {{0.5, 1.}, {0.75, 0.707107}, {0.728553, 0.728238}, {0.728396, 0.728396}, {0.728396, 0.728396}}
    ---
    data:
        got: {{0.5, 1.}, {0.75, 0.707107}, {0.728553, 0.728238}, {0.728396, 0.728396}, {0.728396, 0.728396}}
        expect: {{0.5, 1.}, {0.75, 0.707107}, {0.728553, 0.728238}, {0.728396, 0.728396}, {0.728396, 0.728396}}
        expect_evaluated: {{0.5, 1.}, {0.75, 0.707107}, {0.728553, 0.728238}, {0.728396, 0.728396}, {0.728396, 0.728396}}
    ...
# Powers of 2:
ok  NestList[2*#1 & , 1, 10]    ==>     {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024}
    ---
    data:
        got: {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024}
        expect: {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024}
        expect_evaluated: {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024}
    ...
# Successive integers:
ok  NestList[#1 + 1 & , 0, 10]    ==>     {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    ---
    data:
        got: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
        expect: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
        expect_evaluated: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    ...
# Successive squaring:
ok  NestList[#1^2 & , 2, 6]    ==>     {2, 4, 16, 256, 65536, 4294967296, 18446744073709551616}
    ---
    data:
        got: {2, 4, 16, 256, 65536, 4294967296, 18446744073709551616}
        expect: {2, 4, 16, 256, 65536, 4294967296, 18446744073709551616}
        expect_evaluated: {2, 4, 16, 256, 65536, 4294967296, 18446744073709551616}
    ...
# Growth of annually compounded capital:
ok  NestList[#1*(1 + 0.05) & , 1000, 10]    ==>     {1000, 1050., 1102.5, 1157.63, 1215.51, 1276.28, 1340.1, 1407.1, 1477.46, 1551.33, 1628.89}
    ---
    data:
        got: {1000, 1050., 1102.5, 1157.63, 1215.51, 1276.28, 1340.1, 1407.1, 1477.46, 1551.33, 1628.89}
        expect: {1000, 1050., 1102.5, 1157.63, 1215.51, 1276.28, 1340.1, 1407.1, 1477.46, 1551.33, 1628.89}
        expect_evaluated: {1000, 1050., 1102.5, 1157.63, 1215.51, 1276.28, 1340.1, 1407.1, 1477.46, 1551.33, 1628.89}
    ...
# Successive derivatives:
ok  NestList[D[#1, x] & , x^n, 3]    ==>     {x^n, n*x^(-1 + n), (-1 + n)*n*x^(-2 + n), (-2 + n)*(-1 + n)*n*x^(-3 + n)}
    ---
    data:
        got:   n     -1 + n              -2 + n                       -3 + n
#! {x , n x      , (-1 + n) n x      , (-2 + n) (-1 + n) n x      }
        expect: {x^n, n*x^(-1 + n), (-1 + n)*n*x^(-2 + n), (-2 + n)*(-1 + n)*n*x^(-3 + n)}
        expect_evaluated:   n     -1 + n              -2 + n                       -3 + n
#! {x , n x      , (-1 + n) n x      , (-2 + n) (-1 + n) n x      }
    ...
# Newton iterations for Sqrt[2]:
ok  NestList[(#1 + 2/#1)/2 & , 1., 5]    ==>     {1., 1.5, 1.41667, 1.41422, 1.41421, 1.41421}
    ---
    data:
        got: {1., 1.5, 1.41667, 1.41422, 1.41421, 1.41421}
        expect: {1., 1.5, 1.41667, 1.41422, 1.41421, 1.41421}
        expect_evaluated: {1., 1.5, 1.41667, 1.41422, 1.41421, 1.41421}
    ...
# Continued fraction:
ok  NestList[1/(1 + #1) & , x, 5]    ==>     {x, 1/(1 + x), 1/(1 + 1/(1 + x)), 1/(1 + 1/(1 + 1/(1 + x))), 1/(1 + 1/(1 + 1/(1 + 1/(1 + x)))), 1/(1 + 1/(1 + 1/(1 + 1/(1 + 1/(1 + x)))))}
    ---
    data:
        got:       1        1            1                1                    1
#! {x, -----, ---------, -------------, -----------------, ---------------------}
    1 + x        1            1                1                    1
#!            1 + -----  1 + ---------  1 + -------------  1 + -----------------
#!                1 + x            1                1                    1
#!                           1 + -----      1 + ---------      1 + -------------
#!                               1 + x                1                    1
#!                                              1 + -----          1 + ---------
#!                                                  1 + x                    1
#!                                                                     1 + -----
#!                                                                         1 + x
        expect: {x, 1/(1 + x), 1/(1 + 1/(1 + x)), 1/(1 + 1/(1 + 1/(1 + x))), 1/(1 + 1/(1 + 1/(1 + 1/(1 + x)))), 1/(1 + 1/(1 + 1/(1 + 1/(1 + 1/(1 + x)))))}
        expect_evaluated:       1        1            1                1                    1
#! {x, -----, ---------, -------------, -----------------, ---------------------}
    1 + x        1            1                1                    1
#!            1 + -----  1 + ---------  1 + -------------  1 + -----------------
#!                1 + x            1                1                    1
#!                           1 + -----      1 + ---------      1 + -------------
#!                               1 + x                1                    1
#!                                              1 + -----          1 + ---------
#!                                                  1 + x                    1
#!                                                                     1 + -----
#!                                                                         1 + x
    ...
# Iterated map:
ok  NestList[(4*#1)*(1 - #1) & , 1/3, 5]    ==>     {1/3, 8/9, 32/81, 6272/6561, 7250432/43046721, 1038154236987392/1853020188851841}
    ---
    data:
        got:  1  8  32  6272  7250432   1038154236987392
#! {-, -, --, ----, --------, ----------------}
#!  3  9  81  6561  43046721  1853020188851841
        expect: {1/3, 8/9, 32/81, 6272/6561, 7250432/43046721, 1038154236987392/1853020188851841}
        expect_evaluated:  1  8  32  6272  7250432   1038154236987392
#! {-, -, --, ----, --------, ----------------}
#!  3  9  81  6561  43046721  1853020188851841
    ...
ok  NestList[(4*#1)*(1 - #1) & , N[1/3], 10]    ==>     {0.333333, 0.888889, 0.395062, 0.955952, 0.168432, 0.56025, 0.98548, 0.0572373, 0.215845, 0.677023, 0.874651}
    ---
    data:
        got: {0.333333, 0.888889, 0.395062, 0.955952, 0.168432, 0.56025, 0.98548, 0.0572373, 0.215845, 0.677023, 0.874651}
        expect: {0.333333, 0.888889, 0.395062, 0.955952, 0.168432, 0.56025, 0.98548, 0.0572373, 0.215845, 0.677023, 0.874651}
        expect_evaluated: {0.333333, 0.888889, 0.395062, 0.955952, 0.168432, 0.56025, 0.98548, 0.0572373, 0.215845, 0.677023, 0.874651}
    ...
# Iterates in the 3 n+1 problem:
ok  NestList[If[EvenQ[#1], #1/2, (3*#1 + 1)/2] & , 100, 20]    ==>     {100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1, 2, 1}
    ---
    data:
        got: {100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1, 2, 1}
        expect: {100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1, 2, 1}
        expect_evaluated: {100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1, 2, 1}
    ...
# Linear congruential pseudorandom generator:
ok  NestList[Mod[59*#1, 101] & , 1, 15]    ==>     {1, 59, 47, 46, 88, 41, 96, 8, 68, 73, 65, 98, 25, 61, 64, 39}
    ---
    data:
        got: {1, 59, 47, 46, 88, 41, 96, 8, 68, 73, 65, 98, 25, 61, 64, 39}
        expect: {1, 59, 47, 46, 88, 41, 96, 8, 68, 73, 65, 98, 25, 61, 64, 39}
        expect_evaluated: {1, 59, 47, 46, 88, 41, 96, 8, 68, 73, 65, 98, 25, 61, 64, 39}
    ...
# Random walk:
ok  NestList[#1 + RandomChoice[{-1, 1}] & , 0, 20]    ==>     {0, -1, -2, -3, -2, -1, -2, -1, -2, -1, 0, 1, 2, 1, 2, 3, 2, 3, 2, 1, 0} # skip
not ok  HoldComplete[ListLinePlot[%]]    ==>     $Failed
    ---
    data:
        got: -Graphics-
        expect: $Failed
        expect_evaluated: $Failed
    ...
# Iterated string replacements:
ok  NestList[StringReplace[#1, {"A" -> "BA", "B" -> "AB"}] & , "A", 5]    ==>     {A, BA, ABBA, BAABABBA, ABBABAABBAABABBA, BAABABBAABBABAABABBABAABBAABABBA}
    ---
    data:
        got: {A, BA, ABBA, BAABABBA, ABBABAABBAABABBA, BAABABBAABBABAABABBABAABBAABABBA}
        expect: {A, BA, ABBA, BAABABBA, ABBABAABBAABABBA, BAABABBAABBABAABABBABAABBAABABBA}
        expect_evaluated: {A, BA, ABBA, BAABABBA, ABBABAABBAABABBA, BAABABBAABBABAABABBABAABBAABABBA}
    ...
# Successively append to a list:
ok  NestList[Append[#1, x] & , {a}, 5]    ==>     {{a}, {a, x}, {a, x, x}, {a, x, x, x}, {a, x, x, x, x}, {a, x, x, x, x, x}}
    ---
    data:
        got: {{a}, {a, x}, {a, x, x}, {a, x, x, x}, {a, x, x, x, x}, {a, x, x, x, x, x}}
        expect: {{a}, {a, x}, {a, x, x}, {a, x, x, x}, {a, x, x, x, x}, {a, x, x, x, x, x}}
        expect_evaluated: {{a}, {a, x}, {a, x, x}, {a, x, x, x}, {a, x, x, x, x}, {a, x, x, x, x, x}}
    ...
# Successively rotate a list:
ok  NestList[RotateLeft, {a, b, c, d}, 4]    ==>     {{a, b, c, d}, {b, c, d, a}, {c, d, a, b}, {d, a, b, c}, {a, b, c, d}}
    ---
    data:
        got: {{a, b, c, d}, {b, c, d, a}, {c, d, a, b}, {d, a, b, c}, {a, b, c, d}}
        expect: {{a, b, c, d}, {b, c, d, a}, {c, d, a, b}, {d, a, b, c}, {a, b, c, d}}
        expect_evaluated: {{a, b, c, d}, {b, c, d, a}, {c, d, a, b}, {d, a, b, c}, {a, b, c, d}}
    ...
# Operations on a pair of values:
ok  NestList[{f[Last[#1]], g[First[#1]]} & , {x, y}, 5]    ==>     {{x, y}, {f[y], g[x]}, {f[g[x]], g[f[y]]}, {f[g[f[y]]], g[f[g[x]]]}, {f[g[f[g[x]]]], g[f[g[f[y]]]]}, {f[g[f[g[f[y]]]]], g[f[g[f[g[x]]]]]}}
    ---
    data:
        got: {{x, y}, {f[y], g[x]}, {f[g[x]], g[f[y]]}, {f[g[f[y]]], g[f[g[x]]]}, {f[g[f[g[x]]]], g[f[g[f[y]]]]}, {f[g[f[g[f[y]]]]], g[f[g[f[g[x]]]]]}}
        expect: {{x, y}, {f[y], g[x]}, {f[g[x]], g[f[y]]}, {f[g[f[y]]], g[f[g[x]]]}, {f[g[f[g[x]]]], g[f[g[f[y]]]]}, {f[g[f[g[f[y]]]]], g[f[g[f[g[x]]]]]}}
        expect_evaluated: {{x, y}, {f[y], g[x]}, {f[g[x]], g[f[y]]}, {f[g[f[y]]], g[f[g[x]]]}, {f[g[f[g[x]]]], g[f[g[f[y]]]]}, {f[g[f[g[f[y]]]]], g[f[g[f[g[x]]]]]}}
    ...
# RefLink[Nest,paclet:ref/Nest] gives the last element of RefLink[NestList,paclet:ref/NestList]:
ok  NestList[f, x, 4]    ==>     {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]]}
    ---
    data:
        got: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]]}
        expect: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]]}
        expect_evaluated: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]]}
    ...
ok  Nest[f, x, 4]    ==>     f[f[f[f[x]]]]
    ---
    data:
        got: f[f[f[f[x]]]]
        expect: f[f[f[f[x]]]]
        expect_evaluated: f[f[f[f[x]]]]
    ...
# Nesting zero times simply returns to the original argument:
ok  NestList[f, x, 0]    ==>     {x}
    ---
    data:
        got: {x}
        expect: {x}
        expect_evaluated: {x}
    ...
# RefLink[FixedPointList,paclet:ref/FixedPointList] goes on until the result no longer changes:
ok  NestList[1 + Floor[#1/2] & , 1000, 15]    ==>     {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2, 2, 2, 2, 2}
    ---
    data:
        got: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2, 2, 2, 2, 2}
        expect: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2, 2, 2, 2, 2}
        expect_evaluated: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2, 2, 2, 2, 2}
    ...
ok  FixedPointList[1 + Floor[#1/2] & , 1000, 15]    ==>     {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2}
    ---
    data:
        got: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2}
        expect: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2}
        expect_evaluated: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2}
    ...
# RefLink[NestWhileList,paclet:ref/NestWhileList] goes on while a condition is true:
ok  NestWhileList[If[EvenQ[#1], #1/2, (3*#1 + 1)/2] & , 29, #1 > 1 & ]    ==>     {29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1}
    ---
    data:
        got: {29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1}
        expect: {29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1}
        expect_evaluated: {29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1}
    ...
# RefLink[FoldList,paclet:ref/FoldList] automatically inserts second arguments from a list:
ok  NestList[f[#1, a] & , x, 3]    ==>     {x, f[x, a], f[f[x, a], a], f[f[f[x, a], a], a]}
    ---
    data:
        got: {x, f[x, a], f[f[x, a], a], f[f[f[x, a], a], a]}
        expect: {x, f[x, a], f[f[x, a], a], f[f[f[x, a], a], a]}
        expect_evaluated: {x, f[x, a], f[f[x, a], a], f[f[f[x, a], a], a]}
    ...
ok  FoldList[f, x, {a, a, a}]    ==>     {x, f[x, a], f[f[x, a], a], f[f[f[x, a], a], a]}
    ---
    data:
        got: {x, f[x, a], f[f[x, a], a], f[f[f[x, a], a], a]}
        expect: {x, f[x, a], f[f[x, a], a], f[f[f[x, a], a], a]}
        expect_evaluated: {x, f[x, a], f[f[x, a], a], f[f[f[x, a], a], a]}
    ...
ok  NestList[Framed, x, 6]    ==>     {x, x, x, x, x, x, x} # skip
# Power towers:
ok  NestList[x^#1 & , x, 6]    ==>     {x, x^x, x^x^x, x^x^x^x, x^x^x^x^x, x^x^x^x^x^x, x^x^x^x^x^x^x}
    ---
    data:
        got:                                         x
#!                                x       x
#!                        x      x       x
#!                 x     x      x       x
#!           x    x     x      x       x
     x   x    x     x      x       x
#! {x, x , x  , x   , x    , x     , x      }
        expect: {x, x^x, x^x^x, x^x^x^x, x^x^x^x^x, x^x^x^x^x^x, x^x^x^x^x^x^x}
        expect_evaluated:                                         x
#!                                x       x
#!                        x      x       x
#!                 x     x      x       x
#!           x    x     x      x       x
     x   x    x     x      x       x
#! {x, x , x  , x   , x    , x     , x      }
    ...
ok  NestList[#1^#1 & , x, 4]    ==>     {x, x^x, (x^x)^x^x, ((x^x)^x^x)^(x^x)^x^x, (((x^x)^x^x)^(x^x)^x^x)^((x^x)^x^x)^(x^x)^x^x}
    ---
    data:
        got:                                                              x
#!                              x                x       x   x x
#!              x        x   x x          x   x x     x x  (x )
     x    x x      x x  (x )        x x  (x )   ((x )  )
#! {x, x , (x )  , ((x )  )      , (((x )  )      )              }
        expect: {x, x^x, (x^x)^x^x, ((x^x)^x^x)^(x^x)^x^x, (((x^x)^x^x)^(x^x)^x^x)^((x^x)^x^x)^(x^x)^x^x}
        expect_evaluated:                                                              x
#!                              x                x       x   x x
#!              x        x   x x          x   x x     x x  (x )
     x    x x      x x  (x )        x x  (x )   ((x )  )
#! {x, x , (x )  , ((x )  )      , (((x )  )      )              }
    ...
ok  HoldComplete[NestList[Framed[Row[{#1, #1}]] & , x, 4]]    ==>     $Failed # skip
ok  NestList[p[#1][#1] & , x, 3]    ==>     {x, p[x][x], p[p[x][x]][p[x][x]], p[p[p[x][x]][p[x][x]]][p[p[x][x]][p[x][x]]]}
    ---
    data:
        got: {x, p[x][x], p[p[x][x]][p[x][x]], p[p[p[x][x]][p[x][x]]][p[p[x][x]][p[x][x]]]}
        expect: {x, p[x][x], p[p[x][x]][p[x][x]], p[p[p[x][x]][p[x][x]]][p[p[x][x]][p[x][x]]]}
        expect_evaluated: {x, p[x][x], p[p[x][x]][p[x][x]], p[p[p[x][x]][p[x][x]]][p[p[x][x]][p[x][x]]]}
    ...
ok  HoldComplete[NestList[Subsuperscript[#1, #1, #1] & , x, 4]]    ==>     $Failed # skip
