#! DOCKER > wolfram -script output/Tests/Arg_Tests.m
#! TextForm[ColonForm[MessageName[Arg, indet], StringForm[Indeterminate expression `1` encountered., Short[HoldForm[Arg[ComplexInfinity]], 3]]]]
#! TextForm[ColonForm[MessageName[N, meprec], StringForm[Internal precision limit $MaxExtraPrecision = `1` reached while evaluating `2`., Short[HoldForm[50.], 3], Short[HoldForm[Log[-1 - 2*E - E^2 - I/E^E^(2*Pi) + (1 + E)^2]], 3]]]]
#! TextForm[ColonForm[MessageName[N, meprec], StringForm[Internal precision limit $MaxExtraPrecision = `1` reached while evaluating `2`., Short[HoldForm[50.], 3], Short[HoldForm[ArcTan[-1 - 2*E - E^2 + (1 + E)^2, -E^(-E^(2*Pi))]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: Arg_Tests
# The result is given in radians:
ok  Arg[-1]    ==>     Pi
    ---
    data:
        got: Pi
        expect: Pi
        expect_evaluated: Pi
    ...
ok  Arg[1 + I]    ==>     Pi/4
    ---
    data:
        got: Pi/4
        expect: Pi/4
        expect_evaluated: Pi/4
    ...
ok  HoldComplete[Plot3D[Arg[x + I*y], {x, -3, 3}, {y, -3, 3}]]    ==>     $Failed # skip
ok  Arg[1.2]    ==>     0
    ---
    data:
        got: 0
        expect: 0
        expect_evaluated: 0
    ...
ok  Arg[-3.2*I]    ==>     -1.5708 # skip
ok  Arg[1.6 + I]    ==>     0.558599 # skip
ok  Arg[1.6`23.204119982655925 + I]    ==>     0.55859931534356243597151`22.74710039906514
    ---
    data:
        got: 0.55859931534356243597150821640166127037`23.298550397038014
        expect: 0.55859931534356243597151`22.74710039906514
        expect_evaluated: 0.55859931534356243597151`22.74710039906514
    ...
ok  Arg[{1.2, 1.5*I, -1.8*I}]    ==>     {0, 1.5708, -1.5708} # skip
ok  Arg[1*u*v - I]    ==>     {{0, Arg[u]}, {Arg[v], -(Pi/2)}} # skip
ok  Arg[2 + I*Pi]    ==>     ArcTan[Pi/2]
    ---
    data:
        got: ArcTan[Pi/2]
        expect: ArcTan[Pi/2]
        expect_evaluated: ArcTan[Pi/2]
    ...
ok  Arg[Infinity]    ==>     0
    ---
    data:
        got: 0
        expect: 0
        expect_evaluated: 0
    ...
ok  Arg[-Infinity]    ==>     Pi
    ---
    data:
        got: Pi
        expect: Pi
        expect_evaluated: Pi
    ...
ok  HoldComplete[SparseArray[{{1, 1} -> -6, {1, 3} -> I*Pi, {3, 3} -> 2, {4, 2} -> u, {_, _} -> 1}]]    ==>     $Failed # skip
ok  Normal[Arg[%]]    ==>     {{Pi, 0, Pi/2}, {0, 0, 0}, {0, 0, 0}, {0, Arg[u], 0}} # skip
ok  ({Abs[#1], Arg[#1]} & )[1 + 3*I]    ==>     {Sqrt[10], ArcTan[3]}
    ---
    data:
        got: {Sqrt[10], ArcTan[3]}
        expect: {Sqrt[10], ArcTan[3]}
        expect_evaluated: {Sqrt[10], ArcTan[3]}
    ...
ok  HoldComplete[Plot3D[Abs[Sin[x + I*y]], {x, -2*Pi, 2*Pi}, {y, -1, 1}, ColorFunction -> (Hue[Arg[Sin[#1 + I*#2]]] & )]]    ==>     $Failed # skip
ok  PowerExpand[Sqrt[z^2], Assumptions -> {}]    ==>     E^(I*Pi*Floor[1/2 - Arg[z]/Pi])*z
    ---
    data:
        got: E^(I*Pi*Floor[1/2 - Arg[z]/Pi])*z
        expect: E^(I*Pi*Floor[1/2 - Arg[z]/Pi])*z
        expect_evaluated: E^(I*Pi*Floor[1/2 - Arg[z]/Pi])*z
    ...
ok  PowerExpand[Log[1/z], Assumptions -> {}]    ==>     2*I*Pi*Floor[1/2 + Arg[z]/(2*Pi)] - Log[z]
    ---
    data:
        got: (2*I)*Pi*Floor[1/2 + Arg[z]/(2*Pi)] - Log[z]
        expect: 2*I*Pi*Floor[1/2 + Arg[z]/(2*Pi)] - Log[z]
        expect_evaluated: (2*I)*Pi*Floor[1/2 + Arg[z]/(2*Pi)] - Log[z]
    ...
ok  Simplify[x*Arg[I*x], x > 3]    ==>     (Pi*x)/2
    ---
    data:
        got: (Pi*x)/2
        expect: (Pi*x)/2
        expect_evaluated: (Pi*x)/2
    ...
ok  FullSimplify[Arg[z] - I*Log[z/Abs[z]] - I*Log[Sign[z]], z != 0]    ==>     3*Arg[z] # skip
# Generate RefLink[Arg,paclet:ref/Arg] from RefLink[FullSimplify,paclet:ref/FullSimplify]:
ok  FullSimplify[Im[Log[z]]]    ==>     Arg[z]
    ---
    data:
        got: Arg[z]
        expect: Arg[z]
        expect_evaluated: Arg[z]
    ...
ok  TrigToExp[ComplexExpand[z, z, TargetFunctions -> {Abs, Arg}]]    ==>     E^(I*Arg[z])*Abs[z]
    ---
    data:
        got: E^(I*Arg[z])*Abs[z]
        expect: E^(I*Arg[z])*Abs[z]
        expect_evaluated: E^(I*Arg[z])*Abs[z]
    ...
ok  ComplexExpand[Re[ArcSin[x + I*y]], TargetFunctions -> {Arg}]    ==>     Arg[Sqrt[1 - (x + I*y)^2] + I*(x + I*y)]
    ---
    data:
        got: Arg[Sqrt[1 - (x + I*y)^2] + I*(x + I*y)]
        expect: Arg[Sqrt[1 - (x + I*y)^2] + I*(x + I*y)]
        expect_evaluated: Arg[Sqrt[1 - (x + I*y)^2] + I*(x + I*y)]
    ...
# Rescale RefLink[Arg,paclet:ref/Arg] to run from 0 to 1:
ok  Table[Rescale[Arg[I^n], {-Pi, Pi}], {n, 5}]    ==>     {3/4, 1, 1/4, 1/2, 3/4}
    ---
    data:
        got: {3/4, 1, 1/4, 1/2, 3/4}
        expect: {3/4, 1, 1/4, 1/2, 3/4}
        expect_evaluated: {3/4, 1, 1/4, 1/2, 3/4}
    ...
ok  Table[Arg[I^n], {n, 5}]    ==>     {Pi/2, Pi, -(Pi/2), 0, Pi/2}
    ---
    data:
        got: {Pi/2, Pi, -Pi/2, 0, Pi/2}
        expect: {Pi/2, Pi, -(Pi/2), 0, Pi/2}
        expect_evaluated: {Pi/2, Pi, -Pi/2, 0, Pi/2}
    ...
ok  Reduce[Arg[x + c] > 0, x, Complexes]    ==>     (Re[x] < -Re[c] && Im[x] >= -Im[c]) || (Re[x] >= -Re[c] && Im[x] > -Im[c])
    ---
    data:
        got: (Re[x] < -Re[c] && Im[x] >= -Im[c]) || (Re[x] >= -Re[c] && Im[x] > -Im[c])
        expect: (Re[x] < -Re[c] && Im[x] >= -Im[c]) || (Re[x] >= -Re[c] && Im[x] > -Im[c])
        expect_evaluated: (Re[x] < -Re[c] && Im[x] >= -Im[c]) || (Re[x] >= -Re[c] && Im[x] > -Im[c])
    ...
# Use RefLink[Arg,paclet:ref/Arg] to specify assumptions about complex variables:
ok  Series[ArcSin[x], {x, ComplexInfinity, 2}, Assumptions -> Pi/4 < Arg[x] < 3*(Pi/4)]    ==>     (1/2)*(Pi + I*Log[4] - 2*I*Log[1/x]) - I/(4*x^2) + O[1/x]^3 # skip
ok  Series[ArcSin[x], {x, ComplexInfinity, 2}]    ==>     (-1)^Floor[-(Arg[x]/Pi)]*(Pi*Floor[-(Arg[x]/Pi)] + 2*Pi*Floor[(Pi + Arg[x])/(2*Pi)] + ((1/2)*(Pi - I*Log[4] + 2*I*Log[1/x]) + I/(4*x^2) + O[1/x]^3)) # skip
# Degenerate cases give intervals as results :
ok  Arg[ComplexInfinity]    ==>     Interval[{-Pi, Pi}]
    ---
    data:
        got: Interval[{-Pi, Pi}]
        expect: Interval[{-Pi, Pi}]
        expect_evaluated: Interval[{-Pi, Pi}]
    ...
# Numerical decision procedures with default settings cannot simplify this expression: 
ok  a = Arg[-1 - 2*E - E^2 + (1 + E)^2 - I*Exp[-Exp[2*Pi]]]    ==>     ArcTan[-1 - 2*E - E^2 + (1 + E)^2, -E^(-E^(2*Pi))]
    ---
    data:
        got: ArcTan[-1 - 2*E - E^2 + (1 + E)^2, -E^(-E^(2*Pi))]
        expect: ArcTan[-1 - 2*E - E^2 + (1 + E)^2, -E^(-E^(2*Pi))]
        expect_evaluated: ArcTan[-1 - 2*E - E^2 + (1 + E)^2, -E^(-E^(2*Pi))]
    ...
# The machine-precision result is incorrect: 
ok  N[a]    ==>     -3.14159 # skip
# The arbitrary-precision result indicates that the result may be incorrect: 
ok  N[a, 20]    ==>     0.
    ---
    data:
        got: 0``-0.19611987703015218
        expect: 0.
        expect_evaluated: 0.
    ...
# Using a larger setting for RefLink[$MaxExtraPrecision,paclet:ref/$MaxExtraPrecision] gives the correct result: 
ok  Block[{$MaxExtraPrecision = 1000}, N[a, 20]]    ==>     -1.57079632679489661920000000001`19.196119877030153
    ---
    data:
        got: -1.5707963267948966192313216916397514421`20.
        expect: -1.57079632679489661920000000001`19.196119877030153
        expect_evaluated: -1.57079632679489661920000000001`19.196119877030153
    ...
# The input contains a hidden zero, and simplifying the argument gets the correct answer:
ok  Arg[Simplify[-1 - 2*E - E^2 + (1 + E)^2 - I*Exp[-Exp[2*Pi]]]]    ==>     -(Pi/2)
    ---
    data:
        got: -Pi/2
        expect: -(Pi/2)
        expect_evaluated: -Pi/2
    ...
ok  HoldComplete[Plot[Arg[1/(((3/2)*Exp[I*\[CurlyPhi]])^4 - 1)], {\[CurlyPhi], 0, 2*Pi}]]    ==>     $Failed # skip
ok  HoldComplete[Plot3D[Arg[1/((x + I*y)^8 - 1)], {x, -2, 2}, {y, -2, 2}, Mesh -> False, RegionFunction -> (Norm[{#1, #2}] < 2 & )]]    ==>     $Failed # skip
