#! DOCKER > wolfram -script output/Tests/Count_Tests.m
# SYSTEM: Mathematica_10
# TEST: Count_Tests
# Count how many times b occurs:
ok  Count[{a, b, a, a, b, c, b}, b]    ==>     3
    ---
    data:
        got: 3
        expect: 3
        expect_evaluated: 3
    ...
# Count powers of x in an RefLink[Association,paclet:ref/Association]:
ok  Count[<| 1 -> 1 + x^2, 2 -> x^4, 3 -> a + (1 + x^2)^2 |>, x^_]    ==>     1
    ---
    data:
        got: 1
        expect: 1
        expect_evaluated: 1
    ...
# Count powers of x on all levels:
ok  Count[<| 1 -> 1 + x^2, 2 -> x^4, 3 -> a + (1 + x^2)^2 |>, x^_, Infinity]    ==>     3
    ---
    data:
        got: 3
        expect: 3
        expect_evaluated: 3
    ...
# Count symbols:
ok  Count[<| 1 -> 1 + x^2, 2 -> x^4, 3 -> a + (1 + x^2)^2 |>, _Symbol, Infinity]    ==>     4
    ---
    data:
        got: 4
        expect: 4
        expect_evaluated: 4
    ...
# RefLink[Count,paclet:ref/Count] works with patterns:
ok  Count[{a, 2, a, a, 1, c, b, 3, 3}, _Integer]    ==>     4
    ---
    data:
        got: 4
        expect: 4
        expect_evaluated: 4
    ...
# Count the number of elements not matching b:
ok  Count[{a, b, a, a, b, c, b, a, a}, Except[b]]    ==>     6
    ---
    data:
        got: 6
        expect: 6
        expect_evaluated: 6
    ...
# Count occurrences of b down to level 2:
ok  Count[{{a, a, b}, b, {a, b, a}}, b, 2]    ==>     3
    ---
    data:
        got: 3
        expect: 3
        expect_evaluated: 3
    ...
# Count occurrences at level 2 only:
ok  Count[{{a, a, b}, b, {a, b, a}}, b, {2}]    ==>     2
    ---
    data:
        got: 2
        expect: 2
        expect_evaluated: 2
    ...
# Count all numeric expressions appearing as part of a larger expression:
ok  Count[x^3 + 1.5*x^2 + Pi*x + 7, _?NumericQ, -1]    ==>     5
    ---
    data:
        got: 5
        expect: 5
        expect_evaluated: 5
    ...
# A numeric level specification does not include level zero:
ok  Count[5, _?NumericQ, -1]    ==>     0
    ---
    data:
        got: 0
        expect: 0
        expect_evaluated: 0
    ...
# Use a two-element list to explicitly include level zero:
ok  Count[5, _?NumericQ, {0, -1}]    ==>     1
    ---
    data:
        got: 1
        expect: 1
        expect_evaluated: 1
    ...
# RefLink[Count,paclet:ref/Count] works with any head, not just RefLink[List,paclet:ref/List]:
ok  Count[f[a, b, b, a], b]    ==>     2
    ---
    data:
        got: 2
        expect: 2
        expect_evaluated: 2
    ...
# By default, expressions appearing as heads are not counted:
ok  Count[Sin[x] + Cos[x] + Sin[x]^2, Sin, -1]    ==>     0
    ---
    data:
        got: 0
        expect: 0
        expect_evaluated: 0
    ...
# Use the option RefLink[Heads,paclet:ref/Heads]->RefLink[True,paclet:ref/True] to include them:
ok  Count[Sin[x] + Cos[x] + Sin[x]^2, Sin, -1, Heads -> True]    ==>     2
    ---
    data:
        got: 2
        expect: 2
        expect_evaluated: 2
    ...
# Count the total number of symbols in an expression:
ok  Count[a + b^2/(a + b), _Symbol, Infinity]    ==>     4
    ---
    data:
        got: 4
        expect: 4
        expect_evaluated: 4
    ...
# Count the total number of elements greater than 0.5:
ok  Count[RandomReal[1, {100}], u_ /; u > 0.5]    ==>     40 # skip
# Count the number of rows whose first element is 1:
ok  Count[{{1, 2}, {2, 3}, {1, 5}}, {u_, _} /; u == 1]    ==>     2
    ---
    data:
        got: 2
        expect: 2
        expect_evaluated: 2
    ...
# RefLink[Count,paclet:ref/Count] returns the length of the result given by RefLink[Cases,paclet:ref/Cases]:
ok  Count[{1, "f", g, "h", "7"}, _?StringQ]    ==>     3
    ---
    data:
        got: 3
        expect: 3
        expect_evaluated: 3
    ...
ok  Length[Cases[{1, "f", g, "h", "7"}, _?StringQ]]    ==>     3
    ---
    data:
        got: 3
        expect: 3
        expect_evaluated: 3
    ...
# RefLink[Count,paclet:ref/Count] returns the length of the result given by RefLink[Position,paclet:ref/Position]:
ok  Count[{1, "f", g, "h", "7"}, _?StringQ]    ==>     3
    ---
    data:
        got: 3
        expect: 3
        expect_evaluated: 3
    ...
ok  Length[Position[{1, "f", g, "h", "7"}, _?StringQ]]    ==>     3
    ---
    data:
        got: 3
        expect: 3
        expect_evaluated: 3
    ...
# A count at level {0} is effectively a numericized version of RefLink[MatchQ,paclet:ref/MatchQ]:
ok  MatchQ[5, _Integer]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
ok  Count[5, _Integer, {0}] == 1    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
# For most expressions, RefLink[LeafCount,paclet:ref/LeafCount] equals the count matching RefLink[Blank,paclet:ref/Blank][] at level {-1}:
ok  LeafCount[1 + a + b^2]    ==>     6
    ---
    data:
        got: 6
        expect: 6
        expect_evaluated: 6
    ...
ok  Count[1 + a + b^2, _, {-1}, Heads -> True]    ==>     6
    ---
    data:
        got: 6
        expect: 6
        expect_evaluated: 6
    ...
# RefLink[Count,paclet:ref/Count] treats RefLink[Rational,paclet:ref/Rational] and RefLink[Complex,paclet:ref/Complex] as atoms:
ok  AtomQ /@ {1/2, 1 + I}    ==>     {True, True}
    ---
    data:
        got: {True, True}
        expect: {True, True}
        expect_evaluated: {True, True}
    ...
ok  Count[{1/2, 1 + I}, _, {-1}, Heads -> True]    ==>     3
    ---
    data:
        got: 3
        expect: 3
        expect_evaluated: 3
    ...
# RefLink[LeafCount,paclet:ref/LeafCount] counts RefLink[Rational,paclet:ref/Rational] and RefLink[Complex,paclet:ref/Complex] numbers using their RefLink[FullForm,paclet:ref/FullForm]:
ok  FullForm[{1/2, 1 + I}]    ==>     {Rational[1, 2], Complex[1, 1]} # skip
ok  LeafCount[{1/2, 1 + I}]    ==>     7
    ---
    data:
        got: 7
        expect: 7
        expect_evaluated: 7
    ...
# RefLink[Count,paclet:ref/Count] looks for matches based on patterns, which may not be the same as numerical equality:
ok  Count[{0.9, 0.15*6, 1.8/2}, 0.9]    ==>     2
    ---
    data:
        got: 2
        expect: 2
        expect_evaluated: 2
    ...
# Write a pattern using RefLink[Condition,paclet:ref/Condition] to force searching based on numerical equality:
ok  Count[{0.9, 0.15*6, 1.8/2}, n_ /; n == 0.9]    ==>     3
    ---
    data:
        got: 3
        expect: 3
        expect_evaluated: 3
    ...
