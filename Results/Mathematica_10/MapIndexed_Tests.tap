#! DOCKER > wolfram -script output/Tests/MapIndexed_Tests.m
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
#! TextForm[ColonForm[MessageName[MapIndexed, argtu], StringForm[`1` called with 1 argument; `2` or `3` arguments are expected., Short[HoldForm[MapIndexed], 3], Short[HoldForm[2], 3], Short[HoldForm[3], 3]]]]
# SYSTEM: Mathematica_10
# TEST: MapIndexed_Tests
ok  $Failed    ==>     HoldComplete[{f[a, {1}], f[b, {2}], f[c, {3}], f[d, {4}]}] # skip
# #2 gives the indices of each part:
ok  MapIndexed[First[#2] + f[#1] & , {a, b, c, d}]    ==>     {1 + f[a], 2 + f[b], 3 + f[c], 4 + f[d]}
    ---
    data:
        got: {1 + f[a], 2 + f[b], 3 + f[c], 4 + f[d]}
        expect: {1 + f[a], 2 + f[b], 3 + f[c], 4 + f[d]}
        expect_evaluated: {1 + f[a], 2 + f[b], 3 + f[c], 4 + f[d]}
    ...
ok  MapIndexed[f, {{a, b}, {c, d, e}}]    ==>     {f[{a, b}, {1}], f[{c, d, e}, {2}]}
    ---
    data:
        got: {f[{a, b}, {1}], f[{c, d, e}, {2}]}
        expect: {f[{a, b}, {1}], f[{c, d, e}, {2}]}
        expect_evaluated: {f[{a, b}, {1}], f[{c, d, e}, {2}]}
    ...
ok  MapIndexed[f, {{a, b}, {c, d, e}}, {2}]    ==>     {{f[a, {1, 1}], f[b, {1, 2}]}, {f[c, {2, 1}], f[d, {2, 2}], f[e, {2, 3}]}}
    ---
    data:
        got: {{f[a, {1, 1}], f[b, {1, 2}]}, {f[c, {2, 1}], f[d, {2, 2}], f[e, {2, 3}]}}
        expect: {{f[a, {1, 1}], f[b, {1, 2}]}, {f[c, {2, 1}], f[d, {2, 2}], f[e, {2, 3}]}}
        expect_evaluated: {{f[a, {1, 1}], f[b, {1, 2}]}, {f[c, {2, 1}], f[d, {2, 2}], f[e, {2, 3}]}}
    ...
# Map over an association:
ok  MapIndexed[f, <| "a" -> 1, a -> 2, 1 -> 1 |>]    ==>     <| a -> f[1, {Key[a]}], a -> f[2, {Key[a]}], 1 -> f[1, {Key[1]}] |> # skip
# Map over nested associations:
ok  MapIndexed[h, <| a -> <| b -> c, p -> <| q -> r |> |>, d -> {e} |>, {2}]    ==>     <| a -> <| b -> h[c, {Key[a], Key[b]}], p -> h[<| q -> r |>, {Key[a], Key[p]}] |>, d -> {h[e, {Key[d], 1}]} |>
    ---
    data:
        got: <|a -> <|b -> h[c, {Key[a], Key[b]}], p -> h[<|q -> r|>, {Key[a], Key[p]}]|>, d -> {h[e, {Key[d], 1}]}|>
        expect: <| a -> <| b -> h[c, {Key[a], Key[b]}], p -> h[<| q -> r |>, {Key[a], Key[p]}] |>, d -> {h[e, {Key[d], 1}]} |>
        expect_evaluated: <|a -> <|b -> h[c, {Key[a], Key[b]}], p -> h[<|q -> r|>, {Key[a], Key[p]}]|>, d -> {h[e, {Key[d], 1}]}|>
    ...
# Use the operator form of RefLink[MapIndexed,paclet:ref/MapIndexed]:
ok  MapIndexed[f][{a, b, c, d}]    ==>     {f[a, {1}], f[b, {2}], f[c, {3}], f[d, {4}]} # skip
# Map at level 1 (default):
ok  MapIndexed[f, {{{{{a}}}}}]    ==>     {f[{{{{a}}}}, {1}]}
    ---
    data:
        got: {f[{{{{a}}}}, {1}]}
        expect: {f[{{{{a}}}}, {1}]}
        expect_evaluated: {f[{{{{a}}}}, {1}]}
    ...
# Map down to level 2:
ok  MapIndexed[f, {{{{{a}}}}}, 2]    ==>     {f[{f[{{{a}}}, {1, 1}]}, {1}]}
    ---
    data:
        got: {f[{f[{{{a}}}, {1, 1}]}, {1}]}
        expect: {f[{f[{{{a}}}, {1, 1}]}, {1}]}
        expect_evaluated: {f[{f[{{{a}}}, {1, 1}]}, {1}]}
    ...
# Map at level 2:
ok  MapIndexed[f, {{{{{a}}}}}, {2}]    ==>     {{f[{{{a}}}, {1, 1}]}}
    ---
    data:
        got: {{f[{{{a}}}, {1, 1}]}}
        expect: {{f[{{{a}}}, {1, 1}]}}
        expect_evaluated: {{f[{{{a}}}, {1, 1}]}}
    ...
# Map down to level 3:
ok  MapIndexed[f, {{{{{a}}}}}, 3]    ==>     {f[{f[{f[{{a}}, {1, 1, 1}]}, {1, 1}]}, {1}]}
    ---
    data:
        got: {f[{f[{f[{{a}}, {1, 1, 1}]}, {1, 1}]}, {1}]}
        expect: {f[{f[{f[{{a}}, {1, 1, 1}]}, {1, 1}]}, {1}]}
        expect_evaluated: {f[{f[{f[{{a}}, {1, 1, 1}]}, {1, 1}]}, {1}]}
    ...
# Map onto all elements of an expression:
ok  MapIndexed[f, {{a, b}, {c, d, {e}}}, Infinity]    ==>     {f[{f[a, {1, 1}], f[b, {1, 2}]}, {1}], f[{f[c, {2, 1}], f[d, {2, 2}], f[{f[e, {2, 3, 1}]}, {2, 3}]}, {2}]}
    ---
    data:
        got: {f[{f[a, {1, 1}], f[b, {1, 2}]}, {1}], f[{f[c, {2, 1}], f[d, {2, 2}], f[{f[e, {2, 3, 1}]}, {2, 3}]}, {2}]}
        expect: {f[{f[a, {1, 1}], f[b, {1, 2}]}, {1}], f[{f[c, {2, 1}], f[d, {2, 2}], f[{f[e, {2, 3, 1}]}, {2, 3}]}, {2}]}
        expect_evaluated: {f[{f[a, {1, 1}], f[b, {1, 2}]}, {1}], f[{f[c, {2, 1}], f[d, {2, 2}], f[{f[e, {2, 3, 1}]}, {2, 3}]}, {2}]}
    ...
# Map only onto the "leaves" of the expression:
ok  MapIndexed[f, {{a, b}, {c, d, {e}}}, {-1}]    ==>     {{f[a, {1, 1}], f[b, {1, 2}]}, {f[c, {2, 1}], f[d, {2, 2}], {f[e, {2, 3, 1}]}}}
    ---
    data:
        got: {{f[a, {1, 1}], f[b, {1, 2}]}, {f[c, {2, 1}], f[d, {2, 2}], {f[e, {2, 3, 1}]}}}
        expect: {{f[a, {1, 1}], f[b, {1, 2}]}, {f[c, {2, 1}], f[d, {2, 2}], {f[e, {2, 3, 1}]}}}
        expect_evaluated: {{f[a, {1, 1}], f[b, {1, 2}]}, {f[c, {2, 1}], f[d, {2, 2}], {f[e, {2, 3, 1}]}}}
    ...
# Negative levels:
ok  MapIndexed[f, {{{{a}}}}, -1]    ==>     {f[{f[{f[{f[a, {1, 1, 1, 1}]}, {1, 1, 1}]}, {1, 1}]}, {1}]}
    ---
    data:
        got: {f[{f[{f[{f[a, {1, 1, 1, 1}]}, {1, 1, 1}]}, {1, 1}]}, {1}]}
        expect: {f[{f[{f[{f[a, {1, 1, 1, 1}]}, {1, 1, 1}]}, {1, 1}]}, {1}]}
        expect_evaluated: {f[{f[{f[{f[a, {1, 1, 1, 1}]}, {1, 1, 1}]}, {1, 1}]}, {1}]}
    ...
ok  MapIndexed[f, {{{{a}}}}, -2]    ==>     {f[{f[{f[{a}, {1, 1, 1}]}, {1, 1}]}, {1}]}
    ---
    data:
        got: {f[{f[{f[{a}, {1, 1, 1}]}, {1, 1}]}, {1}]}
        expect: {f[{f[{f[{a}, {1, 1, 1}]}, {1, 1}]}, {1}]}
        expect_evaluated: {f[{f[{f[{a}, {1, 1, 1}]}, {1, 1}]}, {1}]}
    ...
ok  MapIndexed[f, {{{{a}}}}, -3]    ==>     {f[{f[{{a}}, {1, 1}]}, {1}]}
    ---
    data:
        got: {f[{f[{{a}}, {1, 1}]}, {1}]}
        expect: {f[{f[{{a}}, {1, 1}]}, {1}]}
        expect_evaluated: {f[{f[{{a}}, {1, 1}]}, {1}]}
    ...
# Different heads at each level:
ok  MapIndexed[f, h0[h1[h2[h3[h4[a]]]]], {2, -3}]    ==>     h0[h1[f[h2[f[h3[h4[a]], {1, 1, 1}]], {1, 1}]]]
    ---
    data:
        got: h0[h1[f[h2[f[h3[h4[a]], {1, 1, 1}]], {1, 1}]]]
        expect: h0[h1[f[h2[f[h3[h4[a]], {1, 1, 1}]], {1, 1}]]]
        expect_evaluated: h0[h1[f[h2[f[h3[h4[a]], {1, 1, 1}]], {1, 1}]]]
    ...
# Map on levels 0 through 1; the head has index {}:
ok  MapIndexed[f, {a, b}, {0, 1}]    ==>     f[{f[a, {1}], f[b, {2}]}, {}]
    ---
    data:
        got: f[{f[a, {1}], f[b, {2}]}, {}]
        expect: f[{f[a, {1}], f[b, {2}]}, {}]
        expect_evaluated: f[{f[a, {1}], f[b, {2}]}, {}]
    ...
# RefLink[MapIndexed,paclet:ref/MapIndexed] can be used on expressions with any head:
ok  MapIndexed[f, a + b + c + d]    ==>     f[a, {1}] + f[b, {2}] + f[c, {3}] + f[d, {4}]
    ---
    data:
        got: f[a, {1}] + f[b, {2}] + f[c, {3}] + f[d, {4}]
        expect: f[a, {1}] + f[b, {2}] + f[c, {3}] + f[d, {4}]
        expect_evaluated: f[a, {1}] + f[b, {2}] + f[c, {3}] + f[d, {4}]
    ...
# The function can be mapped onto the heads as well:
ok  MapIndexed[f, {a, b, c}, Heads -> True]    ==>     f[List, {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
    ---
    data:
        got: f[List, {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
        expect: f[List, {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
        expect_evaluated: f[List, {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
    ...
# RefLink[MapIndexed,paclet:ref/MapIndexed] works on sparse arrays:
ok  MapIndexed[f, SparseArray[3 -> a, 5]]    ==>     {f[0, {1}], f[0, {2}], f[a, {3}], f[0, {4}], f[0, {5}]}
    ---
    data:
        got: {f[0, {1}], f[0, {2}], f[a, {3}], f[0, {4}], f[0, {5}]}
        expect: {f[0, {1}], f[0, {2}], f[a, {3}], f[0, {4}], f[0, {5}]}
        expect_evaluated: {f[0, {1}], f[0, {2}], f[a, {3}], f[0, {4}], f[0, {5}]}
    ...
# By default, the function is not mapped onto the heads:
ok  MapIndexed[f, {a, b, c}]    ==>     {f[a, {1}], f[b, {2}], f[c, {3}]}
    ---
    data:
        got: {f[a, {1}], f[b, {2}], f[c, {3}]}
        expect: {f[a, {1}], f[b, {2}], f[c, {3}]}
        expect_evaluated: {f[a, {1}], f[b, {2}], f[c, {3}]}
    ...
ok  MapIndexed[f, {a, b, c}, Heads -> True]    ==>     f[List, {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
    ---
    data:
        got: f[List, {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
        expect: f[List, {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
        expect_evaluated: f[List, {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
    ...
# Map onto the heads at all levels:
ok  MapIndexed[f, p[x][a, b, c], Infinity, Heads -> True]    ==>     f[f[p, {0, 0}][f[x, {0, 1}]], {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
    ---
    data:
        got: f[f[p, {0, 0}][f[x, {0, 1}]], {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
        expect: f[f[p, {0, 0}][f[x, {0, 1}]], {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
        expect_evaluated: f[f[p, {0, 0}][f[x, {0, 1}]], {0}][f[a, {1}], f[b, {2}], f[c, {3}]]
    ...
# Label parts by position:
ok  MapIndexed[Labeled, {x^2, x + y, y^2, y^3}]    ==>     {x^2*{1}, x + y*{2}, y^2*{3}, y^3*{4}} # skip
ok  HoldComplete[MapIndexed[Framed[Labeled[#1, #2]] & , {x^2, x + y, y^2, y^3}, Infinity]]    ==>     $Failed # skip
# Use tooltips to show part numbers of subexpressions:
ok  MapIndexed[Tooltip, Integrate[1/(x^4 - 1), x], Infinity]    ==>     (-(1/2))*ArcTan[x] + (1/4)*Log[-1 + x] + (-(1/4))*Log[1 + x] # skip
# Convert a list to a polynomial:
ok  Total[MapIndexed[#1*x^First[#2] & , {a, b, c, d, e}]]    ==>     a*x + b*x^2 + c*x^3 + d*x^4 + e*x^5
    ---
    data:
        got:          2      3      4      5
#! a x + b x  + c x  + d x  + e x
        expect: a*x + b*x^2 + c*x^3 + d*x^4 + e*x^5
        expect_evaluated:          2      3      4      5
#! a x + b x  + c x  + d x  + e x
    ...
# Rotate lists based on position:
ok  MapIndexed[RotateLeft, Table[{a, b, c}, {6}]]    ==>     {{b, c, a}, {c, a, b}, {a, b, c}, {b, c, a}, {c, a, b}, {a, b, c}}
    ---
    data:
        got: {{b, c, a}, {c, a, b}, {a, b, c}, {b, c, a}, {c, a, b}, {a, b, c}}
        expect: {{b, c, a}, {c, a, b}, {a, b, c}, {b, c, a}, {c, a, b}, {a, b, c}}
        expect_evaluated: {{b, c, a}, {c, a, b}, {a, b, c}, {b, c, a}, {c, a, b}, {a, b, c}}
    ...
ok  HoldComplete[MatrixForm[MapIndexed[RotateLeft, Table[{{a, b}, {c, d}}, {3}, {3}], {2}]]]    ==>     $Failed # skip
# Obtain a list of all parts in an expression:
ok  First[Last[Reap[MapIndexed[Sow[#2] & , {{a, b}, {c}, {{d}}}, {1, Infinity}]]]]    ==>     {{1, 1}, {1, 2}, {1}, {2, 1}, {2}, {3, 1, 1}, {3, 1}, {3}}
    ---
    data:
        got: {{1, 1}, {1, 2}, {1}, {2, 1}, {2}, {3, 1, 1}, {3, 1}, {3}}
        expect: {{1, 1}, {1, 2}, {1}, {2, 1}, {2}, {3, 1, 1}, {3, 1}, {3}}
        expect_evaluated: {{1, 1}, {1, 2}, {1}, {2, 1}, {2}, {3, 1, 1}, {3, 1}, {3}}
    ...
ok  Position[{{a, b}, {c}, {{d}}}, _, Infinity, Heads -> False]    ==>     {{1, 1}, {1, 2}, {1}, {2, 1}, {2}, {3, 1, 1}, {3, 1}, {3}}
    ---
    data:
        got: {{1, 1}, {1, 2}, {1}, {2, 1}, {2}, {3, 1, 1}, {3, 1}, {3}}
        expect: {{1, 1}, {1, 2}, {1}, {2, 1}, {2}, {3, 1, 1}, {3, 1}, {3}}
        expect_evaluated: {{1, 1}, {1, 2}, {1}, {2, 1}, {2}, {3, 1, 1}, {3, 1}, {3}}
    ...
# Using only the first argument is equivalent to using RefLink[Map,paclet:ref/Map]:
ok  MapIndexed[f[#1] & , {a, b, c}]    ==>     {f[a], f[b], f[c]}
    ---
    data:
        got: {f[a], f[b], f[c]}
        expect: {f[a], f[b], f[c]}
        expect_evaluated: {f[a], f[b], f[c]}
    ...
ok  f /@ {a, b, c}    ==>     {f[a], f[b], f[c]}
    ---
    data:
        got: {f[a], f[b], f[c]}
        expect: {f[a], f[b], f[c]}
        expect_evaluated: {f[a], f[b], f[c]}
    ...
