#! DOCKER > wolfram -script output/Tests/Cot_Tests.m
#! TextForm[ColonForm[MessageName[N, meprec], StringForm[Internal precision limit $MaxExtraPrecision = `1` reached while evaluating `2`., Short[HoldForm[50.], 3], Short[HoldForm[Cot[10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: Cot_Tests
# The argument is given in radians:
ok  Cot[Pi/3]    ==>     1/Sqrt[3]
    ---
    data:
        got: 1/Sqrt[3]
        expect: 1/Sqrt[3]
        expect_evaluated: 1/Sqrt[3]
    ...
# Use RefLink[Degree,paclet:ref/Degree] to specify an argument in degrees:
ok  Cot[60*Degree]    ==>     1/Sqrt[3]
    ---
    data:
        got: 1/Sqrt[3]
        expect: 1/Sqrt[3]
        expect_evaluated: 1/Sqrt[3]
    ...
ok  HoldComplete[Plot[Cot[x], {x, -Pi, Pi}]]    ==>     $Failed # skip
ok  Series[Cot[x], {x, 0, 10}]    ==>     1/x - x/3 - x^3/45 - (2*x^5)/945 - x^7/4725 - (2*x^9)/93555 + O[x]^11
    ---
    data:
        got: SeriesData[x, 0, {1, 0, -1/3, 0, -1/45, 0, -2/945, 0, -1/4725, 0, -2/93555}, -1, 11, 1]
        expect: 1/x - x/3 - x^3/45 - (2*x^5)/945 - x^7/4725 - (2*x^9)/93555 + O[x]^11
        expect_evaluated: SeriesData[x, 0, {1, 0, -1/3, 0, -1/45, 0, -2/945, 0, -1/4725, 0, -2/93555}, -1, 11, 1]
    ...
# Evaluate numerically:
ok  Cot[1.2]    ==>     0.38878 # skip
# Evaluate to high precision:
ok  N[Cot[12/10], 50]    ==>     0.38877956936820491163419150497190340959498492594098`49.589703434382365
    ---
    data:
        got: 0.3887795693682049116341915049719034095949849259409758245726565785777`50.
        expect: 0.38877956936820491163419150497190340959498492594098`49.589703434382365
        expect_evaluated: 0.38877956936820491163419150497190340959498492594098`49.589703434382365
    ...
# The precision of the output tracks the precision of the input:
ok  Cot[1.2`23.07918124604763]    ==>     0.3887795693682049116342`21.589703434382365
    ---
    data:
        got: 0.3887795693682049116341915049719034123`22.52857168497864
        expect: 0.3887795693682049116342`21.589703434382365
        expect_evaluated: 0.3887795693682049116342`21.589703434382365
    ...
# The precision of the output can be much smaller than the precision of the input:
ok  Cot[1.5707963267948966192213216916397514421`37.196119877030156]    ==>     1./10^20
    ---
    data:
        got: 9.999999999999999998584699688`17.*^-21
        expect: 1./10^20
        expect_evaluated: 1.*^-20
    ...
# RefLink[Cot,paclet:ref/Cot] threads element-wise over lists and matrices:
ok  Cot[{1.2, 1.5, 1.8}]    ==>     {0.38878, 0.0709148, -0.233304} # skip
ok  Cot[(Pi/2)*u*v*(Pi/3)]    ==>     {{0, Cot[u]}, {Cot[v], 1/Sqrt[3]}} # skip
# Evaluate for complex arguments:
ok  Cot[2.5 + I]    ==>     -0.275669 - 1.04264*I # skip
# Simple exact values are generated automatically:
ok  Cot[Pi/6]    ==>     Sqrt[3]
    ---
    data:
        got: Sqrt[3]
        expect: Sqrt[3]
        expect_evaluated: Sqrt[3]
    ...
# More complicated cases require explicit use of RefLink[FunctionExpand,paclet:ref/FunctionExpand]:
ok  Cot[Pi/8]    ==>     Cot[Pi/8]
    ---
    data:
        got: Cot[Pi/8]
        expect: Cot[Pi/8]
        expect_evaluated: Cot[Pi/8]
    ...
ok  FunctionExpand[%]    ==>     Sqrt[(2 + Sqrt[2])/(2 - Sqrt[2])] # skip
# Convert multiple-angle expressions:
ok  TrigExpand[Cot[4*x]]    ==>     Cos[x]^4/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3) - (6*Cos[x]^2*Sin[x]^2)/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3) + Sin[x]^4/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3)
    ---
    data:
        got: Cos[x]^4/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3) - (6*Cos[x]^2*Sin[x]^2)/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3) + Sin[x]^4/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3)
        expect: Cos[x]^4/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3) - (6*Cos[x]^2*Sin[x]^2)/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3) + Sin[x]^4/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3)
        expect_evaluated: Cos[x]^4/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3) - (6*Cos[x]^2*Sin[x]^2)/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3) + Sin[x]^4/(4*Cos[x]^3*Sin[x] - 4*Cos[x]*Sin[x]^3)
    ...
ok  TrigReduce[%]    ==>     Cot[4*x] # skip
# Convert sums of trigonometric functions to products:
ok  TrigFactor[Cot[x] + Cot[y]]    ==>     Csc[x]*Csc[y]*Sin[x + y]
    ---
    data:
        got: Csc[x]*Csc[y]*Sin[x + y]
        expect: Csc[x]*Csc[y]*Sin[x + y]
        expect_evaluated: Csc[x]*Csc[y]*Sin[x + y]
    ...
# Expand assuming real variables:
ok  ComplexExpand[Cot[x + I*y]]    ==>     -(Sin[2*x]/(Cos[2*x] - Cosh[2*y])) + (I*Sinh[2*y])/(Cos[2*x] - Cosh[2*y])
    ---
    data:
        got: -(Sin[2*x]/(Cos[2*x] - Cosh[2*y])) + (I*Sinh[2*y])/(Cos[2*x] - Cosh[2*y])
        expect: -(Sin[2*x]/(Cos[2*x] - Cosh[2*y])) + (I*Sinh[2*y])/(Cos[2*x] - Cosh[2*y])
        expect_evaluated: -(Sin[2*x]/(Cos[2*x] - Cosh[2*y])) + (I*Sinh[2*y])/(Cos[2*x] - Cosh[2*y])
    ...
# Convert to complex exponentials:
ok  TrigToExp[Cot[z]]    ==>     -((I*(E^((-I)*z) + E^(I*z)))/(E^((-I)*z) - E^(I*z)))
    ---
    data:
        got: ((-I)*(E^((-I)*z) + E^(I*z)))/(E^((-I)*z) - E^(I*z))
        expect: -((I*(E^((-I)*z) + E^(I*z)))/(E^((-I)*z) - E^(I*z)))
        expect_evaluated: ((-I)*(E^((-I)*z) + E^(I*z)))/(E^((-I)*z) - E^(I*z))
    ...
# RefLink[TraditionalForm,paclet:ref/TraditionalForm] formatting:
ok  cot*z    ==>     cot*z # skip
# RefLink[Cot,paclet:ref/Cot] can deal with real-valued intervals:
ok  Cot[Interval[{Pi/6, Pi/3}]]    ==>     Interval[{1/Sqrt[3], Sqrt[3]}]
    ---
    data:
        got: Interval[{1/Sqrt[3], Sqrt[3]}]
        expect: Interval[{1/Sqrt[3], Sqrt[3]}]
        expect_evaluated: Interval[{1/Sqrt[3], Sqrt[3]}]
    ...
# Infinite arguments give symbolic results:
ok  Cot[Infinity]    ==>     Interval[{-Infinity, Infinity}]
    ---
    data:
        got: Interval[{-Infinity, Infinity}]
        expect: Interval[{-Infinity, Infinity}]
        expect_evaluated: Interval[{-Infinity, Infinity}]
    ...
ok  Cot[ComplexInfinity]    ==>     Indeterminate
    ---
    data:
        got: Indeterminate
        expect: Indeterminate
        expect_evaluated: Indeterminate
    ...
# RefLink[Cot,paclet:ref/Cot] can be applied to power series:
ok  Cot[Pi/2 + x + x^2/2 + x^3/3 + O[x]^4]    ==>     -x - x^2/2 - (2*x^3)/3 + O[x]^4
    ---
    data:
        got: SeriesData[x, 0, {-1, -1/2, -2/3}, 1, 4, 1]
        expect: -x - x^2/2 - (2*x^3)/3 + O[x]^4
        expect_evaluated: SeriesData[x, 0, {-1, -1/2, -2/3}, 1, 4, 1]
    ...
# RefLink[Cot,paclet:ref/Cot] threads element-wise over sparse arrays as well as lists: 
ok  HoldComplete[SparseArray[{{1, 1} -> Pi/2, {1, 3} -> Pi/3, {3, 3} -> Pi/12, {4, 2} -> Pi/4, {_, _} -> Pi/2}]]    ==>     $Failed # skip
ok  HoldComplete[Cot[%]]    ==>     $Failed # skip
ok  MatrixForm[%]    ==>     0*0*(1/Sqrt[3])*0*0*0*0*0*2 + Sqrt[3]*0*1*0 # skip
# Generate a plot with poles removed:
ok  HoldComplete[Plot[Cot[x], {x, -(Pi/2), (3/2)*Pi}, Exclusions -> Sin[x] == 0]]    ==>     $Failed # skip
# Generate a plot over the complex argument plane:
ok  HoldComplete[Plot3D[Re[Cot[x + I*y]], {x, -Pi, Pi}, {y, 0, 3}]]    ==>     $Failed # skip
# The cotangent function conformally maps a parabola into the unit disk:
ok  HoldComplete[With[{parabola = Table[1 - x^2/4 + I*x, {x, 0, 20, 1/10}], pnts = Point[Thread[Through[{Re, Im}[#1]]]] & , opts = {Axes -> True, PlotRange -> All}}, {Graphics[pnts[parabola], opts], Graphics[pnts[Cot[(Pi/4.)*Sqrt[parabola]]^2], opts]}]]    ==>     $Failed # skip
# Basic parity and periodicity properties of the cotangent function are automatically applied:
ok  Cot[x + Pi]    ==>     Cot[x]
    ---
    data:
        got: Cot[x]
        expect: Cot[x]
        expect_evaluated: Cot[x]
    ...
ok  Cot[-x]    ==>     -Cot[x]
    ---
    data:
        got: -Cot[x]
        expect: -Cot[x]
        expect_evaluated: -Cot[x]
    ...
ok  Cot[I*x]    ==>     (-I)*Coth[x]
    ---
    data:
        got: (-I)*Coth[x]
        expect: (-I)*Coth[x]
        expect_evaluated: (-I)*Coth[x]
    ...
ok  1/Cot[x]    ==>     Tan[x]
    ---
    data:
        got: Tan[x]
        expect: Tan[x]
        expect_evaluated: Tan[x]
    ...
# Use RefLink[TrigFactorList,paclet:ref/TrigFactorList] to factor RefLink[Cot,paclet:ref/Cot] into RefLink[Sin,paclet:ref/Sin] and RefLink[Cos,paclet:ref/Cos]:
ok  Cos[x]/Sin[x]    ==>     Cot[x]
    ---
    data:
        got: Cot[x]
        expect: Cot[x]
        expect_evaluated: Cot[x]
    ...
ok  TrigFactorList[Cot[x]]    ==>     {{1, 1}, {Sin[x], -1}, {Cos[x], 1}}
    ---
    data:
        got: {{1, 1}, {Sin[x], -1}, {Cos[x], 1}}
        expect: {{1, 1}, {Sin[x], -1}, {Cos[x], 1}}
        expect_evaluated: {{1, 1}, {Sin[x], -1}, {Cos[x], 1}}
    ...
# Complicated expressions containing trigonometric functions do not simplify automatically:
ok  Cot[z] + Tan[z]    ==>     Cot[z] + Tan[z]
    ---
    data:
        got: Cot[z] + Tan[z]
        expect: Cot[z] + Tan[z]
        expect_evaluated: Cot[z] + Tan[z]
    ...
ok  Simplify[%]    ==>     Csc[z]*Sec[z] # skip
# Simplify with assumptions on parameters:
ok  Cot[-x + k*Pi]    ==>     Cot[k*Pi - x]
    ---
    data:
        got: Cot[k*Pi - x]
        expect: Cot[k*Pi - x]
        expect_evaluated: Cot[k*Pi - x]
    ...
ok  Simplify[%, Element[k, Integers]]    ==>     -Cot[x] # skip
# Compose with inverse functions:
ok  {Cot[ArcCot[z]], Cot[2*ArcCot[z]], Cot[3*ArcCot[z]]}    ==>     {z, Cot[2*ArcCot[z]], Cot[3*ArcCot[z]]}
    ---
    data:
        got: {z, Cot[2*ArcCot[z]], Cot[3*ArcCot[z]]}
        expect: {z, Cot[2*ArcCot[z]], Cot[3*ArcCot[z]]}
        expect_evaluated: {z, Cot[2*ArcCot[z]], Cot[3*ArcCot[z]]}
    ...
ok  Together[FunctionExpand[%]]    ==>     {z, (-1 + z^2)/(2*z), (z*(-3 + z^2))/(-1 + 3*z^2)} # skip
# Solve a trigonometric equation:
ok  Reduce[Cot[z]^2 - 2*Cot[z + Pi/4] == 4, z]    ==>     Element[C[1], Integers] && (z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 1]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 2]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 3]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 4]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 5]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 6]] + 2*Pi*C[1])
    ---
    data:
        got: Element[C[1], Integers] && (z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 1, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 2, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 3, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 4, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 5, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 6, 0]] + 2*Pi*C[1])
        expect: Element[C[1], Integers] && (z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 1]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 2]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 3]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 4]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 5]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 6]] + 2*Pi*C[1])
        expect_evaluated: Element[C[1], Integers] && (z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 1, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 2, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 3, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 4, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 5, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-1 - 2*#1 + 27*#1^2 + 20*#1^3 - 27*#1^4 - 2*#1^5 + #1^6 & , 6, 0]] + 2*Pi*C[1])
    ...
# Solve for zeros and poles: 
ok  Reduce[Cot[\[Alpha]*x + \[Beta]] == 0, x]    ==>     Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi/2 + Pi*C[1]) || (\[Alpha] != 0 && x == (Pi/2 - \[Beta] + Pi*C[1])/\[Alpha]))
    ---
    data:
        got: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi/2 + Pi*C[1]) || (\[Alpha] != 0 && x == (Pi/2 - \[Beta] + Pi*C[1])/\[Alpha]))
        expect: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi/2 + Pi*C[1]) || (\[Alpha] != 0 && x == (Pi/2 - \[Beta] + Pi*C[1])/\[Alpha]))
        expect_evaluated: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi/2 + Pi*C[1]) || (\[Alpha] != 0 && x == (Pi/2 - \[Beta] + Pi*C[1])/\[Alpha]))
    ...
ok  Reduce[1/Cot[\[Alpha]*x + \[Beta]] == 0, x]    ==>     Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi*C[1]) || (\[Alpha] != 0 && x == (-\[Beta] + Pi*C[1])/\[Alpha]))
    ---
    data:
        got: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi*C[1]) || (\[Alpha] != 0 && x == (-\[Beta] + Pi*C[1])/\[Alpha]))
        expect: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi*C[1]) || (\[Alpha] != 0 && x == (-\[Beta] + Pi*C[1])/\[Alpha]))
        expect_evaluated: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi*C[1]) || (\[Alpha] != 0 && x == (-\[Beta] + Pi*C[1])/\[Alpha]))
    ...
# Numerically find a root of a transcendental equation:
ok  FindRoot[Cot[z]^2 + 3*Cot[z + Pi/6] + z == 4, {z, 2}]    ==>     {z -> 0.615263} # skip
# Integrals:
ok  Integrate[Cot[z]^a, z]    ==>     -((Cot[z]^(1 + a)*Hypergeometric2F1[(1 + a)/2, 1, 1 + (1 + a)/2, -Cot[z]^2])/(1 + a))
    ---
    data:
        got: -((Cot[z]^(1 + a)*Hypergeometric2F1[1, (1 + a)/2, 1 + (1 + a)/2, -Cot[z]^2])/(1 + a))
        expect: -((Cot[z]^(1 + a)*Hypergeometric2F1[(1 + a)/2, 1, 1 + (1 + a)/2, -Cot[z]^2])/(1 + a))
        expect_evaluated: -((Cot[z]^(1 + a)*Hypergeometric2F1[1, (1 + a)/2, 1 + (1 + a)/2, -Cot[z]^2])/(1 + a))
    ...
# RefLink[Cot,paclet:ref/Cot] appears in special cases of many mathematical functions: 
ok  {BesselJ[-(1/2), z]/BesselJ[1/2, z], MathieuC[1, 0, z]/MathieuS[1, 0, z], JacobiCS[z, 0], JacobiSC[Pi/2 - z, 0], JacobiNS[I*z, 1], JacobiSN[(Pi*I)/2 - I*z, 1], HypergeometricPFQ[{}, {1/2}, -z]/HypergeometricPFQ[{}, {3/2}, -z]}    ==>     {Cot[z], Cot[z], Cot[z], Cot[z], (-I)*Cot[z], I*Cot[z], 2*Sqrt[z]*Cot[2*Sqrt[z]]}
    ---
    data:
        got: {Cot[z], Cot[z], Cot[z], Cot[z], (-I)*Cot[z], I*Cot[z], 2*Sqrt[z]*Cot[2*Sqrt[z]]}
        expect: {Cot[z], Cot[z], Cot[z], Cot[z], (-I)*Cot[z], I*Cot[z], 2*Sqrt[z]*Cot[2*Sqrt[z]]}
        expect_evaluated: {Cot[z], Cot[z], Cot[z], Cot[z], (-I)*Cot[z], I*Cot[z], 2*Sqrt[z]*Cot[2*Sqrt[z]]}
    ...
# Calculate residue symbolically and numerically: 
ok  Table[Residue[Cot[z]^k, {z, 0}], {k, 10}]    ==>     {1, 0, -1, 0, 1, 0, -1, 0, 1, 0}
    ---
    data:
        got: {1, 0, -1, 0, 1, 0, -1, 0, 1, 0}
        expect: {1, 0, -1, 0, 1, 0, -1, 0, 1, 0}
        expect_evaluated: {1, 0, -1, 0, 1, 0, -1, 0, 1, 0}
    ...
ok  (1/(2*Pi*I))*NIntegrate[Cot[z], {z, -(1/4), -(I/4), Plus[1/4], Plus[I/4], -(1/4)}]    ==>     1. + 0.*I # skip
# RefLink[Cot,paclet:ref/Cot] is a numeric function:
ok  Attributes[Cot]    ==>     {Listable, NumericFunction, Protected}
    ---
    data:
        got: {Listable, NumericFunction, Protected}
        expect: {Listable, NumericFunction, Protected}
        expect_evaluated: {Listable, NumericFunction, Protected}
    ...
ok  NumericQ[Cot[2 + E]]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
# Machine-precision input is insufficient to give a correct answer:
ok  Cot[10.^30]    ==>     -0.865133 # skip
# With exact input, the answer is correct:
ok  N[Cot[10^30], 20]    ==>     11.051547193404474785`19.043423082593154
    ---
    data:
        got: 11.05154719340447478515848536935`20.
        expect: 11.051547193404474785`19.043423082593154
        expect_evaluated: 11.051547193404474785`19.043423082593154
    ...
# A larger setting for RefLink[$MaxExtraPrecision,paclet:ref/$MaxExtraPrecision] is needed:
ok  N[Cot[10^100], 20]    ==>     0.*10^30
    ---
    data:
        got: 0``-30.
        expect: 0.*10^30
        expect_evaluated: 0.
    ...
ok  Block[{$MaxExtraPrecision = 200}, N[Cot[10^100], 20]]    ==>     2.4923238792798206949`19.39660447853459
    ---
    data:
        got: 2.49232387927982069486640543726040396169`20.
        expect: 2.4923238792798206949`19.39660447853459
        expect_evaluated: 2.4923238792798206949`19.39660447853459
    ...
ok  $Failed    ==>     HoldComplete[Csc[n*z]*Sin[n*(Pi/2 + z)]*Tan[z]] # skip
ok  Simplify[%, Element[n/2, Integers]]    ==>     I^n*Tan[z] # skip
ok  Simplify[%%, Element[(n - 1)/2, Integers]]    ==>     (-I)*I^n*Cot[n*z]*Tan[z] # skip
ok  Integrate[Cot[ArcTan[z]], z]    ==>     Log[z]
    ---
    data:
        got: Log[z]
        expect: Log[z]
        expect_evaluated: Log[z]
    ...
# Plot RefLink[Cot,paclet:ref/Cot] at integer points:
ok  HoldComplete[ArrayPlot[Table[ArcCot[Abs[Cot[x*y]]], {x, -20, 20}, {y, -20, 20}]]]    ==>     $Failed # skip
ok  FunctionExpand[Cot[Pi/2^12]]    ==>     Sqrt[(2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])/(2 - Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])]
    ---
    data:
        got: Sqrt[(2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])/(2 - Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])]
        expect: Sqrt[(2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])/(2 - Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])]
        expect_evaluated: Sqrt[(2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])/(2 - Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])]
    ...
# The continued fraction is highly regular:
ok  ContinuedFraction[Cot[1], 22]    ==>     {0, 1, 1, 1, 3, 1, 5, 1, 7, 1, 9, 1, 11, 1, 13, 1, 15, 1, 17, 1, 19, 1}
    ---
    data:
        got: {0, 1, 1, 1, 3, 1, 5, 1, 7, 1, 9, 1, 11, 1, 13, 1, 15, 1, 17, 1, 19, 1}
        expect: {0, 1, 1, 1, 3, 1, 5, 1, 7, 1, 9, 1, 11, 1, 13, 1, 15, 1, 17, 1, 19, 1}
        expect_evaluated: {0, 1, 1, 1, 3, 1, 5, 1, 7, 1, 9, 1, 11, 1, 13, 1, 15, 1, 17, 1, 19, 1}
    ...
ok  Element[Cot[1], Algebraics]    ==>     False
    ---
    data:
        got: False
        expect: False
        expect_evaluated: False
    ...
