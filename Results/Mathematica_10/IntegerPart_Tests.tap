#! DOCKER > wolfram -script output/Tests/IntegerPart_Tests.m
#! TextForm[ColonForm[MessageName[IntegerPart, meprec], StringForm[Internal precision limit $MaxExtraPrecision = `1` reached while evaluating `2`., Short[HoldForm[50.], 3], Short[HoldForm[IntegerPart[1 + 2*Pi + Pi^2 - (1 + Pi)^2]], 3]]]]
#! TextForm[ColonForm[MessageName[IntegerPart, meprec], StringForm[Internal precision limit $MaxExtraPrecision = `1` reached while evaluating `2`., Short[HoldForm[50.], 3], Short[HoldForm[IntegerPart[1 + 2*Pi + Pi^2 - (1 + Pi)^2]], 3]]]]
#! TextForm[ColonForm[MessageName[IntegerPart, meprec], StringForm[Internal precision limit $MaxExtraPrecision = `1` reached while evaluating `2`., Short[HoldForm[50.], 3], Short[HoldForm[IntegerPart[-2*E - E^2 + E^(-E^(2*E)) + (1 + E)^2]], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[IntegerPart, meprec]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: IntegerPart_Tests
# Find the integer part of a real number:
ok  IntegerPart[2.4]    ==>     2
    ---
    data:
        got: 2
        expect: 2
        expect_evaluated: 2
    ...
ok  HoldComplete[Plot[IntegerPart[x], {x, -3, 3}, Filling -> Axis]]    ==>     $Failed # skip
# Use exact numeric quantities:
ok  IntegerPart[Pi^100]    ==>     51878483143196131920862615246303013562686760680405
    ---
    data:
        got: 51878483143196131920862615246303013562686760680405
        expect: 51878483143196131920862615246303013562686760680405
        expect_evaluated: 51878483143196131920862615246303013562686760680405
    ...
# RefLink[IntegerPart,paclet:ref/IntegerPart] threads element-wise over lists:
ok  IntegerPart[{2.4, 2.5, 3.}]    ==>     {2, 2, 3}
    ---
    data:
        got: {2, 2, 3}
        expect: {2, 2, 3}
        expect_evaluated: {2, 2, 3}
    ...
# Manipulate RefLink[IntegerPart,paclet:ref/IntegerPart] symbolically:
ok  FullSimplify[IntegerPart[x] + IntegerPart[x + 1/2], 1/3 < x < 1/2]    ==>     0
    ---
    data:
        got: 0
        expect: 0
        expect_evaluated: 0
    ...
ok  Reduce[IntegerPart[x] + IntegerPart[2*x - 1] == 2 && 0 < x < 4, x, Reals]    ==>     Inequality[1, LessEqual, x, Less, 3/2]
    ---
    data:
        got: Inequality[1, LessEqual, x, Less, 3/2]
        expect: Inequality[1, LessEqual, x, Less, 3/2]
        expect_evaluated: Inequality[1, LessEqual, x, Less, 3/2]
    ...
# Evaluate an integral:
ok  Integrate[IntegerPart[x^3], {x, 0, 2}]    ==>     13 - 2^(1/3) - 2^(2/3) - 3^(1/3) - 5^(1/3) - 6^(1/3) - 7^(1/3)
    ---
    data:
        got: 13 - 2^(1/3) - 2^(2/3) - 3^(1/3) - 5^(1/3) - 6^(1/3) - 7^(1/3)
        expect: 13 - 2^(1/3) - 2^(2/3) - 3^(1/3) - 5^(1/3) - 6^(1/3) - 7^(1/3)
        expect_evaluated: 13 - 2^(1/3) - 2^(2/3) - 3^(1/3) - 5^(1/3) - 6^(1/3) - 7^(1/3)
    ...
# Use with negative arguments:
ok  IntegerPart[{-2.4, -2.5, -3.}]    ==>     {-2, -2, -3}
    ---
    data:
        got: {-2, -2, -3}
        expect: {-2, -2, -3}
        expect_evaluated: {-2, -2, -3}
    ...
# Use with complex-number arguments:
ok  IntegerPart[3 + (11/5)*I]    ==>     3 + 2*I
    ---
    data:
        got: 3 + 2*I
        expect: 3 + 2*I
        expect_evaluated: 3 + 2*I
    ...
# RefLink[IntegerPart,paclet:ref/IntegerPart] can deal with real-valued intervals:
ok  IntegerPart[Interval[{-1, 3/2}]]    ==>     Interval[{-1, 1}]
    ---
    data:
        got: Interval[{-1, 1}]
        expect: Interval[{-1, 1}]
        expect_evaluated: Interval[{-1, 1}]
    ...
# Infinite arguments give symbolic results:
ok  IntegerPart[Infinity]    ==>     Infinity
    ---
    data:
        got: Infinity
        expect: Infinity
        expect_evaluated: Infinity
    ...
# Series expansion:
ok  Series[IntegerPart[x^2], {x, 1, 2}, Assumptions -> Element[x, Reals]]    ==>     Piecewise[0]*x < 1*1*True # skip
ok  HoldComplete[Plot[IntegerPart[x + x^2], {x, -3, 3}]]    ==>     $Failed # skip
ok  HoldComplete[Plot3D[Abs[IntegerPart[x + I*y]], {x, -2.5, 2.5}, {y, -2.5, 2.5}, ExclusionsStyle -> {None, Directive[Thick, White]}]]    ==>     $Failed # skip
# Iso-curves become full-dimensional regions for piecewise constant functions:
ok  HoldComplete[RegionPlot[IntegerPart[x^2 + y^2] == 1, {x, -2, 2}, {y, -2, 2}]]    ==>     $Failed # skip
# Fibonacci numbers:
ok  Table[IntegerPart[GoldenRatio^k/Sqrt[5]] + Mod[k, 2], {k, 15}]    ==>     {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}
    ---
    data:
        got: {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}
        expect: {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}
        expect_evaluated: {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}
    ...
ok  Table[Fibonacci[k], {k, 15}]    ==>     {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}
    ---
    data:
        got: {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}
        expect: {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}
        expect_evaluated: {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}
    ...
ok  f[10]    ==>     130/27 # skip
# Find the 1000000\[Null]^th digit of the fraction 1/99^2 in base 10:
ok  With[{p = 1, q = 99^2, n = 10^6, base = 10}, IntegerPart[base*(Mod[p*PowerMod[base, n - 1, q], q]/q)]]    ==>     9
    ---
    data:
        got: 9
        expect: 9
        expect_evaluated: 9
    ...
# Compare with RefLink[RealDigits,paclet:ref/RealDigits] functionality:
ok  RealDigits[1/99^2, 10, 1, -10^6]    ==>     {{9}, -999999}
    ---
    data:
        got: {{9}, -999999}
        expect: {{9}, -999999}
        expect_evaluated: {{9}, -999999}
    ...
# Birthday of Leonard Euler:
ok  dow[1707, 4, 15]    ==>     Friday # skip
# Compare with RefLink[DateString,paclet:ref/DateString]:
ok  DateString[{1707, 4, 15}, "DayName"]    ==>     Friday # skip
ok  HoldComplete[ListLinePlot[({#1, f[#1, 100]} & ) /@ Union[Flatten[Table[i/j, {j, 50}, {i, 0, j}]]]]]    ==>     $Failed # skip
# Simplify expressions containing RefLink[IntegerPart,paclet:ref/IntegerPart]:
ok  Simplify[IntegerPart[x + 1] - IntegerPart[x], x >= 0]    ==>     1
    ---
    data:
        got: 1
        expect: 1
        expect_evaluated: 1
    ...
ok  FullSimplify[IntegerPart[z - IntegerPart[z]] - 2*IntegerPart[Round[z]]]    ==>     -2*Round[z]
    ---
    data:
        got: -2*Round[z]
        expect: -2*Round[z]
        expect_evaluated: -2*Round[z]
    ...
# Symbolically expand for complex arguments:
ok  ComplexExpand[IntegerPart[x + I*y]]    ==>     IntegerPart[x] + I*IntegerPart[y]
    ---
    data:
        got: IntegerPart[x] + I*IntegerPart[y]
        expect: IntegerPart[x] + I*IntegerPart[y]
        expect_evaluated: IntegerPart[x] + I*IntegerPart[y]
    ...
# RefLink[IntegerPart,paclet:ref/IntegerPart] is idempotent:
ok  IntegerPart[IntegerPart[x]]    ==>     IntegerPart[x]
    ---
    data:
        got: IntegerPart[x]
        expect: IntegerPart[x]
        expect_evaluated: IntegerPart[x]
    ...
# Use RefLink[PiecewiseExpand,paclet:ref/PiecewiseExpand] to canonicalize:
ok  PiecewiseExpand[IntegerPart[x^2 + Sqrt[x]], 0 < x < 2]    ==>     Inequality[Piecewise[1]*1, LessEqual, Sqrt[x] + x^2, Less, 2*2*2, LessEqual, Sqrt[x] + x^2, Less, 3*3*3, LessEqual, Sqrt[x] + x^2, Less, 4*4*4, LessEqual, Sqrt[x] + x^2, Less, 5*5*Sqrt[x] + x^2, GreaterEqual, 5*0*True] # skip
ok  PiecewiseExpand[IntegerPart[x + 1/3 + IntegerPart[1 - x/2]^3], Element[x, Reals] && -2 < x < 3]    ==>     Inequality[Piecewise[1]*(2/3), LessEqual, x, Less, 5/3] || Inequality[-(1/3), LessEqual, x, LessEqual, 0*2*(5/3), LessEqual, x, Less, (8/3)*3*x, GreaterEqual, (8/3)*0*True] # skip
# Reduce equations containing RefLink[IntegerPart,paclet:ref/IntegerPart]:
ok  Reduce[IntegerPart[x + 1/2] == 2*IntegerPart[x] && -1 < x < 1, x, Reals]    ==>     -1 < x < 1/2 # skip
# Numerical decision procedures with default settings cannot simplify this expression:
ok  IntegerPart[Pi^2 + 2*Pi + 1 - (Pi + 1)^2]    ==>     IntegerPart[1 + 2*Pi + Pi^2 - (1 + Pi)^2]
    ---
    data:
        got: IntegerPart[1 + 2*Pi + Pi^2 - (1 + Pi)^2]
        expect: IntegerPart[1 + 2*Pi + Pi^2 - (1 + Pi)^2]
        expect_evaluated: IntegerPart[1 + 2*Pi + Pi^2 - (1 + Pi)^2]
    ...
# Use RefLink[Simplify,paclet:ref/Simplify] to resolve:
ok  Simplify[%]    ==>     0 # skip
# Machine-precision numericalization of RefLink[IntegerPart,paclet:ref/IntegerPart] can give wrong results:
ok  IntegerPart[1 + (E + 1)^2 - E^2 - 2*E - 1 + Exp[-Exp[E]^2]]    ==>     IntegerPart[-2*E - E^2 + E^(-E^(2*E)) + (1 + E)^2]
    ---
    data:
        got: IntegerPart[-2*E - E^2 + E^(-E^(2*E)) + (1 + E)^2]
        expect: IntegerPart[-2*E - E^2 + E^(-E^(2*E)) + (1 + E)^2]
        expect_evaluated: IntegerPart[-2*E - E^2 + E^(-E^(2*E)) + (1 + E)^2]
    ...
ok  N[%]    ==>     0 # skip
# Use arbitrary-precision evaluation instead:
ok  N[%%, 20]    ==>     1 # skip
# Because the answer is exact, raising the internal precision does not remove the message:
ok  Block[{$MaxExtraPrecision = 10000}, N[%%%, 100]]    ==>     1 # skip
# Symbolic preprocessing of functions containing RefLink[IntegerPart,paclet:ref/IntegerPart] can be time consuming:
ok  Timing[NIntegrate[IntegerPart[x + x^2], {x, 0, 5}]]    ==>     {0.547, 51.7354} # skip
# As a discontinuous function, RefLink[IntegerPart,paclet:ref/IntegerPart] can cause numerical algorithms to converge slowly:
ok  Timing[NIntegrate[IntegerPart[x + x^2], {x, 0, 5}, Method -> {Automatic, "SymbolicProcessing" -> 0}]]    ==>     {0.047, 51.7293} # skip
# Generate the sequence up to 5:
ok  s[5]    ==>     {1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5} # skip
# Group the same numbers:
ok  Split[%]    ==>     {{1}, {2, 2}, {3, 3, 3}, {4, 4, 4, 4}, {5, 5, 5, 5, 5}} # skip
