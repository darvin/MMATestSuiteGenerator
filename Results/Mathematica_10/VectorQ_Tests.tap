#! DOCKER > wolfram -script output/Tests/VectorQ_Tests.m
# SYSTEM: Mathematica_10
# TEST: VectorQ_Tests
# Test whether an object is a vector:
ok  VectorQ[{a, b, c}]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
ok  VectorQ[SparseArray[{{1} -> a, {5} -> b}]]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
# These are not vectors: 
ok  VectorQ[{{1}, {2}}]    ==>     False
    ---
    data:
        got: False
        expect: False
        expect_evaluated: False
    ...
ok  VectorQ[vector]    ==>     False
    ---
    data:
        got: False
        expect: False
        expect_evaluated: False
    ...
# Use specific tests to generalize or specialize:
ok  VectorQ[{{1}, {2, 3}}, ListQ]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
ok  VectorQ[{a, 1.2}, NumericQ]    ==>     False
    ---
    data:
        got: False
        expect: False
        expect_evaluated: False
    ...
# Test for a vector of integers:
ok  VectorQ[Range[10], IntegerQ]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
# Test for a vector of machine-real numbers:
ok  VectorQ[Range[10], MachineNumberQ]    ==>     False
    ---
    data:
        got: False
        expect: False
        expect_evaluated: False
    ...
ok  VectorQ[N[Range[10]], MachineNumberQ]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
# Test for a vector of real-valued numeric quantities:
ok  VectorQ[{1, Pi, Sin[1], Sqrt[2]}, NumericQ[#1] && Im[#1] == 0 & ]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
# Faster test for explicit real-valued numbers:
ok  VectorQ[{1, N[Pi], Sin[1.], 3/4}, NumberQ[#1] &&  !MatchQ[#1, _Complex] & ]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
# Numerically find the minimum of the functions with n components:
ok  TableForm[Quiet[Table[FindMinimum[f[v], {v, RandomReal[1, n]}], {n, 1, 5}]]]    ==>     (5.55905*v)/10^17 -> ({1.}*2.86365*v)/10^15 -> ({1., 1.}*2.92116*v)/10^15 -> ({1., 1., 2.}*5.37532*v)/10^13 -> ({1., 1., 2., 4.}*5.36966*v)/10^13 -> {1., 1., 2., 4., 3.} # skip
ok  {VectorQ[v], ArrayQ[v, 1]}    ==>     {True, True} # skip
ok  {VectorQ[v, NumericQ], ArrayQ[v, 1, NumericQ]}    ==>     {True, True} # skip
ok  {VectorQ[v, Im[#1] == 0 & ], ArrayQ[v, 1, Im[#1] == 0 & ]}    ==>     {False, False}
    ---
    data:
        got: {False, False}
        expect: {False, False}
        expect_evaluated: {False, False}
    ...
# A function equivalent to RefLink[VectorQ,paclet:ref/VectorQ]: 
ok  testf = MatchQ[#1, {(args___)?( !ListQ[#1] & )}] &     ==>     MatchQ[#1, {(args___)?( !ListQ[#1] & )}] & 
    ---
    data:
        got: MatchQ[#1, {(args___)?( !ListQ[#1] & )}] & 
        expect: MatchQ[#1, {(args___)?( !ListQ[#1] & )}] & 
        expect_evaluated: MatchQ[#1, {(args___)?( !ListQ[#1] & )}] & 
    ...
ok  TableForm[Table[{v, VectorQ[v], testf[v]}, {v, vectors}], TableDepth -> 2]    ==>     {}*True*True*{1, 2}*True*True*{1, {2}}*False*False*{{1, 2}}*False*False # skip
