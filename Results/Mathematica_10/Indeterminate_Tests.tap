#! DOCKER > wolfram -script output/Tests/Indeterminate_Tests.m
#! TextForm[ColonForm[MessageName[Power, infy], StringForm[Infinite expression `1` encountered., Short[HoldForm[0^(-1)], 3]]]]
#! TextForm[ColonForm[MessageName[Infinity, indet], StringForm[Indeterminate expression `1` encountered., Short[HoldForm[0*ComplexInfinity], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
#! TextForm[ColonForm[MessageName[Power, indet], StringForm[Indeterminate expression `1` encountered., Short[HoldForm[0^0], 3]]]]
#! TextForm[ColonForm[MessageName[Power, infy], StringForm[Infinite expression `1` encountered., Short[HoldForm[0^(-1)], 3]]]]
#! TextForm[ColonForm[MessageName[Infinity, indet], StringForm[Indeterminate expression `1` encountered., Short[HoldForm[0*ComplexInfinity], 3]]]]
#! TextForm[ColonForm[MessageName[Power, infy], StringForm[Infinite expression `1` encountered., Short[HoldForm[0``-0.7398225701435863^(-1)], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[Power, infy]], 3]]]]
#! TextForm[ColonForm[MessageName[Infinity, indet], StringForm[Indeterminate expression `1` encountered., Short[HoldForm[0``-1.4796451402871726*ComplexInfinity], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[Infinity, indet]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: Indeterminate_Tests
# RefLink[Indeterminate,paclet:ref/Indeterminate] is returned when a value cannot be unambiguously defined:
ok  0/0    ==>     Indeterminate
    ---
    data:
        got: Indeterminate
        expect: Indeterminate
        expect_evaluated: Indeterminate
    ...
# Any numeric function of RefLink[Indeterminate,paclet:ref/Indeterminate] also gives RefLink[Indeterminate,paclet:ref/Indeterminate]:
ok  Sin[Indeterminate]    ==>     Indeterminate
    ---
    data:
        got: Indeterminate
        expect: Indeterminate
        expect_evaluated: Indeterminate
    ...
# RefLink[Indeterminate,paclet:ref/Indeterminate] "takes over" any function with attribute RefLink[NumericFunction,paclet:ref/NumericFunction]:
ok  SetAttributes[f, NumericFunction]; f[Indeterminate]    ==>     Indeterminate
    ---
    data:
        got: Indeterminate
        expect: Indeterminate
        expect_evaluated: Indeterminate
    ...
# Negative precision/accuracy can yield RefLink[Indeterminate,paclet:ref/Indeterminate]:
ok  SetAccuracy[2, -1]    ==>     0. # skip
ok  %/%    ==>     Indeterminate # skip
# Infinity in an unknown direction:
ok  DirectedInfinity[Indeterminate]    ==>     ComplexInfinity
    ---
    data:
        got: ComplexInfinity
        expect: ComplexInfinity
        expect_evaluated: ComplexInfinity
    ...
# Mathematical operations with RefLink[Indeterminate,paclet:ref/Indeterminate] produce RefLink[Indeterminate,paclet:ref/Indeterminate]:
ok  Interval[{0, 1}] + Indeterminate    ==>     Indeterminate
    ---
    data:
        got: Indeterminate
        expect: Indeterminate
        expect_evaluated: Indeterminate
    ...
ok  f[x] + Indeterminate    ==>     Indeterminate
    ---
    data:
        got: Indeterminate
        expect: Indeterminate
        expect_evaluated: Indeterminate
    ...
ok  Integrate[Indeterminate, x]    ==>     Indeterminate
    ---
    data:
        got: Indeterminate
        expect: Indeterminate
        expect_evaluated: Indeterminate
    ...
ok  D[Indeterminate, z]    ==>     Indeterminate
    ---
    data:
        got: Indeterminate
        expect: Indeterminate
        expect_evaluated: Indeterminate
    ...
# RefLink[Indeterminate,paclet:ref/Indeterminate] threads over lists:
ok  {1, 2, 3} + Indeterminate    ==>     {Indeterminate, Indeterminate, Indeterminate}
    ---
    data:
        got: {Indeterminate, Indeterminate, Indeterminate}
        expect: {Indeterminate, Indeterminate, Indeterminate}
        expect_evaluated: {Indeterminate, Indeterminate, Indeterminate}
    ...
ok  {1, 2, 3}*Indeterminate    ==>     {Indeterminate, Indeterminate, Indeterminate}
    ---
    data:
        got: {Indeterminate, Indeterminate, Indeterminate}
        expect: {Indeterminate, Indeterminate, Indeterminate}
        expect_evaluated: {Indeterminate, Indeterminate, Indeterminate}
    ...
# Digits beyond the limit of precision are RefLink[Indeterminate,paclet:ref/Indeterminate]:
ok  RealDigits[6.7, 10, 20]    ==>     {{6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Indeterminate, Indeterminate, Indeterminate, Indeterminate}, 1}
    ---
    data:
        got: {{6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Indeterminate, Indeterminate, Indeterminate, Indeterminate}, 1}
        expect: {{6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Indeterminate, Indeterminate, Indeterminate, Indeterminate}, 1}
        expect_evaluated: {{6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Indeterminate, Indeterminate, Indeterminate, Indeterminate}, 1}
    ...
# Create a number of lower precision:
ok  FromDigits[{{6, 7, 0, 0, 0, Indeterminate}, 1}]    ==>     6.7 # skip
# RefLink[Indeterminate,paclet:ref/Indeterminate] is not a number:
ok  NumberQ[Indeterminate]    ==>     False
    ---
    data:
        got: False
        expect: False
        expect_evaluated: False
    ...
# It is neither real nor complex:
ok  {Re[Indeterminate], Im[Indeterminate]}    ==>     {Indeterminate, Indeterminate}
    ---
    data:
        got: {Indeterminate, Indeterminate}
        expect: {Indeterminate, Indeterminate}
        expect_evaluated: {Indeterminate, Indeterminate}
    ...
# The value cannot be unambiguously defined: 
ok  t^t /. t -> 0    ==>     Indeterminate
    ---
    data:
        got: Indeterminate
        expect: Indeterminate
        expect_evaluated: Indeterminate
    ...
# Use RefLink[Limit,paclet:ref/Limit] to resolve the value: 
ok  Limit[t^t, t -> 0]    ==>     1
    ---
    data:
        got: 1
        expect: 1
        expect_evaluated: 1
    ...
# The answer is valid for generic parameter values:
ok  s = Sum[Exp[k*x], {k, n}]    ==>     (E^x*(-1 + E^(n*x)))/(-1 + E^x)
    ---
    data:
        got:  x        n x
#! E  (-1 + E   )
#! --------------
         x
#!    -1 + E
        expect: (E^x*(-1 + E^(n*x)))/(-1 + E^x)
        expect_evaluated:  x        n x
#! E  (-1 + E   )
#! --------------
         x
#!    -1 + E
    ...
# This particular parameter value gives an RefLink[Indeterminate,paclet:ref/Indeterminate] result:
ok  s /. x -> 0    ==>     Indeterminate
    ---
    data:
        got: Indeterminate
        expect: Indeterminate
        expect_evaluated: Indeterminate
    ...
# Use RefLink[Limit,paclet:ref/Limit] to resolve the value:
ok  Limit[s, x -> 0]    ==>     n
    ---
    data:
        got: n
        expect: n
        expect_evaluated: n
    ...
# Each iteration will result in lower precision:
ok  NestList[Function[x, (x^2 - 1)/(x - 1) - 1], 3.`10., 16]    ==>     {3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 0., 0., Indeterminate} # skip
# In this case an equivalent function does not lower precision: 
ok  Simplify[(x^2 - 1)/(x - 1) - 1]    ==>     x
    ---
    data:
        got: x
        expect: x
        expect_evaluated: x
    ...
ok  NestList[Function[x, x], 3.`10., 16]    ==>     {3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3.} # skip
# Sometimes a higher precision is needed: 
ok  NestList[Function[x, (x^2 - 1)/(x - 1) - 1], 3.`20., 16]    ==>     {3.`19.477121254719663, 3.`18.477121254719663, 3.`18.477121254719663, 3.`17.477121254719663, 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3.} # skip
# RefLink[Indeterminate,paclet:ref/Indeterminate] does not equal itself:
ok  Indeterminate == Indeterminate    ==>     Indeterminate == Indeterminate
    ---
    data:
        got: Indeterminate == Indeterminate
        expect: Indeterminate == Indeterminate
        expect_evaluated: Indeterminate == Indeterminate
    ...
# Use RefLink[SameQ,paclet:ref/SameQ] for testing against RefLink[Indeterminate,paclet:ref/Indeterminate]:
ok  Indeterminate === Indeterminate    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
# RefLink[Indeterminate,paclet:ref/Indeterminate] in functions with special evaluation semantics might go undetected:
ok  {True && Indeterminate, False && Indeterminate}    ==>     {Indeterminate, False}
    ---
    data:
        got: {Indeterminate, False}
        expect: {Indeterminate, False}
        expect_evaluated: {Indeterminate, False}
    ...
