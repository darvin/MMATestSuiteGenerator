#! DOCKER > wolfram -script output/Tests/Integer_Tests.m
# SYSTEM: Mathematica_10
# TEST: Integer_Tests
# Enter an integer:
ok  -12    ==>     -12
    ---
    data:
        got: -12
        expect: -12
        expect_evaluated: -12
    ...
# RefLink[Integer,paclet:ref/Integer] is the RefLink[Head,paclet:ref/Head] used for integers:
ok  Head[%]    ==>     Integer # skip
# Enter a very large integer:
ok  308301830183093810389108725092184914914891917449832749872947298472    ==>     308301830183093810389108725092184914914891917449832749872947298472
    ---
    data:
        got: 308301830183093810389108725092184914914891917449832749872947298472
        expect: 308301830183093810389108725092184914914891917449832749872947298472
        expect_evaluated: 308301830183093810389108725092184914914891917449832749872947298472
    ...
# Enter an integer in base 2:
ok  6455773865180671    ==>     6455773865180671
    ---
    data:
        got: 6455773865180671
        expect: 6455773865180671
        expect_evaluated: 6455773865180671
    ...
# Enter an integer in hexadecimal:
ok  4000    ==>     4000
    ---
    data:
        got: 4000
        expect: 4000
        expect_evaluated: 4000
    ...
# Format an integer using base 2: 
ok  BaseForm[6455773865180671, 2]    ==>     Subscript[10110111011110111110111111011111110111111110111111111, 2] # skip
# _Integer can be used to stand for an integer in a pattern:
ok  MatchQ[1234, _Integer]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
# A rule that replaces integers with their reciprocals:
ok  f[3, g[-4]] /. x_Integer -> 1/x    ==>     f[1/3, g[-(1/4)]]
    ---
    data:
        got: f[1/3, g[-1/4]]
        expect: f[1/3, g[-(1/4)]]
        expect_evaluated: f[1/3, g[-1/4]]
    ...
ok  divisibleby3 /@ {123, -40, 3.14}    ==>     {True, False, divisibleby3[3.14]} # skip
# Define a function that has a special case for integers:
ok  fd[x_, k_, d_Integer] = D[x^k, x]    ==>     k*x^(-1 + k)
    ---
    data:
        got: k*x^(-1 + k)
        expect: k*x^(-1 + k)
        expect_evaluated: k*x^(-1 + k)
    ...
# Make a surface plot of the fractional derivative of x^k at x=1 as a function of k and order:
ok  HoldComplete[Plot3D[fd[1, k, d], {k, 0, 2}, {d, 0, 5}, PlotRange -> All]]    ==>     $Failed # skip
# Integers are numbers:
ok  NumberQ[1234]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
# Integers are atomic objects with no subexpressions:
ok  AtomQ[1234]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
# Use RefLink[Integers,paclet:ref/Integers] to represent assumptions and indicate domain conditions: 
ok  Reduce[x^1000 - 2*x^777 + 1 == 0, x, Integers]    ==>     x == 1
    ---
    data:
        got: x == 1
        expect: x == 1
        expect_evaluated: x == 1
    ...
