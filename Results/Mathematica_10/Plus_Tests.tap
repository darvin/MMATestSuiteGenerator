#! DOCKER > wolfram -script output/Tests/Plus_Tests.m
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
#! TextForm[ColonForm[MessageName[Sum, argmu], StringForm[`1` called with 1 argument; `2` or more arguments are expected., Short[HoldForm[Sum], 3], Short[HoldForm[2], 3]]]]
#! TextForm[ColonForm[MessageName[Set, write], StringForm[Tag `1` in `2` is Protected., Short[HoldForm[Times], 3], Short[HoldForm[5*n*Sum[x*n]], 3]]]]
#! TextForm[ColonForm[MessageName[Sum, argmu], StringForm[`1` called with 1 argument; `2` or more arguments are expected., Short[HoldForm[Sum], 3], Short[HoldForm[2], 3]]]]
# SYSTEM: Mathematica_10
# TEST: Plus_Tests
ok  $Failed    ==>     HoldComplete[6] # skip
# RefLink[Plus,paclet:ref/Plus] threads element-wise over lists:
ok  {1, 2, 3} + x    ==>     {1 + x, 2 + x, 3 + x}
    ---
    data:
        got: {1 + x, 2 + x, 3 + x}
        expect: {1 + x, 2 + x, 3 + x}
        expect_evaluated: {1 + x, 2 + x, 3 + x}
    ...
ok  {10, 20, 30} + {1, 2, 3}    ==>     {11, 22, 33}
    ---
    data:
        got: {11, 22, 33}
        expect: {11, 22, 33}
        expect_evaluated: {11, 22, 33}
    ...
# Explicit RefLink[FullForm,paclet:ref/FullForm]:
ok  1 + 2 + 3    ==>     6
    ---
    data:
        got: 6
        expect: 6
        expect_evaluated: 6
    ...
# If any number is approximate, the whole result will be as follows:
ok  1. + 2 + 3/4    ==>     3.75
    ---
    data:
        got: 3.75
        expect: 3.75
        expect_evaluated: 3.75
    ...
# Complex numbers add their components:
ok  (2 + I) + (3 - 7*I)    ==>     5 - 6*I
    ---
    data:
        got: 5 - 6 I
        expect: 5 - 6*I
        expect_evaluated: 5 - 6 I
    ...
# RefLink[Plus,paclet:ref/Plus] threads element-wise over lists:
ok  {a, b} + {c, d}    ==>     {a + c, b + d}
    ---
    data:
        got: {a + c, b + d}
        expect: {a + c, b + d}
        expect_evaluated: {a + c, b + d}
    ...
ok  {a, b, c} + x    ==>     {a + x, b + x, c + x}
    ---
    data:
        got: {a + x, b + x, c + x}
        expect: {a + x, b + x, c + x}
        expect_evaluated: {a + x, b + x, c + x}
    ...
ok  {{a, b}, {c, d}} + x    ==>     {{a + x, b + x}, {c + x, d + x}}
    ---
    data:
        got: {{a + x, b + x}, {c + x, d + x}}
        expect: {{a + x, b + x}, {c + x, d + x}}
        expect_evaluated: {{a + x, b + x}, {c + x, d + x}}
    ...
# Matrices add element-wise:
ok  {{1, 2}, {3, 4}} + {{a, b}, {c, d}}    ==>     {{1 + a, 2 + b}, {3 + c, 4 + d}}
    ---
    data:
        got: {{1 + a, 2 + b}, {3 + c, 4 + d}}
        expect: {{1 + a, 2 + b}, {3 + c, 4 + d}}
        expect_evaluated: {{1 + a, 2 + b}, {3 + c, 4 + d}}
    ...
# RefLink[Plus,paclet:ref/Plus] sorts its arguments:
ok  b + c + a    ==>     a + b + c
    ---
    data:
        got: a + b + c
        expect: a + b + c
        expect_evaluated: a + b + c
    ...
ok  Sum[x^n, {n, 0, 5}]    ==>     1 + x + x^2 + x^3 + x^4 + x^5
    ---
    data:
        got:          2    3    4    5
#! 1 + x + x  + x  + x  + x
        expect: 1 + x + x^2 + x^3 + x^4 + x^5
        expect_evaluated:          2    3    4    5
#! 1 + x + x  + x  + x  + x
    ...
ok  Sum[x^i*y^j, {i, 3}, {j, 3}]    ==>     x*y + x^2*y + x^3*y + x*y^2 + x^2*y^2 + x^3*y^2 + x*y^3 + x^2*y^3 + x^3*y^3
    ---
    data:
        got:        2      3        2    2  2    3  2      3    2  3    3  3
#! x y + x  y + x  y + x y  + x  y  + x  y  + x y  + x  y  + x  y
        expect: x*y + x^2*y + x^3*y + x*y^2 + x^2*y^2 + x^3*y^2 + x*y^3 + x^2*y^3 + x^3*y^3
        expect_evaluated:        2      3        2    2  2    3  2      3    2  3    3  3
#! x y + x  y + x  y + x y  + x  y  + x  y  + x y  + x  y  + x  y
    ...
# Display terms in a sum in a traditional order:
ok  5*n*Sum[x*n] = 0    ==>     x^5 + x^4 + x^3 + x^2 + x + 1 # skip
ok  3*3*i*j*Sum[Sum[x*y*i*j]]    ==>     y^3*x^3 + y^2*x^3 + y*x^3 + y^3*x^2 + y^2*x^2 + y*x^2 + y^3*x + y^2*x + y*x # skip
# Display a sum without evaluation:
ok  HoldForm[1 + 3 + 2]    ==>     1 + 3 + 2 # skip
# Display the RefLink[FullForm,paclet:ref/FullForm] of a sum:
ok  FullForm[a + b + c + d]    ==>     a + b + c + d # skip
# Find the length of a sum:
ok  Length[a + b + c + d]    ==>     4
    ---
    data:
        got: 4
        expect: 4
        expect_evaluated: 4
    ...
# RefLink[Total,paclet:ref/Total] applies RefLink[Plus,paclet:ref/Plus] to a list:
ok  Plus @@ {a, b, c, d}    ==>     a + b + c + d
    ---
    data:
        got: a + b + c + d
        expect: a + b + c + d
        expect_evaluated: a + b + c + d
    ...
ok  Total[{a, b, c, d}]    ==>     a + b + c + d
    ---
    data:
        got: a + b + c + d
        expect: a + b + c + d
        expect_evaluated: a + b + c + d
    ...
# Pattern matching works with RefLink[Plus,paclet:ref/Plus]:
ok  a + b + c + d /. a + d -> x    ==>     b + c + x
    ---
    data:
        got: b + c + x
        expect: b + c + x
        expect_evaluated: b + c + x
    ...
ok  a + b + c + d /. a + c + (x_) -> f[x]    ==>     f[b + d]
    ---
    data:
        got: f[b + d]
        expect: f[b + d]
        expect_evaluated: f[b + d]
    ...
ok  {a, a + b, a + b + c} /. a + (x_.) -> f[x]    ==>     {f[0], f[b], f[b + c]}
    ---
    data:
        got: {f[0], f[b], f[b + c]}
        expect: {f[0], f[b], f[b + c]}
        expect_evaluated: {f[0], f[b], f[b + c]}
    ...
# Distribute a function over RefLink[Plus,paclet:ref/Plus]:
ok  f[a + b, c + d]    ==>     f[a + b, c + d]
    ---
    data:
        got: f[a + b, c + d]
        expect: f[a + b, c + d]
        expect_evaluated: f[a + b, c + d]
    ...
ok  Distribute[f[a + b, c + d]]    ==>     f[a, c] + f[a, d] + f[b, c] + f[b, d]
    ---
    data:
        got: f[a, c] + f[a, d] + f[b, c] + f[b, d]
        expect: f[a, c] + f[a, d] + f[b, c] + f[b, d]
        expect_evaluated: f[a, c] + f[a, d] + f[b, c] + f[b, d]
    ...
# Distribute RefLink[Plus,paclet:ref/Plus] through a head:
ok  (f + g)[x]    ==>     (f + g)[x]
    ---
    data:
        got: (f + g)[x]
        expect: (f + g)[x]
        expect_evaluated: (f + g)[x]
    ...
ok  Through[(f + g)[x]]    ==>     f[x] + g[x]
    ---
    data:
        got: f[x] + g[x]
        expect: f[x] + g[x]
        expect_evaluated: f[x] + g[x]
    ...
# RefLink[Accumulate,paclet:ref/Accumulate] makes a cumulative sum:
ok  FoldList[Plus, 0, {a, b, c}]    ==>     {0, a, a + b, a + b + c}
    ---
    data:
        got: {0, a, a + b, a + b + c}
        expect: {0, a, a + b, a + b + c}
        expect_evaluated: {0, a, a + b, a + b + c}
    ...
ok  Accumulate[{a, b, c}]    ==>     {a, a + b, a + b + c}
    ---
    data:
        got: {a, a + b, a + b + c}
        expect: {a, a + b, a + b + c}
        expect_evaluated: {a, a + b, a + b + c}
    ...
