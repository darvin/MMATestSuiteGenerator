#! DOCKER > wolfram -script output/Tests/Evaluate_Tests.m
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[ReplaceAll, argrx], StringForm[`1` called with `2` arguments; `3` arguments are expected., Short[HoldForm[ReplaceAll], 3], Short[HoldForm[3], 3], Short[HoldForm[2], 3]]]]
#! TextForm[ColonForm[MessageName[ToString, nonopt], StringForm[Options expected (instead of `1`) beyond position `2` in `3`. An option must be a rule or a list of rules., Short[HoldForm[OutputForm], 3], Short[HoldForm[2], 3], Short[HoldForm[ToString[2, 4, OutputForm]], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: Evaluate_Tests
# Evaluate inside a RefLink[Hold,paclet:ref/Hold]:
not ok  Hold[Evaluate[1 + 1], 2 + 2]    ==>     Hold[2, 2 + 2]
    ---
    data:
        got: 2 /. Sequence[4, Hold[Out[$Line - 1]] -> Null]
        expect: Hold[2, 2 + 2]
        expect_evaluated: ToString[2, 4, OutputForm]
    ...
# RefLink[Evaluate,paclet:ref/Evaluate] works for arguments of any symbol with attributes RefLink[HoldAll,paclet:ref/HoldAll], RefLink[HoldFirst,paclet:ref/HoldFirst], or RefLink[HoldRest,paclet:ref/HoldRest]:
ok  Attributes[Attributes]    ==>     {HoldAll, Listable, Protected}
    ---
    data:
        got: {HoldAll, Listable, Protected}
        expect: {HoldAll, Listable, Protected}
        expect_evaluated: {HoldAll, Listable, Protected}
    ...
# Since RefLink[Attributes,paclet:ref/Attributes] is RefLink[HoldAll,paclet:ref/HoldAll], use RefLink[Evaluate,paclet:ref/Evaluate] to find the properties of the value of x: 
ok  x = Plus ;; {Attributes[x], Attributes[Evaluate[x]]}    ==>     {{}, {Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}} # skip
# Unprotect a system symbol to make a definition for it:
ok  protected = Unprotect[Sqrt]    ==>     {Sqrt}
    ---
    data:
        got: {Sqrt}
        expect: {Sqrt}
        expect_evaluated: {Sqrt}
    ...
# Restore protection:
ok  Protect[Evaluate[protected]]    ==>     {Sqrt}
    ---
    data:
        got: {Sqrt}
        expect: {Sqrt}
        expect_evaluated: {Sqrt}
    ...
# Force evaluation of the right-hand side of a delayed definition:
ok  Expand[(1 + x)^3]    ==>     1 + 3*x + 3*x^2 + x^3
    ---
    data:
        got:                                                2                     3
#! 1 + 3 (Plus ;; {{}, {}}) + 3 (Plus ;; {{}, {}})  + (Plus ;; {{}, {}})
        expect: 1 + 3*x + 3*x^2 + x^3
        expect_evaluated:                                                2                     3
#! 1 + 3 (Plus ;; {{}, {}}) + 3 (Plus ;; {{}, {}})  + (Plus ;; {{}, {}})
    ...
ok  f[x_] := Evaluate[%]; f[x_] := 1 + 3*x + 3*x^2 + x^3    ==>     f[x_] := 1 + 3*x + 3*x^2 + x^3 # skip
# Build a function from an expression:
ok  ch = ChebyshevT[5, x]    ==>     5*x - 20*x^3 + 16*x^5
    ---
    data:
        got:                                             3                        5
#! 5 (Plus ;; {{}, {}}) - 20 (Plus ;; {{}, {}})  + 16 (Plus ;; {{}, {}})
        expect: 5*x - 20*x^3 + 16*x^5
        expect_evaluated:                                             3                        5
#! 5 (Plus ;; {{}, {}}) - 20 (Plus ;; {{}, {}})  + 16 (Plus ;; {{}, {}})
    ...
ok  Function[x, Evaluate[ch]]    ==>     Function[x, 5*x - 20*x^3 + 16*x^5] # skip
ok  %[10]    ==>     1580050
    ---
    data:
        got: 1580050
        expect: 1580050
        expect_evaluated: 1580050
    ...
# RefLink[Evaluate,paclet:ref/Evaluate] does not work inside functions with attribute RefLink[HoldAllComplete,paclet:ref/HoldAllComplete]:
ok  HoldComplete[Evaluate[1 + 2]]    ==>     HoldComplete[Evaluate[1 + 2]]
    ---
    data:
        got: 3
        expect: HoldComplete[Evaluate[1 + 2]]
        expect_evaluated: 3
    ...
# Use RefLink[Unevaluated,paclet:ref/Unevaluated] to temporarily treat a function as if it were RefLink[HoldAll,paclet:ref/HoldAll]:
ok  Length[Unevaluated[1 + 2 + 3]]    ==>     3
    ---
    data:
        got: 3
        expect: 3
        expect_evaluated: 3
    ...
ok  Length[1 + 2 + 3]    ==>     0
    ---
    data:
        got: 0
        expect: 0
        expect_evaluated: 0
    ...
# RefLink[Evaluate,paclet:ref/Evaluate] does not work inside RefLink[Unevaluated,paclet:ref/Unevaluated]:
ok  Unevaluated[Evaluate[1 + 1]]    ==>     Unevaluated[Evaluate[1 + 1]]
    ---
    data:
        got: 2
        expect: Unevaluated[Evaluate[1 + 1]]
        expect_evaluated: 2
    ...
# RefLink[Evaluate,paclet:ref/Evaluate] works only on the first level, directly inside a held function:
ok  Hold[f[Evaluate[1 + 2]]]    ==>     Hold[f[Evaluate[1 + 2]]]
    ---
    data:
        got: 64
        expect: Hold[f[Evaluate[1 + 2]]]
        expect_evaluated: 64
    ...
