#! DOCKER > wolfram -script output/Tests/Evaluate_Tests.m
#! TextForm[ColonForm[MessageName[InputForm, nonopt], StringForm[Options expected (instead of `1`) beyond position `2` in `3`. An option must be a rule or a list of rules., Short[HoldForm[4], 3], Short[HoldForm[1], 3], Short[HoldForm[InputForm[2, 4]], 3]]]]
#! TextForm[ColonForm[MessageName[InputForm, nonopt], StringForm[Options expected (instead of `1`) beyond position `2` in `3`. An option must be a rule or a list of rules., Short[HoldForm[4], 3], Short[HoldForm[1], 3], Short[HoldForm[InputForm[2, 4]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: Evaluate_Tests
# Evaluate inside a RefLink[Hold,paclet:ref/Hold]:
not ok  Hold[Evaluate[1 + 1], 2 + 2]    ==>     Hold[2, 2 + 2]
    ---
    data:
        got: InputForm[2, 4]
        expect: Hold[2, 2 + 2]
        expect_evaluated: InputForm[2, 4]
    ...
# RefLink[Evaluate,paclet:ref/Evaluate] works for arguments of any symbol with attributes RefLink[HoldAll,paclet:ref/HoldAll], RefLink[HoldFirst,paclet:ref/HoldFirst], or RefLink[HoldRest,paclet:ref/HoldRest]:
ok  Attributes[Attributes]    ==>     {HoldAll, Listable, Protected}
    ---
    data:
        got: {HoldAll, Listable, Protected}
        expect: {HoldAll, Listable, Protected}
        expect_evaluated: {HoldAll, Listable, Protected}
    ...
ok  {Attributes[x], Attributes[Evaluate[x]]}    ==>     {{}, {Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}} # skip
# Unprotect a system symbol to make a definition for it:
ok  protected = Unprotect[Sqrt]    ==>     {Sqrt} # skip
# Restore protection:
ok  Protect[Evaluate[protected]]    ==>     {Sqrt} # skip
# Force evaluation of the right-hand side of a delayed definition:
ok  Expand[(1 + x)^3]    ==>     1 + 3*x + 3*x^2 + x^3
    ---
    data:
        got: 1 + 3*x + 3*x^2 + x^3
        expect: 1 + 3*x + 3*x^2 + x^3
        expect_evaluated: 1 + 3*x + 3*x^2 + x^3
    ...
ok  f[x_] := 1 + 3*x + 3*x^2 + x^3    ==>     f[x_] := 1 + 3*x + 3*x^2 + x^3 # skip
# Build a function from an expression:
ok  ch = ChebyshevT[5, x]    ==>     5*x - 20*x^3 + 16*x^5
    ---
    data:
        got: 5*x - 20*x^3 + 16*x^5
        expect: 5*x - 20*x^3 + 16*x^5
        expect_evaluated: 5*x - 20*x^3 + 16*x^5
    ...
ok  Function[x, Evaluate[ch]]    ==>     Function[x, 5*x - 20*x^3 + 16*x^5] # skip
ok  %[10]    ==>     1580050 # skip
# RefLink[Evaluate,paclet:ref/Evaluate] does not work inside functions with attribute RefLink[HoldAllComplete,paclet:ref/HoldAllComplete]:
ok  HoldComplete[Evaluate[1 + 2]]    ==>     HoldComplete[Evaluate[1 + 2]]
    ---
    data:
        got: 3
        expect: HoldComplete[Evaluate[1 + 2]]
        expect_evaluated: 3
    ...
# Use RefLink[Unevaluated,paclet:ref/Unevaluated] to temporarily treat a function as if it were RefLink[HoldAll,paclet:ref/HoldAll]:
ok  Length[Unevaluated[1 + 2 + 3]]    ==>     3
    ---
    data:
        got: 3
        expect: 3
        expect_evaluated: 3
    ...
ok  Length[1 + 2 + 3]    ==>     0
    ---
    data:
        got: 0
        expect: 0
        expect_evaluated: 0
    ...
# RefLink[Evaluate,paclet:ref/Evaluate] does not work inside RefLink[Unevaluated,paclet:ref/Unevaluated]:
ok  Unevaluated[Evaluate[1 + 1]]    ==>     Unevaluated[Evaluate[1 + 1]]
    ---
    data:
        got: 2
        expect: Unevaluated[Evaluate[1 + 1]]
        expect_evaluated: 2
    ...
# RefLink[Evaluate,paclet:ref/Evaluate] works only on the first level, directly inside a held function:
ok  Hold[f[Evaluate[1 + 2]]]    ==>     Hold[f[Evaluate[1 + 2]]]
    ---
    data:
        got: f[3]
        expect: Hold[f[Evaluate[1 + 2]]]
        expect_evaluated: f[3]
    ...
