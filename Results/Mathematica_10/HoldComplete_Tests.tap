#! DOCKER > wolfram -script output/Tests/HoldComplete_Tests.m
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
#! TextForm[ColonForm[MessageName[ReplaceAll, argrx], StringForm[`1` called with `2` arguments; `3` arguments are expected., Short[HoldForm[ReplaceAll], 3], Short[HoldForm[4], 3], Short[HoldForm[2], 3]]]]
#! TextForm[ColonForm[MessageName[ToString, nonopt], StringForm[Options expected (instead of `1`) beyond position `2` in `3`. An option must be a rule or a list of rules., Short[HoldForm[OutputForm], 3], Short[HoldForm[2], 3], Short[HoldForm[ToString[a, b, 3, OutputForm]], 3]]]]
#! TextForm[ColonForm[MessageName[ReplaceAll, argrx], StringForm[`1` called with `2` arguments; `3` arguments are expected., Short[HoldForm[ReplaceAll], 3], Short[HoldForm[3], 3], Short[HoldForm[2], 3]]]]
#! TextForm[ColonForm[MessageName[ToString, nonopt], StringForm[Options expected (instead of `1`) beyond position `2` in `3`. An option must be a rule or a list of rules., Short[HoldForm[OutputForm], 3], Short[HoldForm[2], 3], Short[HoldForm[ToString[a, b, OutputForm]], 3]]]]
#! TextForm[ColonForm[MessageName[ReleaseHold, argx], StringForm[`1` called with `2` arguments; 1 argument is expected., Short[HoldForm[ReleaseHold], 3], Short[HoldForm[2], 3]]]]
#! TextForm[ColonForm[MessageName[ReleaseHold, argx], StringForm[`1` called with `2` arguments; 1 argument is expected., Short[HoldForm[ReleaseHold], 3], Short[HoldForm[2], 3]]]]
#! TextForm[ColonForm[MessageName[ReplaceAll, argrx], StringForm[`1` called with `2` arguments; `3` arguments are expected., Short[HoldForm[ReplaceAll], 3], Short[HoldForm[3], 3], Short[HoldForm[2], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[ReplaceAll, argrx]], 3]]]]
#! TextForm[ColonForm[MessageName[ToString, nonopt], StringForm[Options expected (instead of `1`) beyond position `2` in `3`. An option must be a rule or a list of rules., Short[HoldForm[OutputForm], 3], Short[HoldForm[2], 3], Short[HoldForm[ToString[a, b, OutputForm]], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[ToString, nonopt]], 3]]]]
#! TextForm[ColonForm[MessageName[FullForm, nonopt], StringForm[Options expected (instead of `1`) beyond position `2` in `3`. An option must be a rule or a list of rules., Short[HoldForm[a/b], 3], Short[HoldForm[1], 3], Short[HoldForm[FullForm[a - b, a/b]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: HoldComplete_Tests
ok  $Failed    ==>     HoldComplete[HoldComplete[1 + 1, Evaluate[1 + 2], Sequence[3, 4]]] # skip
# RefLink[HoldComplete,paclet:ref/HoldComplete] is the standard container with attribute RefLink[HoldAllComplete,paclet:ref/HoldAllComplete]:
ok  Attributes[HoldComplete]    ==>     {HoldAllComplete, Protected}
    ---
    data:
        got: {HoldAllComplete, Protected}
        expect: {HoldAllComplete, Protected}
        expect_evaluated: {HoldAllComplete, Protected}
    ...
not ok  HoldComplete[Sequence[a, b], 1 + 2]    ==>     HoldComplete[Sequence[a, b], 1 + 2]
    ---
    data:
        got: a /. Sequence[b, 3, Hold[Out[$Line - 1]] -> {HoldAllComplete, Protected}]
        expect: HoldComplete[Sequence[a, b], 1 + 2]
        expect_evaluated: ToString[a, b, 3, OutputForm]
    ...
# No form of evaluation control affects an expression with attribute RefLink[HoldAllComplete,paclet:ref/HoldAllComplete]:
ok  HoldComplete[1 + 2]    ==>     HoldComplete[1 + 2]
    ---
    data:
        got: 3
        expect: HoldComplete[1 + 2]
        expect_evaluated: 3
    ...
ok  HoldComplete[Evaluate[1 + 2]]    ==>     HoldComplete[Evaluate[1 + 2]]
    ---
    data:
        got: 3
        expect: HoldComplete[Evaluate[1 + 2]]
        expect_evaluated: 3
    ...
not ok  HoldComplete[Sequence[a, b]]    ==>     HoldComplete[Sequence[a, b]]
    ---
    data:
        got: a /. Sequence[b, Hold[Out[$Line - 1]] -> 3]
        expect: HoldComplete[Sequence[a, b]]
        expect_evaluated: ToString[a, b, OutputForm]
    ...
ok  g /: HoldComplete[g[x_]] := x; HoldComplete[g[1]]    ==>     HoldComplete[g[1]]
    ---
    data:
        got: g[1]
        expect: HoldComplete[g[1]]
        expect_evaluated: g[1]
    ...
# Substitution still happens inside RefLink[HoldComplete,paclet:ref/HoldComplete]:
ok  HoldComplete[f[1 + 2]] /. f[x_] :> g[x]    ==>     HoldComplete[g[1 + 2]]
    ---
    data:
        got: g[3]
        expect: HoldComplete[g[1 + 2]]
        expect_evaluated: g[3]
    ...
# RefLink[ReleaseHold,paclet:ref/ReleaseHold] removes one level of RefLink[HoldComplete,paclet:ref/HoldComplete]:
ok  ReleaseHold[HoldComplete[Sequence[1, 2]]]    ==>     Sequence[1, 2] # skip
# RefLink[Hold,paclet:ref/Hold] is a milder form of RefLink[HoldComplete,paclet:ref/HoldComplete] that allows for some form of evaluation:
ok  Hold[1 + 2]    ==>     Hold[1 + 2]
    ---
    data:
        got: 3
        expect: Hold[1 + 2]
        expect_evaluated: 3
    ...
ok  Hold[Evaluate[1 + 2]]    ==>     Hold[3]
    ---
    data:
        got: 3
        expect: Hold[3]
        expect_evaluated: 3
    ...
not ok  Hold[Sequence[a, b]]    ==>     Hold[a, b]
    ---
    data:
        got: a /. Sequence[b, Hold[Out[$Line - 1]] -> 3]
        expect: Hold[a, b]
        expect_evaluated: ToString[a, b, OutputForm]
    ...
ok  g /: Hold[g[x_]] := x; Hold[g[1]]    ==>     1
    ---
    data:
        got: 1
        expect: 1
        expect_evaluated: 1
    ...
# RefLink[HoldComplete,paclet:ref/HoldComplete] can be used to freeze the result of RefLink[ToExpression,paclet:ref/ToExpression] before it is evaluated:
not ok  ToExpression["Sequence[a,b]", InputForm, HoldComplete]    ==>     HoldComplete[Sequence[a, b]]
    ---
    data:
        got: a /. Sequence[b, Hold[Out[$Line - 1]] -> 1]
        expect: HoldComplete[Sequence[a, b]]
        expect_evaluated: ToString[a, b, OutputForm]
    ...
# RefLink[HoldComplete,paclet:ref/HoldComplete] affects only evaluation; input transformations are still applied:
ok  FullForm[HoldComplete[a - b, a/b]]    ==>     HoldComplete[a - b, a/b] # skip
