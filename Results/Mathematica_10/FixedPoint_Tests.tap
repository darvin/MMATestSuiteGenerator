#! DOCKER > wolfram -script output/Tests/FixedPoint_Tests.m
# SYSTEM: Mathematica_10
# TEST: FixedPoint_Tests
# Find a value x such that x^2=2:
ok  FixedPoint[(#1 + 2/#1)/2 & , 1.]    ==>     1.41421 # skip
ok  Sqrt[2.]    ==>     1.41421 # skip
# Fixed point of an integer-valued function:
ok  NestList[1 + Floor[#1/2] & , 1000, 20]    ==>     {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}
    ---
    data:
        got: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}
        expect: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}
        expect_evaluated: {1000, 501, 251, 126, 64, 33, 17, 9, 5, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}
    ...
ok  FixedPoint[1 + Floor[#1/2] & , 1000]    ==>     2
    ---
    data:
        got: 2
        expect: 2
        expect_evaluated: 2
    ...
# Repeated application of a rule until the result no longer changes:
ok  FixedPoint[#1 /. {a_, b_} /; b != 0 -> {b, Mod[a, b]} & , {28, 21}]    ==>     {7, 0}
    ---
    data:
        got: {7, 0}
        expect: {7, 0}
        expect_evaluated: {7, 0}
    ...
ok  GCD[28, 21]    ==>     7
    ---
    data:
        got: 7
        expect: 7
        expect_evaluated: 7
    ...
# Numerical fixed point of a function:
ok  FixedPoint[Erf, 1.]    ==>     0.617447 # skip
# Fixed point of a repeated transformation:
ok  FixedPoint[#1 /. {fact[0] -> 1, fact[n_] :> n*fact[n - 1]} & , fact[17]]    ==>     355687428096000
    ---
    data:
        got: 355687428096000
        expect: 355687428096000
        expect_evaluated: 355687428096000
    ...
# Stop after at most 10 steps:
ok  FixedPoint[1 + Floor[#1/2] & , 10^6, 10]    ==>     978
    ---
    data:
        got: 978
        expect: 978
        expect_evaluated: 978
    ...
ok  FixedPoint[1 + Floor[#1/2] & , 10^6]    ==>     2
    ---
    data:
        got: 2
        expect: 2
        expect_evaluated: 2
    ...
# Stop as soon as successive iterations differ by less than 10^-10:
ok  FixedPoint[(#1 + 2/#1)/2 & , 1.`20., SameTest -> (Abs[#1 - #2] < 1/10000000000 & )]    ==>     1.4142135623730950488`19.15051499783199
    ---
    data:
        got: 1.41421356237309504880168962350253024361`20.
        expect: 1.4142135623730950488`19.15051499783199
        expect_evaluated: 1.4142135623730950488`19.15051499783199
    ...
ok  FixedPoint[(#1 + 2/#1)/2 & , 1, SameTest -> (Abs[#1 - #2] < 1/10000000000 & )]    ==>     886731088897/627013566048
    ---
    data:
        got: 886731088897/627013566048
        expect: 886731088897/627013566048
        expect_evaluated: 886731088897/627013566048
    ...
# Perform exact arithmetic, but use a numerical comparison function:
ok  FixedPoint[(#1 + 2/#1)/2 & , 1, SameTest -> (N[#1] == N[#2] & )]    ==>     1572584048032918633353217/1111984844349868137938112
    ---
    data:
        got: 1572584048032918633353217/1111984844349868137938112
        expect: 1572584048032918633353217/1111984844349868137938112
        expect_evaluated: 1572584048032918633353217/1111984844349868137938112
    ...
# Find Sqrt[2] using Newton's method:
ok  FixedPoint[(#1 + 2/#1)/2 & , 1.]    ==>     1.41421 # skip
# Fixed point of a complex iteration:
ok  FixedPoint[Log, 1. + I]    ==>     0.318132 + 1.33724*I # skip
# Matrix-multiplication convergence:
ok  MatrixForm[FixedPoint[{{0.51, 0.49}, {0.49, 0.51}} . #1 & , {{1, 0}, {0, 1}}]]    ==>     0.5*0.5*0.5*0.5 # skip
# Root of the current directory tree (the result will depend on computer system):
ok  HoldComplete[FixedPoint[ParentDirectory, Directory[]]]    ==>     $Failed # skip
# Repeated differentiation:
ok  FixedPoint[D[#1, x] & , x^10]    ==>     0
    ---
    data:
        got: 0
        expect: 0
        expect_evaluated: 0
    ...
# Find the minimum of (x-1)^2+y^2 with the steepest-descent method (vector notation):
ok  With[{\[Epsilon] = 0.1}, FixedPoint[Function[xy, {2*\[Epsilon], 0} + {{1 - 2*\[Epsilon], 0}, {0, 1 - 2*\[Epsilon]}} . xy], {1., 1.}]]    ==>     {1., 0.}
    ---
    data:
        got: {1., 0.}
        expect: {1., 0.}
        expect_evaluated: {1., 0.}
    ...
# Component notation:
ok  With[{\[Epsilon] = 0.1}, FixedPoint[Function[{x, y}, {x + 2*\[Epsilon] - 2*x*\[Epsilon], y - 2*y*\[Epsilon]}] @@ #1 & , {1., 1.}]]    ==>     {1., 3./10^323} # skip
# Evaluate combinators [WebLink[more info,http://www.wolframscience.com/nksonline/page-1122]]:
ok  FixedPoint[#1 /. {s[x_][y_][z_] -> x[z][y[z]], k[x_][y_] -> x} & , s[s[s[s][s]]][s][s][k]]    ==>     s[k[s[s[s]][k]]][s[k[k[s[s[s]][k]]]][s[s[s]][k]]]
    ---
    data:
        got: s[k[s[s[s]][k]]][s[k[k[s[s[s]][k]]]][s[s[s]][k]]]
        expect: s[k[s[s[s]][k]]][s[k[k[s[s[s]][k]]]][s[s[s]][k]]]
        expect_evaluated: s[k[s[s[s]][k]]][s[k[k[s[s[s]][k]]]][s[s[s]][k]]]
    ...
ok  ConnectedNodes[{{3, 2}, {4, 3}, {5, 4}, {1, 5}, {2, 1}}, 1]    ==>     {1, 2, 3, 4, 5} # skip
# RefLink[FixedPoint,paclet:ref/FixedPoint] gives the last element of RefLink[FixedPointList,paclet:ref/FixedPointList]:
ok  FixedPointList[Function[x, (x + 2/x)/2], 1.]    ==>     {1., 1.5, 1.41667, 1.41422, 1.41421, 1.41421, 1.41421} # skip
ok  FixedPoint[Function[x, (x + 2/x)/2], 1.]    ==>     1.41421 # skip
# Apply rules repeatedly until the result no longer changes using RefLink[ReplaceRepeated,paclet:ref/ReplaceRepeated] (//.):
ok  FixedPoint[#1 /. {a -> b, b -> c, c -> d} & , a^2 + c^3]    ==>     d^2 + d^3
    ---
    data:
        got: d^2 + d^3
        expect: d^2 + d^3
        expect_evaluated: d^2 + d^3
    ...
ok  a^2 + c^3 /. {a -> b, b -> c, c -> d}    ==>     b^2 + d^3
    ---
    data:
        got: b^2 + d^3
        expect: b^2 + d^3
        expect_evaluated: b^2 + d^3
    ...
ok  a^2 + c^3 //. {a -> b, b -> c, c -> d}    ==>     d^2 + d^3
    ---
    data:
        got: d^2 + d^3
        expect: d^2 + d^3
        expect_evaluated: d^2 + d^3
    ...
# RefLink[FixedPoint,paclet:ref/FixedPoint] is equivalent to a particular choice of arguments of RefLink[NestWhile,paclet:ref/NestWhile]:
ok  NestWhile[Function[x, (x + 2/x)/2], 1., UnsameQ, 2]    ==>     1.41421 # skip
# Calculations may not converge in a finite number of steps:
ok  TimeConstrained[FixedPoint[#1/3 + 1/4 & , Interval[{0, 1}]], 1]    ==>     $Aborted
    ---
    data:
        got: $Aborted
        expect: $Aborted
        expect_evaluated: $Aborted
    ...
# Providing a maximum number of iterations will guarantee termination:
ok  FixedPoint[#1/3 + 1/4 & , Interval[{0, 1}], 50]    ==>     Interval[{89737248461481573596281/239299329230617529590083, 269211745384444720788844/717897987691852588770249}]
    ---
    data:
        got: Interval[{89737248461481573596281/239299329230617529590083, 269211745384444720788844/717897987691852588770249}]
        expect: Interval[{89737248461481573596281/239299329230617529590083, 269211745384444720788844/717897987691852588770249}]
        expect_evaluated: Interval[{89737248461481573596281/239299329230617529590083, 269211745384444720788844/717897987691852588770249}]
    ...
# Using a numerical test for convergence works in this case as well:
ok  FixedPoint[#1/3 + 1/4 & , Interval[{0, 1}], SameTest -> (N[#1] === N[#2] & )]    ==>     Interval[{2084647712458321/5559060566555523, 6253943137374964/16677181699666569}]
    ---
    data:
        got: Interval[{2084647712458321/5559060566555523, 6253943137374964/16677181699666569}]
        expect: Interval[{2084647712458321/5559060566555523, 6253943137374964/16677181699666569}]
        expect_evaluated: Interval[{2084647712458321/5559060566555523, 6253943137374964/16677181699666569}]
    ...
# Sometimes convergence may fail on certain platforms due to insufficient accuracy of a machine arithmetic library function. This can be addressed by using a comparison function with a larger tolerance:
ok  FixedPoint[Cos, 0.5, SameTest -> Equal]    ==>     0.739085 # skip
