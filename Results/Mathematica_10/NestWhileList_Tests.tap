# SYSTEM: Mathematica_10
# TEST: NestWhileList_Tests
# OUTPUT: output/Results/Mathematica_10/NestWhileList_Tests.json
# Keep dividing by 2 until the result is no longer an even number:
ok  NestWhileList[#1/2 & , 123456, EvenQ]    ==>     {123456, 61728, 30864, 15432, 7716, 3858, 1929}
    ---
    data:
        got: {123456, 61728, 30864, 15432, 7716, 3858, 1929}
        expect: {123456, 61728, 30864, 15432, 7716, 3858, 1929}
        expect_evaluated: {123456, 61728, 30864, 15432, 7716, 3858, 1929}
    ...
# Iterate taking logarithms until the result is no longer positive:
ok  NestWhileList[Log, 100, #1 > 0 & ]    ==>     {100, Log[100], Log[Log[100]], Log[Log[Log[100]]], Log[Log[Log[Log[100]]]]}
    ---
    data:
        got: {100, Log[100], Log[Log[100]], Log[Log[Log[100]]], Log[Log[Log[Log[100]]]]}
        expect: {100, Log[100], Log[Log[100]], Log[Log[Log[100]]], Log[Log[Log[Log[100]]]]}
        expect_evaluated: {100, Log[100], Log[Log[100]], Log[Log[Log[100]]], Log[Log[Log[Log[100]]]]}
    ...
# Start comparisons after 4 iterations, and compare using the 4 last values:
ok  NestWhileList[Floor[#1/2] & , 10, (Print[{##1}]; UnsameQ[##1]) & , 4]    ==>     {10, 5, 2, 1, 0, 0}
    ---
    data:
        got: {10, 5, 2, 1, 0, 0}
        expect: {10, 5, 2, 1, 0, 0}
        expect_evaluated: {10, 5, 2, 1, 0, 0}
    ...
# Start comparisons after 4 iterations, and compare using the 6 last values:
ok  NestWhileList[Floor[#1/2] & , 10, (Print[{##1}]; UnsameQ[##1]) & , {4, 6}]    ==>     {10, 5, 2, 1, 0, 0}
    ---
    data:
        got: {10, 5, 2, 1, 0, 0}
        expect: {10, 5, 2, 1, 0, 0}
        expect_evaluated: {10, 5, 2, 1, 0, 0}
    ...
# Always compare all values generated:
ok  NestWhileList[Floor[#1/2] & , 10, (Print[{##1}]; UnsameQ[##1]) & , All]    ==>     {10, 5, 2, 1, 0, 0}
    ---
    data:
        got: {10, 5, 2, 1, 0, 0}
        expect: {10, 5, 2, 1, 0, 0}
        expect_evaluated: {10, 5, 2, 1, 0, 0}
    ...
# Stop after at most 4 steps, even if the condition is still RefLink[True,paclet:ref/True]:
ok  NestWhileList[Floor[#1/2] & , 20, UnsameQ, 2, 4]    ==>     {20, 10, 5, 2, 1}
    ---
    data:
        got: {20, 10, 5, 2, 1}
        expect: {20, 10, 5, 2, 1}
        expect_evaluated: {20, 10, 5, 2, 1}
    ...
# Continue until the result is no longer greater than 1:
ok  NestWhileList[Floor[#1/2] & , 20, #1 > 1 & , 1, Infinity]    ==>     {20, 10, 5, 2, 1}
    ---
    data:
        got: {20, 10, 5, 2, 1}
        expect: {20, 10, 5, 2, 1}
        expect_evaluated: {20, 10, 5, 2, 1}
    ...
# Perform one more step after the condition is no longer RefLink[True,paclet:ref/True]:
ok  NestWhileList[Floor[#1/2] & , 20, #1 > 1 & , 1, Infinity, 1]    ==>     {20, 10, 5, 2, 1, 0}
    ---
    data:
        got: {20, 10, 5, 2, 1, 0}
        expect: {20, 10, 5, 2, 1, 0}
        expect_evaluated: {20, 10, 5, 2, 1, 0}
    ...
# Drop the last value generated (for which the test was no longer RefLink[True,paclet:ref/True]):
ok  NestWhileList[Floor[#1/2] & , 20, #1 > 1 & , 1, Infinity, -1]    ==>     {20, 10, 5, 2}
    ---
    data:
        got: {20, 10, 5, 2}
        expect: {20, 10, 5, 2}
        expect_evaluated: {20, 10, 5, 2}
    ...
# Find successive integers until a prime is reached:
ok  NestWhileList[#1 + 1 & , 899,  !PrimeQ[#1] & ]    ==>     {899, 900, 901, 902, 903, 904, 905, 906, 907}
    ---
    data:
        got: {899, 900, 901, 902, 903, 904, 905, 906, 907}
        expect: {899, 900, 901, 902, 903, 904, 905, 906, 907}
        expect_evaluated: {899, 900, 901, 902, 903, 904, 905, 906, 907}
    ...
# Find the multiplicative order of 2 modulo 19:
ok  NestWhileList[Mod[2*#1, 19] & , 2, #1 != 1 & ]    ==>     {2, 4, 8, 16, 13, 7, 14, 9, 18, 17, 15, 11, 3, 6, 12, 5, 10, 1}
    ---
    data:
        got: {2, 4, 8, 16, 13, 7, 14, 9, 18, 17, 15, 11, 3, 6, 12, 5, 10, 1}
        expect: {2, 4, 8, 16, 13, 7, 14, 9, 18, 17, 15, 11, 3, 6, 12, 5, 10, 1}
        expect_evaluated: {2, 4, 8, 16, 13, 7, 14, 9, 18, 17, 15, 11, 3, 6, 12, 5, 10, 1}
    ...
ok  Length[%]    ==>     18 # skip
# Use RefLink[MultiplicativeOrder,paclet:ref/MultiplicativeOrder] to compute directly:
ok  MultiplicativeOrder[2, 19]    ==>     18
    ---
    data:
        got: 18
        expect: 18
        expect_evaluated: 18
    ...
# Find the orbit of 4 under the mapping 5x  mod 7:
ok  NestWhileList[Mod[5*#1, 7] & , 4, Unequal, All]    ==>     {4, 6, 2, 3, 1, 5, 4}
    ---
    data:
        got: {4, 6, 2, 3, 1, 5, 4}
        expect: {4, 6, 2, 3, 1, 5, 4}
        expect_evaluated: {4, 6, 2, 3, 1, 5, 4}
    ...
# Keep applying iterations in the 3n+1 problem until the results repeat:
ok  NestWhileList[If[EvenQ[#1], #1/2, (3*#1 + 1)/2] & , 400, Unequal, All]    ==>     {400, 200, 100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1, 2}
    ---
    data:
        got: {400, 200, 100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1, 2}
        expect: {400, 200, 100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1, 2}
        expect_evaluated: {400, 200, 100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1, 2}
    ...
# Exclude the first repeating element from the output:
ok  NestWhileList[If[EvenQ[#1], #1/2, (3*#1 + 1)/2] & , 400, Unequal, All, Infinity, -1]    ==>     {400, 200, 100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1}
    ---
    data:
        got: {400, 200, 100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1}
        expect: {400, 200, 100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1}
        expect_evaluated: {400, 200, 100, 50, 25, 38, 19, 29, 44, 22, 11, 17, 26, 13, 20, 10, 5, 8, 4, 2, 1}
    ...
# Apply Newton iterations for Sqrt[2] until successive results are within 0.001.
ok  NestWhileList[(#1 + 2/#1)/2 & , 1, Abs[#1 - #2] > 0.001 & , 2]    ==>     {1, 3/2, 17/12, 577/408, 665857/470832}
    ---
    data:
        got: {1, 3/2, 17/12, 577/408, 665857/470832}
        expect: {1, 3/2, 17/12, 577/408, 665857/470832}
        expect_evaluated: {1, 3/2, 17/12, 577/408, 665857/470832}
    ...
# These two forms are equivalent:
ok  NestWhileList[Floor[#1/2] & , 10, UnsameQ, {4, 4}]    ==>     {10, 5, 2, 1, 0, 0}
    ---
    data:
        got: {10, 5, 2, 1, 0, 0}
        expect: {10, 5, 2, 1, 0, 0}
        expect_evaluated: {10, 5, 2, 1, 0, 0}
    ...
ok  NestWhileList[Floor[#1/2] & , 10, UnsameQ, 4]    ==>     {10, 5, 2, 1, 0, 0}
    ---
    data:
        got: {10, 5, 2, 1, 0, 0}
        expect: {10, 5, 2, 1, 0, 0}
        expect_evaluated: {10, 5, 2, 1, 0, 0}
    ...
# RefLink[NestWhileList,paclet:ref/NestWhileList] returns all intermediate values of RefLink[NestWhile,paclet:ref/NestWhile]:
ok  NestWhileList[#1/2 & , 123456, EvenQ]    ==>     {123456, 61728, 30864, 15432, 7716, 3858, 1929}
    ---
    data:
        got: {123456, 61728, 30864, 15432, 7716, 3858, 1929}
        expect: {123456, 61728, 30864, 15432, 7716, 3858, 1929}
        expect_evaluated: {123456, 61728, 30864, 15432, 7716, 3858, 1929}
    ...
ok  Reap[NestWhile[Sow[#1]/2 & , 123456, EvenQ]]    ==>     {1929, {{123456, 61728, 30864, 15432, 7716, 3858}}}
    ---
    data:
        got: {1929, {{123456, 61728, 30864, 15432, 7716, 3858}}}
        expect: {1929, {{123456, 61728, 30864, 15432, 7716, 3858}}}
        expect_evaluated: {1929, {{123456, 61728, 30864, 15432, 7716, 3858}}}
    ...
# RefLink[FixedPointList,paclet:ref/FixedPointList] always compares the last two values; these two forms are equivalent:
ok  NestWhileList[(#1 + 3/#1)/2 & , 1., UnsameQ, 2]    ==>     {1., 2., 1.75, 1.73214, 1.73205, 1.73205, 1.73205} # skip
ok  FixedPointList[(#1 + 3/#1)/2 & , 1.]    ==>     {1., 2., 1.75, 1.73214, 1.73205, 1.73205, 1.73205} # skip
# Find the digits of a number:
ok  With[{n = 123456, k = 10}, Reverse[Mod[NestWhileList[Quotient[#1, k] & , n, #1 >= k & ], k]]]    ==>     {1, 2, 3, 4, 5, 6}
    ---
    data:
        got: {1, 2, 3, 4, 5, 6}
        expect: {1, 2, 3, 4, 5, 6}
        expect_evaluated: {1, 2, 3, 4, 5, 6}
    ...
ok  Distance[dodec, {1, 11}]    ==>     5 # skip
# A plot of the graph:
ok  HoldComplete[GraphPlot[Flatten[Thread /@ dodec], VertexLabeling -> True]]    ==>     $Failed # skip
