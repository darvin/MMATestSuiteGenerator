#! DOCKER > wolfram -script output/Tests/Flatten_Tests.m
# SYSTEM: Mathematica_10
# TEST: Flatten_Tests
# Flatten out lists at all levels:
ok  Flatten[{{a, b}, {c, {d}, e}, {f, {g, h}}}]    ==>     {a, b, c, d, e, f, g, h}
    ---
    data:
        got: {a, b, c, d, e, f, g, h}
        expect: {a, b, c, d, e, f, g, h}
        expect_evaluated: {a, b, c, d, e, f, g, h}
    ...
# Flatten only at level 1:
ok  Flatten[{{a, b}, {c, {d}, e}, {f, {g, h}}}, 1]    ==>     {a, b, c, {d}, e, f, {g, h}}
    ---
    data:
        got: {a, b, c, {d}, e, f, {g, h}}
        expect: {a, b, c, {d}, e, f, {g, h}}
        expect_evaluated: {a, b, c, {d}, e, f, {g, h}}
    ...
# No flattening:
ok  Flatten[{0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}, 0]    ==>     {0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}
    ---
    data:
        got: {0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}
        expect: {0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}
        expect_evaluated: {0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}
    ...
# Flatten to level 1:
ok  Flatten[{0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}, 1]    ==>     {0, 1, {2, -2}, {{3}, {-3}}, {{{4}}}}
    ---
    data:
        got: {0, 1, {2, -2}, {{3}, {-3}}, {{{4}}}}
        expect: {0, 1, {2, -2}, {{3}, {-3}}, {{{4}}}}
        expect_evaluated: {0, 1, {2, -2}, {{3}, {-3}}, {{{4}}}}
    ...
# Flatten to level 2:
ok  Flatten[{0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}, 2]    ==>     {0, 1, 2, -2, {3}, {-3}, {{4}}}
    ---
    data:
        got: {0, 1, 2, -2, {3}, {-3}, {{4}}}
        expect: {0, 1, 2, -2, {3}, {-3}, {{4}}}
        expect_evaluated: {0, 1, 2, -2, {3}, {-3}, {{4}}}
    ...
# Flatten to level 3:
ok  Flatten[{0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}, 3]    ==>     {0, 1, 2, -2, 3, -3, {4}}
    ---
    data:
        got: {0, 1, 2, -2, 3, -3, {4}}
        expect: {0, 1, 2, -2, 3, -3, {4}}
        expect_evaluated: {0, 1, 2, -2, 3, -3, {4}}
    ...
# Flatten to level 4:
ok  Flatten[{0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}, 4]    ==>     {0, 1, 2, -2, 3, -3, 4}
    ---
    data:
        got: {0, 1, 2, -2, 3, -3, 4}
        expect: {0, 1, 2, -2, 3, -3, 4}
        expect_evaluated: {0, 1, 2, -2, 3, -3, 4}
    ...
# This is the same as using level \[Infinity]:
ok  Flatten[{0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}, Infinity]    ==>     {0, 1, 2, -2, 3, -3, 4}
    ---
    data:
        got: {0, 1, 2, -2, 3, -3, 4}
        expect: {0, 1, 2, -2, 3, -3, 4}
        expect_evaluated: {0, 1, 2, -2, 3, -3, 4}
    ...
# And the same as not specifying a level:
ok  Flatten[{0, {1}, {{2, -2}}, {{{3}, {-3}}}, {{{{4}}}}}]    ==>     {0, 1, 2, -2, 3, -3, 4}
    ---
    data:
        got: {0, 1, 2, -2, 3, -3, 4}
        expect: {0, 1, 2, -2, 3, -3, 4}
        expect_evaluated: {0, 1, 2, -2, 3, -3, 4}
    ...
# Flatten a sparse array:
ok  HoldComplete[Flatten[SparseArray[{{1, 2} -> a, {6, 4} -> b}]]]    ==>     $Failed # skip
ok  Normal[%]    ==>     {0, a, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, b} # skip
# RefLink[Flatten,paclet:ref/Flatten] works with any head:
ok  Flatten[f[f[x, y], z]]    ==>     f[x, y, z]
    ---
    data:
        got: f[x, y, z]
        expect: f[x, y, z]
        expect_evaluated: f[x, y, z]
    ...
# Flatten all levels with respect to g:
ok  Flatten[f[g[u, v], f[x, y]], Infinity, g]    ==>     f[u, v, f[x, y]]
    ---
    data:
        got: f[u, v, f[x, y]]
        expect: f[u, v, f[x, y]]
        expect_evaluated: f[u, v, f[x, y]]
    ...
# Flatten all levels with respect to f:
ok  Flatten[f[g[u, v], f[x, y]], Infinity, f]    ==>     f[g[u, v], x, y]
    ---
    data:
        got: f[g[u, v], x, y]
        expect: f[g[u, v], x, y]
        expect_evaluated: f[g[u, v], x, y]
    ...
# Here is a matrix:
ok  u = {{a, b}, {c, d}}    ==>     {{a, b}, {c, d}}
    ---
    data:
        got: {{a, b}, {c, d}}
        expect: {{a, b}, {c, d}}
        expect_evaluated: {{a, b}, {c, d}}
    ...
# Flatten an array of blocks with the shape of u into a single matrix.
ok  MatrixForm[Flatten[{{u, 0*u}, {0*u, u}}, {{1, 3}, {2, 4}}]]    ==>     a*b*0*0*c*d*0*0*0*0*a*b*0*0*c*d # skip
# Flatten into a single matrix effectively using the transpose of the blocks:
ok  MatrixForm[Flatten[{{u, 0*u}, {0*u, u}}, {{1, 4}, {2, 3}}]]    ==>     a*c*0*0*b*d*0*0*0*0*a*c*0*0*b*d # skip
# Join lists and individual elements:
ok  Range[5]    ==>     {1, 2, 3, 4, 5}
    ---
    data:
        got: {1, 2, 3, 4, 5}
        expect: {1, 2, 3, 4, 5}
        expect_evaluated: {1, 2, 3, 4, 5}
    ...
ok  Flatten[{%, x, %, %, y}]    ==>     {1, 2, 3, 4, 5, x, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, y} # skip
# Unravel a matrix:
ok  Table[i^j, {i, 3}, {j, 4}]    ==>     {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
    ---
    data:
        got: {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
        expect: {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
        expect_evaluated: {{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}}
    ...
ok  Flatten[%]    ==>     {1, 1, 1, 1, 2, 4, 8, 16, 3, 9, 27, 81} # skip
# Make a flattened list of rules:
ok  Table[i -> j, {i, 4}, {j, 3}]    ==>     {{1 -> 1, 1 -> 2, 1 -> 3}, {2 -> 1, 2 -> 2, 2 -> 3}, {3 -> 1, 3 -> 2, 3 -> 3}, {4 -> 1, 4 -> 2, 4 -> 3}}
    ---
    data:
        got: {{1 -> 1, 1 -> 2, 1 -> 3}, {2 -> 1, 2 -> 2, 2 -> 3}, {3 -> 1, 3 -> 2, 3 -> 3}, {4 -> 1, 4 -> 2, 4 -> 3}}
        expect: {{1 -> 1, 1 -> 2, 1 -> 3}, {2 -> 1, 2 -> 2, 2 -> 3}, {3 -> 1, 3 -> 2, 3 -> 3}, {4 -> 1, 4 -> 2, 4 -> 3}}
        expect_evaluated: {{1 -> 1, 1 -> 2, 1 -> 3}, {2 -> 1, 2 -> 2, 2 -> 3}, {3 -> 1, 3 -> 2, 3 -> 3}, {4 -> 1, 4 -> 2, 4 -> 3}}
    ...
ok  Flatten[%]    ==>     {1 -> 1, 1 -> 2, 1 -> 3, 2 -> 1, 2 -> 2, 2 -> 3, 3 -> 1, 3 -> 2, 3 -> 3, 4 -> 1, 4 -> 2, 4 -> 3} # skip
# Do a "transpose" on a ragged array:
ok  list = Table[i + j - 1, {i, 4}, {j, i}]    ==>     {{1}, {2, 3}, {3, 4, 5}, {4, 5, 6, 7}}
    ---
    data:
        got: {{1}, {2, 3}, {3, 4, 5}, {4, 5, 6, 7}}
        expect: {{1}, {2, 3}, {3, 4, 5}, {4, 5, 6, 7}}
        expect_evaluated: {{1}, {2, 3}, {3, 4, 5}, {4, 5, 6, 7}}
    ...
ok  Flatten[list, {{2}, {1}}]    ==>     {{1, 2, 3, 4}, {3, 4, 5}, {5, 6}, {7}}
    ---
    data:
        got: {{1, 2, 3, 4}, {3, 4, 5}, {5, 6}, {7}}
        expect: {{1, 2, 3, 4}, {3, 4, 5}, {5, 6}, {7}}
        expect_evaluated: {{1, 2, 3, 4}, {3, 4, 5}, {5, 6}, {7}}
    ...
# RefLink[Flatten,paclet:ref/Flatten] acts as an inverse of RefLink[Partition,paclet:ref/Partition]:
ok  Range[20]    ==>     {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
    ---
    data:
        got: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
        expect: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
        expect_evaluated: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
    ...
ok  Partition[%, 4]    ==>     {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}, {17, 18, 19, 20}} # skip
ok  Flatten[%]    ==>     {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20} # skip
# RefLink[ArrayReshape,paclet:ref/ArrayReshape] acts as an inverse for RefLink[Flatten,paclet:ref/Flatten] on rectangular arrays:
ok  array = RandomInteger[9, {3, 2, 4}]    ==>     {{{5, 2, 3, 7}, {8, 6, 5, 9}}, {{1, 1, 4, 5}, {0, 9, 3, 7}}, {{2, 0, 1, 3}, {3, 4, 3, 6}}} # skip
ok  Flatten[array]    ==>     {5, 2, 3, 7, 8, 6, 5, 9, 1, 1, 4, 5, 0, 9, 3, 7, 2, 0, 1, 3, 3, 4, 3, 6} # skip
ok  ArrayReshape[%, {3, 2, 4}]    ==>     {{{5, 2, 3, 7}, {8, 6, 5, 9}}, {{1, 1, 4, 5}, {0, 9, 3, 7}}, {{2, 0, 1, 3}, {3, 4, 3, 6}}} # skip
# RefLink[Flatten,paclet:ref/Flatten] effectively arranges elements in the lexicographic order of their indices:
ok  Flatten[Array[a, {3, 4}]]    ==>     {a[1, 1], a[1, 2], a[1, 3], a[1, 4], a[2, 1], a[2, 2], a[2, 3], a[2, 4], a[3, 1], a[3, 2], a[3, 3], a[3, 4]}
    ---
    data:
        got: {a[1, 1], a[1, 2], a[1, 3], a[1, 4], a[2, 1], a[2, 2], a[2, 3], a[2, 4], a[3, 1], a[3, 2], a[3, 3], a[3, 4]}
        expect: {a[1, 1], a[1, 2], a[1, 3], a[1, 4], a[2, 1], a[2, 2], a[2, 3], a[2, 4], a[3, 1], a[3, 2], a[3, 3], a[3, 4]}
        expect_evaluated: {a[1, 1], a[1, 2], a[1, 3], a[1, 4], a[2, 1], a[2, 2], a[2, 3], a[2, 4], a[3, 1], a[3, 2], a[3, 3], a[3, 4]}
    ...
ok  Flatten[Array[100*#1 + 10*#2 + #3 & , {3, 3, 3}]]    ==>     {111, 112, 113, 121, 122, 123, 131, 132, 133, 211, 212, 213, 221, 222, 223, 231, 232, 233, 311, 312, 313, 321, 322, 323, 331, 332, 333}
    ---
    data:
        got: {111, 112, 113, 121, 122, 123, 131, 132, 133, 211, 212, 213, 221, 222, 223, 231, 232, 233, 311, 312, 313, 321, 322, 323, 331, 332, 333}
        expect: {111, 112, 113, 121, 122, 123, 131, 132, 133, 211, 212, 213, 221, 222, 223, 231, 232, 233, 311, 312, 313, 321, 322, 323, 331, 332, 333}
        expect_evaluated: {111, 112, 113, 121, 122, 123, 131, 132, 133, 211, 212, 213, 221, 222, 223, 231, 232, 233, 311, 312, 313, 321, 322, 323, 331, 332, 333}
    ...
# A random permutation:
ok  p = RandomSample[Range[4]]    ==>     {4, 2, 3, 1} # skip
# Get its inverse:
ok  invp = p; invp[[p]] = Range[4]; invp    ==>     {4, 2, 3, 1} # skip
ok  Flatten[list, List /@ invp] == Transpose[list, p]    ==>     True # skip
# Peel off successive layers of RefLink[Framed,paclet:ref/Framed]:
ok  NestList[Flatten[#1, 1] & , Nest[Framed, x, 6], 10]    ==>     {x, x, x, x, x, x, x, x, x, x, x} # skip
