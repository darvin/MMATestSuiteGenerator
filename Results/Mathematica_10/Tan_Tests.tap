#! DOCKER > wolfram -script output/Tests/Tan_Tests.m
#! TextForm[ColonForm[MessageName[N, meprec], StringForm[Internal precision limit $MaxExtraPrecision = `1` reached while evaluating `2`., Short[HoldForm[50.], 3], Short[HoldForm[Tan[10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: Tan_Tests
# The argument is given in radians:
ok  Tan[Pi/6]    ==>     1/Sqrt[3]
    ---
    data:
        got: 1/Sqrt[3]
        expect: 1/Sqrt[3]
        expect_evaluated: 1/Sqrt[3]
    ...
# Use RefLink[Degree,paclet:ref/Degree] to specify an argument in degrees:
ok  Tan[30*Degree]    ==>     1/Sqrt[3]
    ---
    data:
        got: 1/Sqrt[3]
        expect: 1/Sqrt[3]
        expect_evaluated: 1/Sqrt[3]
    ...
ok  HoldComplete[Plot[Tan[x], {x, 0, 2*Pi}]]    ==>     $Failed # skip
ok  Series[Tan[x], {x, 0, 10}]    ==>     x + x^3/3 + (2*x^5)/15 + (17*x^7)/315 + (62*x^9)/2835 + O[x]^11
    ---
    data:
        got: SeriesData[x, 0, {1, 0, 1/3, 0, 2/15, 0, 17/315, 0, 62/2835}, 1, 11, 1]
        expect: x + x^3/3 + (2*x^5)/15 + (17*x^7)/315 + (62*x^9)/2835 + O[x]^11
        expect_evaluated: SeriesData[x, 0, {1, 0, 1/3, 0, 2/15, 0, 17/315, 0, 62/2835}, 1, 11, 1]
    ...
# Evaluate numerically:
ok  Tan[1.2]    ==>     2.57215 # skip
# Evaluate to high precision:
ok  N[Tan[12/10], 50]    ==>     2.5721516221263189354099942360333639565294093060434`49.41029656561764
    ---
    data:
        got: 2.572151622126318935409994236033363956529409306043389279225637262239`50.
        expect: 2.5721516221263189354099942360333639565294093060434`49.41029656561764
        expect_evaluated: 2.5721516221263189354099942360333639565294093060434`49.41029656561764
    ...
# The precision of the output tracks the precision of the input:
ok  Tan[1.2`23.07918124604763]    ==>     2.57215162212631893541`22.41029656561764
    ---
    data:
        got: 2.57215162212631893540999423603336393864`22.52857168497864
        expect: 2.57215162212631893541`22.41029656561764
        expect_evaluated: 2.57215162212631893541`22.41029656561764
    ...
# The precision of the output can be much smaller than the precision of the input:
ok  Tan[1.5707963267948966192213216916397514421`37.196119877030156]    ==>     1.*10^20
    ---
    data:
        got: 1.00000000000000000014153003119`17.*^20
        expect: 1.*10^20
        expect_evaluated: 1.*^20
    ...
# RefLink[Tan,paclet:ref/Tan] threads element-wise over lists and matrices:
ok  Tan[{1.2, 1.5, 1.8}]    ==>     {2.57215, 14.1014, -4.28626} # skip
ok  Tan[Pi*u*v*(Pi/3)]    ==>     {{0, Tan[u]}, {Tan[v], Sqrt[3]}} # skip
# RefLink[Tan,paclet:ref/Tan] can take complex number inputs:
ok  Tan[2.5 + I]    ==>     -0.237014 + 0.896438*I # skip
# Simple exact values are generated automatically:
ok  Tan[Pi/5]    ==>     Sqrt[5 - 2*Sqrt[5]]
    ---
    data:
        got: Sqrt[5 - 2*Sqrt[5]]
        expect: Sqrt[5 - 2*Sqrt[5]]
        expect_evaluated: Sqrt[5 - 2*Sqrt[5]]
    ...
# More complicated cases require explicit use of RefLink[FunctionExpand,paclet:ref/FunctionExpand]:
ok  Tan[Pi/8]    ==>     Tan[Pi/8]
    ---
    data:
        got: Tan[Pi/8]
        expect: Tan[Pi/8]
        expect_evaluated: Tan[Pi/8]
    ...
ok  FunctionExpand[%]    ==>     Sqrt[(2 - Sqrt[2])/(2 + Sqrt[2])] # skip
# Convert multiple-angle expressions:
ok  TrigExpand[Tan[4*x]]    ==>     (4*Cos[x]^3*Sin[x])/(Cos[x]^4 - 6*Cos[x]^2*Sin[x]^2 + Sin[x]^4) - (4*Cos[x]*Sin[x]^3)/(Cos[x]^4 - 6*Cos[x]^2*Sin[x]^2 + Sin[x]^4)
    ---
    data:
        got: (4*Cos[x]^3*Sin[x])/(Cos[x]^4 - 6*Cos[x]^2*Sin[x]^2 + Sin[x]^4) - (4*Cos[x]*Sin[x]^3)/(Cos[x]^4 - 6*Cos[x]^2*Sin[x]^2 + Sin[x]^4)
        expect: (4*Cos[x]^3*Sin[x])/(Cos[x]^4 - 6*Cos[x]^2*Sin[x]^2 + Sin[x]^4) - (4*Cos[x]*Sin[x]^3)/(Cos[x]^4 - 6*Cos[x]^2*Sin[x]^2 + Sin[x]^4)
        expect_evaluated: (4*Cos[x]^3*Sin[x])/(Cos[x]^4 - 6*Cos[x]^2*Sin[x]^2 + Sin[x]^4) - (4*Cos[x]*Sin[x]^3)/(Cos[x]^4 - 6*Cos[x]^2*Sin[x]^2 + Sin[x]^4)
    ...
ok  TrigReduce[%]    ==>     Tan[4*x] # skip
# Convert sums of trigonometric functions to products:
ok  TrigFactor[Tan[x] + Tan[y]]    ==>     Sec[x]*Sec[y]*Sin[x + y]
    ---
    data:
        got: Sec[x]*Sec[y]*Sin[x + y]
        expect: Sec[x]*Sec[y]*Sin[x + y]
        expect_evaluated: Sec[x]*Sec[y]*Sin[x + y]
    ...
# Expand assuming real variables:
ok  ComplexExpand[Tan[x + I*y]]    ==>     Sin[2*x]/(Cos[2*x] + Cosh[2*y]) + (I*Sinh[2*y])/(Cos[2*x] + Cosh[2*y])
    ---
    data:
        got: Sin[2*x]/(Cos[2*x] + Cosh[2*y]) + (I*Sinh[2*y])/(Cos[2*x] + Cosh[2*y])
        expect: Sin[2*x]/(Cos[2*x] + Cosh[2*y]) + (I*Sinh[2*y])/(Cos[2*x] + Cosh[2*y])
        expect_evaluated: Sin[2*x]/(Cos[2*x] + Cosh[2*y]) + (I*Sinh[2*y])/(Cos[2*x] + Cosh[2*y])
    ...
# Convert to complex exponentials:
ok  TrigToExp[Tan[z]]    ==>     (I*(E^((-I)*z) - E^(I*z)))/(E^((-I)*z) + E^(I*z))
    ---
    data:
        got: (I*(E^((-I)*z) - E^(I*z)))/(E^((-I)*z) + E^(I*z))
        expect: (I*(E^((-I)*z) - E^(I*z)))/(E^((-I)*z) + E^(I*z))
        expect_evaluated: (I*(E^((-I)*z) - E^(I*z)))/(E^((-I)*z) + E^(I*z))
    ...
# RefLink[Tan,paclet:ref/Tan] can deal with real-valued intervals:
ok  Tan[Interval[{0, Pi/3}]]    ==>     Interval[{0, Sqrt[3]}]
    ---
    data:
        got: Interval[{0, Sqrt[3]}]
        expect: Interval[{0, Sqrt[3]}]
        expect_evaluated: Interval[{0, Sqrt[3]}]
    ...
# Infinite arguments give symbolic results:
ok  Tan[Infinity]    ==>     Interval[{-Infinity, Infinity}]
    ---
    data:
        got: Interval[{-Infinity, Infinity}]
        expect: Interval[{-Infinity, Infinity}]
        expect_evaluated: Interval[{-Infinity, Infinity}]
    ...
ok  Tan[ComplexInfinity]    ==>     Indeterminate
    ---
    data:
        got: Indeterminate
        expect: Indeterminate
        expect_evaluated: Indeterminate
    ...
# RefLink[Tan,paclet:ref/Tan] can be applied to power series:
ok  Tan[Pi/2 + x + x^2/2 + x^3/3 + O[x]^4]    ==>     -(1/x) + 1/2 + (5*x)/12 + O[x]^2
    ---
    data:
        got: SeriesData[x, 0, {-1, 1/2, 5/12}, -1, 2, 1]
        expect: -(1/x) + 1/2 + (5*x)/12 + O[x]^2
        expect_evaluated: SeriesData[x, 0, {-1, 1/2, 5/12}, -1, 2, 1]
    ...
# RefLink[Tan,paclet:ref/Tan] threads element-wise over sparse arrays as well as lists: 
ok  HoldComplete[SparseArray[{{1, 1} -> Pi, {1, 3} -> Pi/3, {3, 3} -> Pi/12, {4, 2} -> Pi/4}]]    ==>     $Failed # skip
ok  HoldComplete[Tan[%]]    ==>     $Failed # skip
ok  MatrixForm[%]    ==>     0*0*Sqrt[3]*0*0*0*0*0*2 - Sqrt[3]*0*1*0 # skip
# Generate a plot with poles removed:
ok  HoldComplete[Plot[Tan[x], {x, 0, 20}, Exclusions -> {Cos[x] == 0}]]    ==>     $Failed # skip
# Generate a plot over the complex argument plane:
ok  HoldComplete[Plot3D[Re[Tan[x + I*y]], {x, 0, 2*Pi}, {y, 0, 3}]]    ==>     $Failed # skip
# Differential equation solution with a movable singularity:
ok  DSolve[(w^,)[z] - w[z]^2 - 1 == 0, w[z], z]    ==>     {{w[z] -> Tan[z + C[1]]}} # skip
# The tangent function conformally maps a parabola into the unit disk:
ok  HoldComplete[parabola = Table[1 - x^2/4 + I*x, {x, 0, 20, 1/10}]; {Graphics[(Point[{Re[#1], Im[#1]}] & ) /@ parabola, AspectRatio -> 1, Axes -> True], Graphics[(Point[{Re[#1], Im[#1]}] & ) /@ (Tan[(Pi/4.)*Sqrt[parabola]]^2), PlotRange -> All, Axes -> True]}]    ==>     $Failed # skip
# Pursuit curve in the reference frame of the predator with prey moving half as fast along a line:
ok  s = FullSimplify[DSolve[{Derivative[1][\[ScriptL]][\[Phi]] == \[ScriptL][\[Phi]]*((Sin[\[Phi]] - 2)/Cos[\[Phi]]), \[ScriptL][0] == 1}, \[ScriptL][\[Phi]], \[Phi]]]    ==>     {{\[ScriptL][\[Phi]] -> (Sec[\[Phi]] - Tan[\[Phi]])/(1 + Sin[\[Phi]])}}
    ---
    data:
        got: {{\[ScriptL][\[Phi]] -> (Sec[\[Phi]] - Tan[\[Phi]])/(1 + Sin[\[Phi]])}}
        expect: {{\[ScriptL][\[Phi]] -> (Sec[\[Phi]] - Tan[\[Phi]])/(1 + Sin[\[Phi]])}}
        expect_evaluated: {{\[ScriptL][\[Phi]] -> (Sec[\[Phi]] - Tan[\[Phi]])/(1 + Sin[\[Phi]])}}
    ...
ok  HoldComplete[PolarPlot[\[ScriptL][\[Phi]] /. s, {\[Phi], 0, Pi/2}, AspectRatio -> 1]]    ==>     $Failed # skip
# Basic parity and periodicity properties of the tangent function get automatically applied:
ok  Tan[x + 2*Pi]    ==>     Tan[x]
    ---
    data:
        got: Tan[x]
        expect: Tan[x]
        expect_evaluated: Tan[x]
    ...
ok  Tan[-x]    ==>     -Tan[x]
    ---
    data:
        got: -Tan[x]
        expect: -Tan[x]
        expect_evaluated: -Tan[x]
    ...
ok  Tan[I*x]    ==>     I*Tanh[x]
    ---
    data:
        got: I*Tanh[x]
        expect: I*Tanh[x]
        expect_evaluated: I*Tanh[x]
    ...
ok  1/Tan[x]    ==>     Cot[x]
    ---
    data:
        got: Cot[x]
        expect: Cot[x]
        expect_evaluated: Cot[x]
    ...
# Use RefLink[TrigFactorList,paclet:ref/TrigFactorList] to factor RefLink[Tan,paclet:ref/Tan] into RefLink[Sin,paclet:ref/Sin] and RefLink[Cos,paclet:ref/Cos]:
ok  Sin[x]/Cos[x]    ==>     Tan[x]
    ---
    data:
        got: Tan[x]
        expect: Tan[x]
        expect_evaluated: Tan[x]
    ...
ok  TrigFactorList[Tan[x]]    ==>     {{1, 1}, {Sin[x], 1}, {Cos[x], -1}}
    ---
    data:
        got: {{1, 1}, {Sin[x], 1}, {Cos[x], -1}}
        expect: {{1, 1}, {Sin[x], 1}, {Cos[x], -1}}
        expect_evaluated: {{1, 1}, {Sin[x], 1}, {Cos[x], -1}}
    ...
# Complicated expressions containing trigonometric functions do not simplify automatically:
ok  Tan[z] + Cot[z]    ==>     Cot[z] + Tan[z]
    ---
    data:
        got: Cot[z] + Tan[z]
        expect: Cot[z] + Tan[z]
        expect_evaluated: Cot[z] + Tan[z]
    ...
ok  Simplify[%]    ==>     Csc[z]*Sec[z] # skip
# Simplify under assumptions on parameters:
ok  Tan[-x + k*Pi]    ==>     Tan[k*Pi - x]
    ---
    data:
        got: Tan[k*Pi - x]
        expect: Tan[k*Pi - x]
        expect_evaluated: Tan[k*Pi - x]
    ...
ok  Simplify[%, Element[k, Integers]]    ==>     -Tan[x] # skip
# Compose with inverse functions:
ok  {Tan[ArcTan[z]], Tan[2*ArcTan[z]], Tan[3*ArcTan[z]], Tan[4*ArcTan[z]]}    ==>     {z, Tan[2*ArcTan[z]], Tan[3*ArcTan[z]], Tan[4*ArcTan[z]]}
    ---
    data:
        got: {z, Tan[2*ArcTan[z]], Tan[3*ArcTan[z]], Tan[4*ArcTan[z]]}
        expect: {z, Tan[2*ArcTan[z]], Tan[3*ArcTan[z]], Tan[4*ArcTan[z]]}
        expect_evaluated: {z, Tan[2*ArcTan[z]], Tan[3*ArcTan[z]], Tan[4*ArcTan[z]]}
    ...
ok  Together[FunctionExpand[%]]    ==>     {z, -((2*z)/(-1 + z^2)), (-3*z + z^3)/(-1 + 3*z^2), -((4*(-z + z^3))/(1 - 6*z^2 + z^4))} # skip
# Solve a trigonometric equation:
ok  Reduce[Tan[z]^2 - 2*Tan[z + Pi/4] == 4, z]    ==>     Element[C[1], Integers] && (z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 1]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 2]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 3]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 4]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 5]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 6]] + 2*Pi*C[1])
    ---
    data:
        got: Element[C[1], Integers] && (z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 1, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 2, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 3, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 4, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 5, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 6, 0]] + 2*Pi*C[1])
        expect: Element[C[1], Integers] && (z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 1]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 2]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 3]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 4]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 5]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 6]] + 2*Pi*C[1])
        expect_evaluated: Element[C[1], Integers] && (z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 1, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 2, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 3, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 4, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 5, 0]] + 2*Pi*C[1] || z == 2*ArcTan[Root[-3 + 2*#1 + 11*#1^2 - 8*#1^3 - 11*#1^4 + 2*#1^5 + 3*#1^6 & , 6, 0]] + 2*Pi*C[1])
    ...
# Solve for zeros and poles: 
ok  Reduce[Tan[\[Alpha]*x + \[Beta]] == 0, x]    ==>     Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi*C[1]) || (\[Alpha] != 0 && x == (-\[Beta] + Pi*C[1])/\[Alpha]))
    ---
    data:
        got: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi*C[1]) || (\[Alpha] != 0 && x == (-\[Beta] + Pi*C[1])/\[Alpha]))
        expect: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi*C[1]) || (\[Alpha] != 0 && x == (-\[Beta] + Pi*C[1])/\[Alpha]))
        expect_evaluated: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi*C[1]) || (\[Alpha] != 0 && x == (-\[Beta] + Pi*C[1])/\[Alpha]))
    ...
ok  Reduce[1/Tan[\[Alpha]*x + \[Beta]] == 0, x]    ==>     Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi/2 + Pi*C[1]) || (\[Alpha] != 0 && x == (Pi/2 - \[Beta] + Pi*C[1])/\[Alpha]))
    ---
    data:
        got: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi/2 + Pi*C[1]) || (\[Alpha] != 0 && x == (Pi/2 - \[Beta] + Pi*C[1])/\[Alpha]))
        expect: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi/2 + Pi*C[1]) || (\[Alpha] != 0 && x == (Pi/2 - \[Beta] + Pi*C[1])/\[Alpha]))
        expect_evaluated: Element[C[1], Integers] && ((\[Alpha] == 0 && \[Beta] == Pi/2 + Pi*C[1]) || (\[Alpha] != 0 && x == (Pi/2 - \[Beta] + Pi*C[1])/\[Alpha]))
    ...
# Numerically find a root of a transcendental equation:
ok  FindRoot[Tan[z]^2 + 3*Tan[z + Pi/6] + z == 4, {z, 2}]    ==>     {z -> 2.03816} # skip
# Integrals:
ok  Integrate[Tan[z]^a, z]    ==>     (Hypergeometric2F1[(1 + a)/2, 1, 1 + (1 + a)/2, -Tan[z]^2]*Tan[z]^(1 + a))/(1 + a)
    ---
    data:
        got: (Hypergeometric2F1[1, (1 + a)/2, 1 + (1 + a)/2, -Tan[z]^2]*Tan[z]^(1 + a))/(1 + a)
        expect: (Hypergeometric2F1[(1 + a)/2, 1, 1 + (1 + a)/2, -Tan[z]^2]*Tan[z]^(1 + a))/(1 + a)
        expect_evaluated: (Hypergeometric2F1[1, (1 + a)/2, 1 + (1 + a)/2, -Tan[z]^2]*Tan[z]^(1 + a))/(1 + a)
    ...
# RefLink[Tan,paclet:ref/Tan] appears in special cases of many mathematical functions: 
ok  {MathieuS[1, 0, z]/MathieuC[1, 0, z], JacobiSC[z, 0], JacobiCS[Pi/2 - z, 0], JacobiSN[I*z, 1], JacobiNS[(Pi*I)/2 - I*z, 1], HypergeometricPFQ[{}, {3/2}, -z]/HypergeometricPFQ[{}, {1/2}, -z], MeijerG[{{}, {}}, {{1/2}, {0}}, z]/MeijerG[{{}, {}}, {{-(1/2)}, {0}}, z]}    ==>     {Tan[z], Tan[z], Tan[z], I*Tan[z], (-I)*Tan[z], Tan[2*Sqrt[z]]/(2*Sqrt[z]), Sqrt[z]*Tan[2*Sqrt[z]]}
    ---
    data:
        got: {Tan[z], Tan[z], Tan[z], I*Tan[z], (-I)*Tan[z], Tan[2*Sqrt[z]]/(2*Sqrt[z]), Sqrt[z]*Tan[2*Sqrt[z]]}
        expect: {Tan[z], Tan[z], Tan[z], I*Tan[z], (-I)*Tan[z], Tan[2*Sqrt[z]]/(2*Sqrt[z]), Sqrt[z]*Tan[2*Sqrt[z]]}
        expect_evaluated: {Tan[z], Tan[z], Tan[z], I*Tan[z], (-I)*Tan[z], Tan[2*Sqrt[z]]/(2*Sqrt[z]), Sqrt[z]*Tan[2*Sqrt[z]]}
    ...
# Calculate residue symbolically and numerically: 
ok  Table[Residue[Tan[z]^k, {z, Pi/2}], {k, 5}]    ==>     {-1, 0, 1, 0, -1}
    ---
    data:
        got: {-1, 0, 1, 0, -1}
        expect: {-1, 0, 1, 0, -1}
        expect_evaluated: {-1, 0, 1, 0, -1}
    ...
ok  (1/(2*Pi*I))*NIntegrate[Tan[z], {z, Pi/2 - 1/4, Pi/2 - I/4, Pi/2 + 1/4, Pi/2 + I/4, Pi/2 - 1/4}]    ==>     -1. + 0.*I # skip
# RefLink[Tan,paclet:ref/Tan] is a numeric function:
ok  Attributes[Tan]    ==>     {Listable, NumericFunction, Protected}
    ---
    data:
        got: {Listable, NumericFunction, Protected}
        expect: {Listable, NumericFunction, Protected}
        expect_evaluated: {Listable, NumericFunction, Protected}
    ...
ok  NumericQ[Tan[2 + E]]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
# Machine-precision input is insufficient to give a correct answer:
ok  Tan[10.^30]    ==>     -1.15589 # skip
# With exact input, the answer is correct:
ok  N[Tan[10^30], 20]    ==>     0.090485068063302172566`19.95657691740685
    ---
    data:
        got: 0.09048506806330217256622313805004127349`20.
        expect: 0.090485068063302172566`19.95657691740685
        expect_evaluated: 0.090485068063302172566`19.95657691740685
    ...
# A larger setting for RefLink[$MaxExtraPrecision,paclet:ref/$MaxExtraPrecision] is needed:
ok  N[Tan[10^100], 20]    ==>     ComplexInfinity
    ---
    data:
        got: ComplexInfinity
        expect: ComplexInfinity
        expect_evaluated: ComplexInfinity
    ...
ok  Block[{$MaxExtraPrecision = 200}, N[Tan[10^100], 20]]    ==>     0.40123196199081435419`19.603395521465412
    ---
    data:
        got: 0.40123196199081435418575434365329495832`20.
        expect: 0.40123196199081435419`19.603395521465412
        expect_evaluated: 0.40123196199081435419`19.603395521465412
    ...
# In traditional form parentheses are needed around the argument:
ok  tan*x    ==>     tan*x
    ---
    data:
        got: tan*x
        expect: tan*x
        expect_evaluated: tan*x
    ...
ok  tan*x    ==>     Tan[x] # skip
ok  $Failed    ==>     HoldComplete[Cot[z]*Csc[n*(Pi/2 + z)]*Sin[n*z]] # skip
ok  Integrate[Tan[ArcCot[z]], z]    ==>     Log[z]
    ---
    data:
        got: Log[z]
        expect: Log[z]
        expect_evaluated: Log[z]
    ...
# Plot RefLink[Tan,paclet:ref/Tan] at integer points:
ok  HoldComplete[ArrayPlot[Table[ArcTan[Abs[Tan[x*y]]], {x, -20, 20}, {y, -20, 20}]]]    ==>     $Failed # skip
ok  FunctionExpand[Tan[Pi/2^12]]    ==>     Sqrt[(2 - Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])/(2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])]
    ---
    data:
        got: Sqrt[(2 - Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])/(2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])]
        expect: Sqrt[(2 - Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])/(2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])]
        expect_evaluated: Sqrt[(2 - Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])/(2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2 + Sqrt[2]]]]]]]]]])]
    ...
# The continued fraction is highly regular:
ok  ContinuedFraction[Tan[1], 22]    ==>     {1, 1, 1, 3, 1, 5, 1, 7, 1, 9, 1, 11, 1, 13, 1, 15, 1, 17, 1, 19, 1, 21}
    ---
    data:
        got: {1, 1, 1, 3, 1, 5, 1, 7, 1, 9, 1, 11, 1, 13, 1, 15, 1, 17, 1, 19, 1, 21}
        expect: {1, 1, 1, 3, 1, 5, 1, 7, 1, 9, 1, 11, 1, 13, 1, 15, 1, 17, 1, 19, 1, 21}
        expect_evaluated: {1, 1, 1, 3, 1, 5, 1, 7, 1, 9, 1, 11, 1, 13, 1, 15, 1, 17, 1, 19, 1, 21}
    ...
ok  Element[Tan[1], Algebraics]    ==>     False
    ---
    data:
        got: False
        expect: False
        expect_evaluated: False
    ...
ok  HoldComplete[Plot3D[Tan[y^2 - x^3 + 3*x - 3], {x, -2, 2}, {y, -2, 2}, Exclusions -> {Cos[y^2 - x^3 + 3*x - 3] == 0}, PlotPoints -> 30, Mesh -> None]]    ==>     $Failed # skip
