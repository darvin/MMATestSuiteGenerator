#! DOCKER > wolfram -script output/Tests/BlankSequence_Tests.m
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: BlankSequence_Tests
# A function definition that works with any nonzero number of arguments:
ok  f[x__] := Length[{x}]; {f[x, y, z], f[]}    ==>     {3, f[]}
    ---
    data:
        got: {3, f[]}
        expect: {3, f[]}
        expect_evaluated: {3, f[]}
    ...
# A function definition that works with any nonzero number of real arguments:
ok  f[x__Real] := (Plus[x])/Length[{x}]; {f[1., N[Pi]], f[1, N[Pi]]}    ==>     {2.0708, f[1, 3.14159]}
    ---
    data:
        got: {2.0708, 2}
        expect: {2.0708, f[1, 3.14159]}
        expect_evaluated: {2.0708, 2}
    ...
# A function definition for a symbol followed by any nonzero number of integer arguments:
ok  f[x_Symbol, p__Integer] := Plus @@ (x^{p}); {f[x, 1, 2], f[0, 1, 2], f[x, 1, 2.]}    ==>     {x + x^2, f[0, 1, 2], f[x, 1, 2.]}
    ---
    data:
        got:       2
#! {x + x , 3, 3}
        expect: {x + x^2, f[0, 1, 2], f[x, 1, 2.]}
        expect_evaluated:       2
#! {x + x , 3, 3}
    ...
