#! DOCKER > wolfram -script output/Tests/Min_Tests.m
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
#! TextForm[ColonForm[MessageName[$RecursionLimit, reclim], StringForm[Recursion depth of `1` exceeded., Short[HoldForm[1024], 3]]]]
#! TextForm[ColonForm[MessageName[$RecursionLimit, reclim], StringForm[Recursion depth of `1` exceeded., Short[HoldForm[1024], 3]]]]
#! TextForm[ColonForm[MessageName[$RecursionLimit, reclim], StringForm[Recursion depth of `1` exceeded., Short[HoldForm[1024], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$RecursionLimit, reclim]], 3]]]]
#! TextForm[ColonForm[MessageName[Piecewise, pairs], StringForm[The first argument `1` of Piecewise is not a list of pairs., Short[HoldForm[-1], 3]]]]
#! TextForm[ColonForm[MessageName[Last, nolast], StringForm[`1` has a length of zero and no last element., Short[HoldForm[{}], 3]]]]
#! TextForm[ColonForm[MessageName[Piecewise, pairs], StringForm[The first argument `1` of Piecewise is not a list of pairs., Short[HoldForm[x], 3]]]]
#! TextForm[ColonForm[MessageName[Piecewise, pairs], StringForm[The first argument `1` of Piecewise is not a list of pairs., Short[HoldForm[2], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[Piecewise, pairs]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: Min_Tests
# Minimum of two numbers:
ok  Min[9, 2]    ==>     2
    ---
    data:
        got: 2
        expect: 2
        expect_evaluated: 2
    ...
# Minimum of a list:
ok  Min[{4, 1, 7, 2}]    ==>     1
    ---
    data:
        got: 1
        expect: 1
        expect_evaluated: 1
    ...
# RefLink[Min,paclet:ref/Min] works with exact numeric quantities:
ok  Min[{Pi, E, Sqrt[2]}]    ==>     Sqrt[2]
    ---
    data:
        got: Sqrt[2]
        expect: Sqrt[2]
        expect_evaluated: Sqrt[2]
    ...
# RefLink[Min,paclet:ref/Min] effectively flattens out all lists:
ok  Min[{3, 4, 1}, {2, 2}, 7]    ==>     1
    ---
    data:
        got: 1
        expect: 1
        expect_evaluated: 1
    ...
# The minimum of all elements of a matrix:
ok  mat = {{-1, 0, 1, 2}, {0, 2, 4, 6}, {-3, -2, -1, 0}} ;; Min[mat]    ==>     -3 # skip
# The minima of all rows:
ok  Min /@ mat    ==>     {-1, 0, -3} # skip
# The minima of all columns:
ok  Min /@ Transpose[mat]    ==>     {-3, -2, -1, 0} # skip
# Basic symbolic simplification is done automatically:
ok  Min[x, y, Min[x, z]]    ==>     Min[x, y, z]
    ---
    data:
        got: Min[x, y, z]
        expect: Min[x, y, z]
        expect_evaluated: Min[x, y, z]
    ...
# Simplify a symbolic RefLink[Min,paclet:ref/Min]:
ok  Simplify[Min[1 - x, x, 1 + x]]    ==>     Min[1 - x, x]
    ---
    data:
        got: Min[1 - x, x]
        expect: Min[1 - x, x]
        expect_evaluated: Min[1 - x, x]
    ...
# Integrate expressions involving RefLink[Min,paclet:ref/Min]:
ok  FullSimplify[Integrate[Min[Sin[x], Cos[x]], {x, 0, Pi}]]    ==>     1 - Sqrt[2]
    ---
    data:
        got: 1 - Sqrt[2]
        expect: 1 - Sqrt[2]
        expect_evaluated: 1 - Sqrt[2]
    ...
ok  Integrate[Exp[Min[x, a - x]], {x, 0, 1}]    ==>     Inequality[Piecewise[-1] + E*a, GreaterEqual, 2*(-1 + E)*E^(-1 + a)*a, LessEqual, 0*((-E + 2*E^(1 + a/2) - E^a)/E)*True] # skip
ok  HoldComplete[Plot[Min[Sin[x], Cos[x]], {x, 0, 2*Pi}, PlotRange -> All]]    ==>     $Failed # skip
# Reduce inequalities involving RefLink[Min,paclet:ref/Min]:
ok  Reduce[{Min[Sin[x], Cos[x]] > 0, 0 < x < 20}, x]    ==>     0 < x < Pi/2 || 2*Pi < x < (5*Pi)/2 || 4*Pi < x < (9*Pi)/2 || 6*Pi < x < 20
    ---
    data:
        got:         Pi               5 Pi               9 Pi
#! 0 < x < -- || 2 Pi < x < ---- || 4 Pi < x < ---- || 6 Pi < x < 20
        2                 2                  2
        expect: 0 < x < Pi/2 || 2*Pi < x < (5*Pi)/2 || 4*Pi < x < (9*Pi)/2 || 6*Pi < x < 20
        expect_evaluated:         Pi               5 Pi               9 Pi
#! 0 < x < -- || 2 Pi < x < ---- || 4 Pi < x < ---- || 6 Pi < x < 20
        2                 2                  2
    ...
# RefLink[Min,paclet:ref/Min] works on sparse arrays:
ok  Min[SparseArray[{1 -> x, 2 -> y}, 10]]    ==>     Min[0, x, y]
    ---
    data:
        got: Min[0, x, y]
        expect: Min[0, x, y]
        expect_evaluated: Min[0, x, y]
    ...
# Use in bounds of iterator variables:
ok  Table[i*j*k, {i, 3}, {j, 3}, {k, Min[i, j], 3}]    ==>     {{{1, 2, 3}, {2, 4, 6}, {3, 6, 9}}, {{2, 4, 6}, {8, 12}, {12, 18}}, {{3, 6, 9}, {12, 18}, {27}}}
    ---
    data:
        got: {{{1, 2, 3}, {2, 4, 6}, {3, 6, 9}}, {{2, 4, 6}, {8, 12}, {12, 18}}, {{3, 6, 9}, {12, 18}, {27}}}
        expect: {{{1, 2, 3}, {2, 4, 6}, {3, 6, 9}}, {{2, 4, 6}, {8, 12}, {12, 18}}, {{3, 6, 9}, {12, 18}, {27}}}
        expect_evaluated: {{{1, 2, 3}, {2, 4, 6}, {3, 6, 9}}, {{2, 4, 6}, {8, 12}, {12, 18}}, {{3, 6, 9}, {12, 18}, {27}}}
    ...
# Cumulative minima:
ok  Rest[FoldList[Min, Infinity, {10, 18, 16, 22, 12, 30, 6, 24, 24, 2}]]    ==>     {10, 10, 10, 10, 10, 10, 6, 6, 6, 2}
    ---
    data:
        got: {10, 10, 10, 10, 10, 10, 6, 6, 6, 2}
        expect: {10, 10, 10, 10, 10, 10, 6, 6, 6, 2}
        expect_evaluated: {10, 10, 10, 10, 10, 10, 6, 6, 6, 2}
    ...
# Find the lowest point of a plotted curve:
ok  HoldComplete[Plot[Sin[x] + Sin[Sqrt[3]*x], {x, 0, 20*Pi}]]    ==>     $Failed # skip
ok  Min[Last /@ Level[Cases[%, _Line, Infinity], {-2}]]    ==>     -1.99914 # skip
# Mean of the length ratio of a randomly broken stick:
ok  Integrate[Min[x, 1 - x]/Max[x, 1 - x], {x, 0, 1}]    ==>     -1 + 2*Log[2]
    ---
    data:
        got: -1 + 2 Log[2]
        expect: -1 + 2*Log[2]
        expect_evaluated: -1 + 2 Log[2]
    ...
# R-function-based solid modeling:
ok  HoldComplete[RegionPlot3D[Min[x - y*z, y - z, x + z^2] > 0, {x, -3, 3}, {y, -3, 3}, {z, -3, 3}]]    ==>     $Failed # skip
ok  Min[]    ==>     Infinity
    ---
    data:
        got: Infinity
        expect: Infinity
        expect_evaluated: Infinity
    ...
# RefLink[Min,paclet:ref/Min] is RefLink[Flat,paclet:ref/Flat] and RefLink[Orderless,paclet:ref/Orderless]:
ok  Min[Min[z, y], x]    ==>     Min[x, y, z]
    ---
    data:
        got: Min[x, y, z]
        expect: Min[x, y, z]
        expect_evaluated: Min[x, y, z]
    ...
ok  PiecewiseExpand[Max[Min[x, y], z]]    ==>     Piecewise[x]*x - y <= 0 && x - z > 0*y*x - y > 0 && y - z > 0*z*True # skip
# Use RefLink[FullSimplify,paclet:ref/FullSimplify] to simplify RefLink[Min,paclet:ref/Min] expressions:
ok  FullSimplify[Max[x, y] - Min[-x, -y]]    ==>     Piecewise[2]*x*x >= y*2*y*True # skip
ok  FullSimplify[Min[x, y] - (x + 2*y - Sqrt[(x - y)^2])/2, Element[{x, y}, Reals]]    ==>     -(y/2)
    ---
    data:
        got: -y
#! --
#! 2
        expect: -(y/2)
        expect_evaluated: -y
#! --
#! 2
    ...
# Minimize a function containing RefLink[Min,paclet:ref/Min]:
ok  Minimize[Min[x^2 + 2*x + 2, x^4 - 3*x + 2], x]    ==>     {2 - (9*3^(1/3))/(4*2^(2/3)), {x -> 3^(1/3)/2^(2/3)}}
    ---
    data:
        got:         1/3         1/3
     9 3           3
#! {2 - ------, {x -> ----}}
        2/3         2/3
     4 2           2
        expect: {2 - (9*3^(1/3))/(4*2^(2/3)), {x -> 3^(1/3)/2^(2/3)}}
        expect_evaluated:         1/3         1/3
     9 3           3
#! {2 - ------, {x -> ----}}
        2/3         2/3
     4 2           2
    ...
# RefLink[Min,paclet:ref/Min] can be differentiated:
ok  Derivative[1][Min][x]    ==>     1
    ---
    data:
        got: 1
        expect: 1
        expect_evaluated: 1
    ...
ok  Derivative[1, 0][Min]    ==>     Piecewise[1]*#1 - #2 <= 0*0*True &  # skip
# RefLink[Min,paclet:ref/Min] flattens lists, rather than being RefLink[Listable,paclet:ref/Listable]:
ok  Min[{a, b}, {c, d}]    ==>     Min[a, b, c, d]
    ---
    data:
        got: Min[a, b, c, d]
        expect: Min[a, b, c, d]
        expect_evaluated: Min[a, b, c, d]
    ...
# One-argument form evaluates for any argument:
ok  Min[I]    ==>     I
    ---
    data:
        got: I
        expect: I
        expect_evaluated: I
    ...
# Two-dimensional sublevel sets: 
ok  HoldComplete[Table[RegionPlot[Min[x, y] < t, {x, -2, 2}, {y, -2, 2}, PlotLabel -> Min[x, y] < t], {t, {-1, 0, 1}}]]    ==>     $Failed # skip
ok  $Failed    ==>     $Failed # skip
# Three-dimensional sublevel sets: 
ok  HoldComplete[Table[RegionPlot3D[Min[x, y, z] < t, {x, -2, 2}, {y, -2, 2}, {z, -2, 2}, PlotLabel -> Min[x, y, z] < t], {t, {-1, 0, 1}}]]    ==>     $Failed # skip
ok  HoldComplete[Table[RegionPlot3D[Min[x, y, z] > t, {x, -2, 2}, {y, -2, 2}, {z, -2, 2}, PlotLabel -> Min[x, y, z] > t], {t, {-1, 0, 1}}]]    ==>     $Failed # skip
