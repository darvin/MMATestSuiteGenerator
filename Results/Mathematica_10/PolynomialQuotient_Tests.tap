#! DOCKER > wolfram -script output/Tests/PolynomialQuotient_Tests.m
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
#! TextForm[ColonForm[MessageName[Set, write], StringForm[Tag `1` in `2` is Protected., Short[HoldForm[Span], 3], Short[HoldForm[Span[{1 + 4*x + x^2, 2 + x}, q]], 3]]]]
#! TextForm[ColonForm[MessageName[Set, shape], StringForm[Lists `1` and `2` are not the same shape., Short[HoldForm[{f, g}], 3], Short[HoldForm[f/g], 3]]]]
#! TextForm[ColonForm[MessageName[Set, write], StringForm[Tag `1` in `2` is Protected., Short[HoldForm[Span], 3], Short[HoldForm[Span[{2 + 3*x + x^2, 6 + 5*x + x^2}, h]], 3]]]]
#! TextForm[ColonForm[MessageName[Set, shape], StringForm[Lists `1` and `2` are not the same shape., Short[HoldForm[{f, g}], 3], Short[HoldForm[1], 3]]]]
#! TextForm[ColonForm[MessageName[$RecursionLimit, reclim], StringForm[Recursion depth of `1` exceeded., Short[HoldForm[1024], 3]]]]
#! TextForm[ColonForm[MessageName[$RecursionLimit, reclim], StringForm[Recursion depth of `1` exceeded., Short[HoldForm[1024], 3]]]]
# SYSTEM: Mathematica_10
# TEST: PolynomialQuotient_Tests
# The quotient of x^2 by x+a, with the remainder dropped:
ok  PolynomialQuotient[x^2, x + a, x]    ==>     -a + x
    ---
    data:
        got: -a + x
        expect: -a + x
        expect_evaluated: -a + x
    ...
ok  Expand[%*(x + a)]    ==>     -a^2 + x^2 # skip
# The resulting polynomial will have coefficients that are rational expressions of input coefficients:
ok  PolynomialQuotient[x^2 + x + 1, 2*x + 1, x]    ==>     1/4 + x/2
    ---
    data:
        got: 1   x
#! - + -
#! 4   2
        expect: 1/4 + x/2
        expect_evaluated: 1   x
#! - + -
#! 4   2
    ...
ok  PolynomialQuotient[x^2 + b*x + 1, a*x + 1, x]    ==>     -(1/a^2) + b/a + x/a
    ---
    data:
        got:   -2   b   x
#! -a   + - + -
       a   a
        expect: -(1/a^2) + b/a + x/a
        expect_evaluated:   -2   b   x
#! -a   + - + -
       a   a
    ...
ok  PolynomialQuotient[x^2 + x + 1, Pi*x + 1, x]    ==>     -(1/Pi^2) + 1/Pi + x/Pi
    ---
    data:
        got:    -2   1    x
#! -Pi   + -- + --
        Pi   Pi
        expect: -(1/Pi^2) + 1/Pi + x/Pi
        expect_evaluated:    -2   1    x
#! -Pi   + -- + --
        Pi   Pi
    ...
# RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient] also works for rational functions:
ok  PolynomialQuotient[(x + 1)/(x + 2), (x + 1)/(x + 3), x]    ==>     (3 + x)/(2 + x)
    ---
    data:
        got: 3 + x
#! -----
#! 2 + x
        expect: (3 + x)/(2 + x)
        expect_evaluated: 3 + x
#! -----
#! 2 + x
    ...
# Use a prime modulus:
ok  PolynomialQuotient[x^2 + 4*x + 1, 2*x + 1, x, Modulus -> 2]    ==>     1 + x^2
    ---
    data:
        got:      2
#! 1 + x
        expect: 1 + x^2
        expect_evaluated:      2
#! 1 + x
    ...
ok  PolynomialQuotient[x^2 + 4*x + 1, 2*x + 1, x, Modulus -> 3]    ==>     1 + 2*x
    ---
    data:
        got: 1 + 2 x
        expect: 1 + 2*x
        expect_evaluated: 1 + 2 x
    ...
# For a polynomial f, f==gq+r, where r is given by RefLink[PolynomialRemainder,paclet:ref/PolynomialRemainder]:
ok  {f, g} = {x^2 + 4*x + 1, x + 2} ;; q = PolynomialQuotient[f, g, x]    ==>     2 + x # skip
ok  r = PolynomialRemainder[f, g, x]    ==>     -3 # skip
# Use RefLink[Expand,paclet:ref/Expand] to verify identity:
ok  Expand[q*g + r] == f    ==>     True # skip
# To get both quotient and remainder use RefLink[PolynomialQuotientRemainder,paclet:ref/PolynomialQuotientRemainder]:
ok  PolynomialQuotientRemainder[f, g, x]    ==>     {2 + x, -3} # skip
# RefLink[PolynomialReduce,paclet:ref/PolynomialReduce] generalizes RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient] for multivariate polynomials:
ok  PolynomialReduce[x^2 + 4*x + 1, {x + 2}, {x}]    ==>     {{2 + x}, -3}
    ---
    data:
        got: {{2 + x}, -3}
        expect: {{2 + x}, -3}
        expect_evaluated: {{2 + x}, -3}
    ...
# Use RefLink[PolynomialGCD,paclet:ref/PolynomialGCD] to find a common divisor:
ok  {f, g} = {x^2 + 3*x + 2, x^2 + 5*x + 6} ;; h = PolynomialGCD[f, g]    ==>     2 + x # skip
# Use RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient] to see the resulting factorization:
ok  f == PolynomialQuotient[f, h, x]*h    ==>     2 + 3*x + x^2 == (1 + x)*(2 + x) # skip
ok  g == PolynomialQuotient[g, h, x]*h    ==>     6 + 5*x + x^2 == (2 + x)*(3 + x) # skip
# For rational functions common divisors are not automatically canceled:
ok  f/g    ==>     (2 + 3*x + x^2)/(6 + 5*x + x^2) # skip
# RefLink[Cancel,paclet:ref/Cancel] effectively uses RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient] to cancel common divisors:
ok  Cancel[%]    ==>     (1 + x)/(3 + x) # skip
# The RefLink[Cyclotomic,paclet:ref/Cyclotomic] polynomials are defined as quotients:
ok  PolynomialQuotient[x^5 - 1, x - 1, x]    ==>     1 + x + x^2 + x^3 + x^4
    ---
    data:
        got:          2    3    4
#! 1 + x + x  + x  + x
        expect: 1 + x + x^2 + x^3 + x^4
        expect_evaluated:          2    3    4
#! 1 + x + x  + x  + x
    ...
ok  Cyclotomic[5, x]    ==>     1 + x + x^2 + x^3 + x^4
    ---
    data:
        got:          2    3    4
#! 1 + x + x  + x  + x
        expect: 1 + x + x^2 + x^3 + x^4
        expect_evaluated:          2    3    4
#! 1 + x + x  + x  + x
    ...
# The result depends on what is assumed to be a variable:
ok  {PolynomialQuotient[x^3 + y^2, x - y, x], PolynomialQuotient[x^3 + y^2, x - y, y]}    ==>     {x^2 + x*y + y^2, -x - y}
    ---
    data:
        got:   2          2
#! {x  + x y + y , -x - y}
        expect: {x^2 + x*y + y^2, -x - y}
        expect_evaluated:   2          2
#! {x  + x y + y , -x - y}
    ...
# The result from RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient] depends on recognizing zeros:
ok  PolynomialQuotient[x^3 + x + 1, zero*x^2 + x + 1, x]    ==>     -(1/zero^2) + x/zero
    ---
    data:
        got:      -2    x
#! -zero   + ----
#!           zero
        expect: -(1/zero^2) + x/zero
        expect_evaluated:      -2    x
#! -zero   + ----
#!           zero
    ...
ok  PolynomialQuotient[x^3 + x + 1, x + 1, x]    ==>     2 - x + x^2
    ---
    data:
        got:          2
#! 2 - x + x
        expect: 2 - x + x^2
        expect_evaluated:          2
#! 2 - x + x
    ...
# This is a hidden zero:
ok  zero = Sin[Sqrt[2] + Sqrt[3]] - Sin[Sqrt[5 + 2*Sqrt[6]]] ;; FullSimplify[zero]    ==>     0 # skip
# The result is as if the hidden zero was not zero:
ok  N[PolynomialQuotient[x^3 + x + 1, zero*x^2 + x + 1, x]]    ==>     -5.0706*10^30 - 2.2518*10^15*x # skip
