# SYSTEM: Mathematica_10
# TEST: PolynomialQuotient_Tests
# OUTPUT: output/Results/Mathematica_10/PolynomialQuotient_Tests.json
# The quotient of x^2 by x+a, with the remainder dropped:
ok  PolynomialQuotient[x^2, x + a, x]    ==>     -a + x
    ---
    data:
        got: -a + x
        expect: -a + x
        expect_evaluated: -a + x
    ...
ok  Expand[%*(x + a)]    ==>     -a^2 + x^2 # skip
# The resulting polynomial will have coefficients that are rational expressions of input coefficients:
ok  PolynomialQuotient[x^2 + x + 1, 2*x + 1, x]    ==>     1/4 + x/2
    ---
    data:
        got: 1/4 + x/2
        expect: 1/4 + x/2
        expect_evaluated: 1/4 + x/2
    ...
ok  PolynomialQuotient[x^2 + b*x + 1, a*x + 1, x]    ==>     -(1/a^2) + b/a + x/a
    ---
    data:
        got: -a^(-2) + b/a + x/a
        expect: -(1/a^2) + b/a + x/a
        expect_evaluated: -a^(-2) + b/a + x/a
    ...
ok  PolynomialQuotient[x^2 + x + 1, Pi*x + 1, x]    ==>     -(1/Pi^2) + 1/Pi + x/Pi
    ---
    data:
        got: -Pi^(-2) + Pi^(-1) + x/Pi
        expect: -(1/Pi^2) + 1/Pi + x/Pi
        expect_evaluated: -Pi^(-2) + Pi^(-1) + x/Pi
    ...
# RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient] also works for rational functions:
ok  PolynomialQuotient[(x + 1)/(x + 2), (x + 1)/(x + 3), x]    ==>     (3 + x)/(2 + x)
    ---
    data:
        got: (3 + x)/(2 + x)
        expect: (3 + x)/(2 + x)
        expect_evaluated: (3 + x)/(2 + x)
    ...
# Use a prime modulus:
ok  PolynomialQuotient[x^2 + 4*x + 1, 2*x + 1, x, Modulus -> 2]    ==>     1 + x^2
    ---
    data:
        got: 1 + x^2
        expect: 1 + x^2
        expect_evaluated: 1 + x^2
    ...
ok  PolynomialQuotient[x^2 + 4*x + 1, 2*x + 1, x, Modulus -> 3]    ==>     1 + 2*x
    ---
    data:
        got: 1 + 2*x
        expect: 1 + 2*x
        expect_evaluated: 1 + 2*x
    ...
ok  q = PolynomialQuotient[f, g, x]    ==>     2 + x # skip
ok  r = PolynomialRemainder[f, g, x]    ==>     -3 # skip
# Use RefLink[Expand,paclet:ref/Expand] to verify identity:
not ok  Expand[q*g + r] == f    ==>     True
    ---
    data:
        got: g*q + r == f
        expect: True
        expect_evaluated: True
    ...
# To get both quotient and remainder use RefLink[PolynomialQuotientRemainder,paclet:ref/PolynomialQuotientRemainder]:
ok  PolynomialQuotientRemainder[f, g, x]    ==>     {2 + x, -3} # skip
# RefLink[PolynomialReduce,paclet:ref/PolynomialReduce] generalizes RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient] for multivariate polynomials:
ok  PolynomialReduce[x^2 + 4*x + 1, {x + 2}, {x}]    ==>     {{2 + x}, -3}
    ---
    data:
        got: {{2 + x}, -3}
        expect: {{2 + x}, -3}
        expect_evaluated: {{2 + x}, -3}
    ...
ok  h = PolynomialGCD[f, g]    ==>     2 + x # skip
# Use RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient] to see the resulting factorization:
ok  f == PolynomialQuotient[f, h, x]*h    ==>     2 + 3*x + x^2 == (1 + x)*(2 + x) # skip
ok  g == PolynomialQuotient[g, h, x]*h    ==>     6 + 5*x + x^2 == (2 + x)*(3 + x) # skip
# For rational functions common divisors are not automatically canceled:
ok  f/g    ==>     (2 + 3*x + x^2)/(6 + 5*x + x^2) # skip
# RefLink[Cancel,paclet:ref/Cancel] effectively uses RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient] to cancel common divisors:
ok  Cancel[%]    ==>     (1 + x)/(3 + x) # skip
# The RefLink[Cyclotomic,paclet:ref/Cyclotomic] polynomials are defined as quotients:
ok  PolynomialQuotient[x^5 - 1, x - 1, x]    ==>     1 + x + x^2 + x^3 + x^4
    ---
    data:
        got: 1 + x + x^2 + x^3 + x^4
        expect: 1 + x + x^2 + x^3 + x^4
        expect_evaluated: 1 + x + x^2 + x^3 + x^4
    ...
ok  Cyclotomic[5, x]    ==>     1 + x + x^2 + x^3 + x^4
    ---
    data:
        got: 1 + x + x^2 + x^3 + x^4
        expect: 1 + x + x^2 + x^3 + x^4
        expect_evaluated: 1 + x + x^2 + x^3 + x^4
    ...
# The result depends on what is assumed to be a variable:
ok  {PolynomialQuotient[x^3 + y^2, x - y, x], PolynomialQuotient[x^3 + y^2, x - y, y]}    ==>     {x^2 + x*y + y^2, -x - y}
    ---
    data:
        got: {x^2 + x*y + y^2, -x - y}
        expect: {x^2 + x*y + y^2, -x - y}
        expect_evaluated: {x^2 + x*y + y^2, -x - y}
    ...
# The result from RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient] depends on recognizing zeros:
ok  PolynomialQuotient[x^3 + x + 1, zero*x^2 + x + 1, x]    ==>     -(1/zero^2) + x/zero
    ---
    data:
        got: -zero^(-2) + x/zero
        expect: -(1/zero^2) + x/zero
        expect_evaluated: -zero^(-2) + x/zero
    ...
ok  PolynomialQuotient[x^3 + x + 1, x + 1, x]    ==>     2 - x + x^2
    ---
    data:
        got: 2 - x + x^2
        expect: 2 - x + x^2
        expect_evaluated: 2 - x + x^2
    ...
ok  FullSimplify[zero]    ==>     0 # skip
# The result is as if the hidden zero was not zero:
ok  N[PolynomialQuotient[x^3 + x + 1, zero*x^2 + x + 1, x]]    ==>     -5.0706*10^30 - 2.2518*10^15*x # skip
