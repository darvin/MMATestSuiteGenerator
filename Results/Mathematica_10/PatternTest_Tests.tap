#! DOCKER > wolfram -script output/Tests/PatternTest_Tests.m
#! 5
# SYSTEM: Mathematica_10
# TEST: PatternTest_Tests
# Find cases of any expression that satisfies the RefLink[NumberQ,paclet:ref/NumberQ] test:
ok  Cases[{1, 2, 3.5, x, y, 4}, _?NumberQ]    ==>     {1, 2, 3.5, 4}
    ---
    data:
        got: {1, 2, 3.5, 4}
        expect: {1, 2, 3.5, 4}
        expect_evaluated: {1, 2, 3.5, 4}
    ...
# Test whether a list has only positive elements:
ok  MatchQ[{1, E, Pi}, {__?Positive}]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
ok  MatchQ[{1, I, 0}, {__?Positive}]    ==>     False
    ---
    data:
        got: False
        expect: False
        expect_evaluated: False
    ...
ok  f[2]    ==>     0.451948 # skip
ok  f[(1 + Sqrt[2])/5]    ==>     0.0135768 # skip
ok  f[a]    ==>     f[a]
    ---
    data:
        got: f[a]
        expect: f[a]
        expect_evaluated: f[a]
    ...
# Replace negative numbers with zero:
ok  {3, -5, 2, 7, -6, 3} /. _?Negative :> 0    ==>     {3, 0, 2, 7, 0, 3}
    ---
    data:
        got: {3, 0, 2, 7, 0, 3}
        expect: {3, 0, 2, 7, 0, 3}
        expect_evaluated: {3, 0, 2, 7, 0, 3}
    ...
# Find elements in a list that are divisible by 7:
ok  Cases[Range[0, 70], _?(Divisible[#1, 7] & )]    ==>     {0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70}
    ---
    data:
        got: {0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70}
        expect: {0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70}
        expect_evaluated: {0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70}
    ...
# Elements that are divisible by both 5 and 7:
ok  Cases[Range[0, 350], _?(Divisible[#1, 7] && Divisible[#1, 5] & )]    ==>     {0, 35, 70, 105, 140, 175, 210, 245, 280, 315, 350}
    ---
    data:
        got: {0, 35, 70, 105, 140, 175, 210, 245, 280, 315, 350}
        expect: {0, 35, 70, 105, 140, 175, 210, 245, 280, 315, 350}
        expect_evaluated: {0, 35, 70, 105, 140, 175, 210, 245, 280, 315, 350}
    ...
# Elements that are divisible by either 5 or 7:
ok  Cases[Range[0, 35], _?(Divisible[#1, 7] || Divisible[#1, 5] & )]    ==>     {0, 5, 7, 10, 14, 15, 20, 21, 25, 28, 30, 35}
    ---
    data:
        got: {0, 5, 7, 10, 14, 15, 20, 21, 25, 28, 30, 35}
        expect: {0, 5, 7, 10, 14, 15, 20, 21, 25, 28, 30, 35}
        expect_evaluated: {0, 5, 7, 10, 14, 15, 20, 21, 25, 28, 30, 35}
    ...
ok  f[0, 3]    ==>     0 # skip
ok  f[2, 4]    ==>     f[2, 4]
    ---
    data:
        got: f[2, 4]
        expect: f[2, 4]
        expect_evaluated: f[2, 4]
    ...
ok  f[-1, 3]    ==>     f[-1, 3]
    ---
    data:
        got: f[-1, 3]
        expect: f[-1, 3]
        expect_evaluated: f[-1, 3]
    ...
ok  f[-2]    ==>     1/4 # skip
ok  f[2]    ==>     f[2]
    ---
    data:
        got: f[2]
        expect: f[2]
        expect_evaluated: f[2]
    ...
ok  f[-4]    ==>     f[-4]
    ---
    data:
        got: f[-4]
        expect: f[-4]
        expect_evaluated: f[-4]
    ...
# Use RefLink[PatternTest,paclet:ref/PatternTest] on a complex pattern:
ok  MatchQ[{{a, b}, {c, d}}, ({_, _})?MatrixQ]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
ok  MatchQ[{a, b}, ({_, _})?MatrixQ]    ==>     False
    ---
    data:
        got: False
        expect: False
        expect_evaluated: False
    ...
# Search for numbers without allowing expressions to evaluate:
ok  Cases[Hold[Print[5], Sin, 2 + 2, 7, Sqrt[2]], _?(Function[{n}, NumberQ[Unevaluated[n]], HoldAll])]    ==>     {7}
    ---
    data:
        got: {7}
        expect: {7}
        expect_evaluated: {7}
    ...
# Just using RefLink[NumberQ,paclet:ref/NumberQ] would allow each element to evaluate:
ok  Cases[Hold[Print[5], Sin, 2 + 2, 7, Sqrt[2]], _?NumberQ]    ==>     {4, 7}
    ---
    data:
        got: {4, 7}
        expect: {4, 7}
        expect_evaluated: {4, 7}
    ...
# RefLink[PatternTest,paclet:ref/PatternTest] applies test functions to patterns, which need not have names:
ok  Cases[{{a, b}, {1, 2, 3}, {{d, 6}, {d, 10}}}, ({_, _})?VectorQ]    ==>     {{a, b}}
    ---
    data:
        got: {{a, b}}
        expect: {{a, b}}
        expect_evaluated: {{a, b}}
    ...
# RefLink[Condition,paclet:ref/Condition] evaluates a Boolean expression on named parts of a pattern:
ok  Cases[{{a, b}, {1, 2, 3}, {{d, 6}, {d, 10}}}, {x_, y_} /;  !ListQ[x] &&  !ListQ[y]]    ==>     {{a, b}}
    ---
    data:
        got: {{a, b}}
        expect: {{a, b}}
        expect_evaluated: {{a, b}}
    ...
# Use RefLink[Except,paclet:ref/Except] to effectively negate RefLink[PatternTest,paclet:ref/PatternTest]:
ok  Replace[{1, 7, "Hi", 3, Indeterminate}, Except[_?NumericQ] :> 0, 1]    ==>     {1, 7, 0, 3, 0}
    ---
    data:
        got: {1, 7, 0, 3, 0}
        expect: {1, 7, 0, 3, 0}
        expect_evaluated: {1, 7, 0, 3, 0}
    ...
# RefLink[PatternTest,paclet:ref/PatternTest] evaluates potential matches that are a part of a held expression:
ok  MatchQ[Hold[2 + 3], Hold[_?IntegerQ]]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
# Due to normal evaluation rules, expressions may evaluate before being examined by the test function:
ok  MatchQ[Hold[2 + 3], Hold[_?(IntegerQ[Unevaluated[#1]] & )]]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
# Use the three-argument form of RefLink[Function,paclet:ref/Function] or write the pattern using RefLink[Condition,paclet:ref/Condition] to prevent this:
ok  MatchQ[Hold[2 + 3], Hold[_?(Function[{n}, IntegerQ[Unevaluated[n]], HoldAll])]]    ==>     False
    ---
    data:
        got: False
        expect: False
        expect_evaluated: False
    ...
ok  MatchQ[Hold[2 + 3], Hold[n_] /; IntegerQ[Unevaluated[n]]]    ==>     False
    ---
    data:
        got: False
        expect: False
        expect_evaluated: False
    ...
