#! DOCKER > wolfram -script output/Tests/If_Tests.m
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
#! TextForm[ColonForm[MessageName[Piecewise, pairs], StringForm[The first argument `1` of Piecewise is not a list of pairs., Short[HoldForm[-x], 3]]]]
#! TextForm[ColonForm[MessageName[Less, nord], StringForm[Invalid comparison with `1` attempted., Short[HoldForm[I], 3]]]]
#! TextForm[ColonForm[MessageName[Less, nord], StringForm[Invalid comparison with `1` attempted., Short[HoldForm[I], 3]]]]
#! TextForm[ColonForm[MessageName[RuleDelayed, rhs], StringForm[Pattern `1` appears on the right-hand side of rule `2`., Short[HoldForm[x_], 3], Short[HoldForm[sign2[x_ /; x < 0] :> (-sign2[x_ /; x >= 0] := x)], 3]]]]
#! TextForm[ColonForm[MessageName[SetDelayed, write], StringForm[Tag `1` in `2` is Protected., Short[HoldForm[Times], 3], Short[HoldForm[-sign2[Pattern[-1, _] /; -1 >= 0]], 3]]]]
#! TextForm[ColonForm[MessageName[Less, nord], StringForm[Invalid comparison with `1` attempted., Short[HoldForm[I], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[Less, nord]], 3]]]]
#! TextForm[ColonForm[MessageName[Piecewise, pairs], StringForm[The first argument `1` of Piecewise is not a list of pairs., Short[HoldForm[a], 3]]]]
#! TextForm[ColonForm[MessageName[Piecewise, pairs], StringForm[The first argument `1` of Piecewise is not a list of pairs., Short[HoldForm[a], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[Piecewise, pairs]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: If_Tests
ok  $Failed    ==>     HoldComplete[{1, 0, 1}] # skip
# If the condition is neither RefLink[True,paclet:ref/True] nor RefLink[False,paclet:ref/False], RefLink[If,paclet:ref/If] remains unevaluated:
ok  If[a < b, 1, 0]    ==>     If[a < b, 1, 0]
    ---
    data:
        got: If[a < b, 1, 0]
        expect: If[a < b, 1, 0]
        expect_evaluated: If[a < b, 1, 0]
    ...
# The form with an explicit case for an undetermined condition evaluates in any case:
ok  If[a < b, 1, 0, Indeterminate]    ==>     Indeterminate
    ---
    data:
        got: Indeterminate
        expect: Indeterminate
        expect_evaluated: Indeterminate
    ...
# Use RefLink[TrueQ,paclet:ref/TrueQ] to force the condition to always return a Boolean value:
ok  If[TrueQ[a < b], 1, 0]    ==>     0
    ---
    data:
        got: 0
        expect: 0
        expect_evaluated: 0
    ...
# Define a piecewise function with both RefLink[If,paclet:ref/If] and RefLink[Round,paclet:ref/Round] as piecewise elements:
ok  f = If[Round[x] > x, x, -x]    ==>     If[Round[x] > x, x, -x]
    ---
    data:
        got: If[Round[x] > x, x, -x]
        expect: If[Round[x] > x, x, -x]
        expect_evaluated: If[Round[x] > x, x, -x]
    ...
# Use RefLink[PiecewiseExpand,paclet:ref/PiecewiseExpand] to get it into piecewise normal form: 
ok  PiecewiseExpand[f, 0 < x < 5]    ==>     Inequality[Piecewise[-x]*1, LessEqual, x, Less, 3/2] || 2 <= x <= 5/2 || Inequality[3, LessEqual, x, Less, 7/2] || 4 <= x <= 9/2 || x <= (1/2)*x*True # skip
# Perform several different symbolic operations: 
ok  Reduce[f < 5 && 0 < x < 10, x, Reals]    ==>     0 < x < 11/2 || 6 <= x <= 13/2 || Inequality[7, LessEqual, x, Less, 15/2] || 8 <= x <= 17/2 || Inequality[9, LessEqual, x, Less, 19/2]
    ---
    data:
        got:         11              13             15              17             19
#! 0 < x < -- || 6 <= x <= -- || 7 <= x < -- || 8 <= x <= -- || 9 <= x < --
        2               2              2               2              2
        expect: 0 < x < 11/2 || 6 <= x <= 13/2 || Inequality[7, LessEqual, x, Less, 15/2] || 8 <= x <= 17/2 || Inequality[9, LessEqual, x, Less, 19/2]
        expect_evaluated:         11              13             15              17             19
#! 0 < x < -- || 6 <= x <= -- || 7 <= x < -- || 8 <= x <= -- || 9 <= x < --
        2               2              2               2              2
    ...
ok  Integrate[f, {x, 0, 10}]    ==>     5/2
    ---
    data:
        got: 5
#! -
#! 2
        expect: 5/2
        expect_evaluated: 5
#! -
#! 2
    ...
ok  D[f, x]    ==>     If[Round[x] > x, 1, -1]
    ---
    data:
        got: If[Round[x] > x, 1, -1]
        expect: If[Round[x] > x, 1, -1]
        expect_evaluated: If[Round[x] > x, 1, -1]
    ...
ok  HoldComplete[Plot[f, {x, -2, 2}]]    ==>     $Failed # skip
# RefLink[If,paclet:ref/If] can be used as a statement:
ok  x = -2; If[x < 0, y = -x, y = x]; y    ==>     2
    ---
    data:
        got: 2
        expect: 2
        expect_evaluated: 2
    ...
# It can also be used as an expression returning a value:
ok  y = If[x < 0, -x, x]    ==>     2
    ---
    data:
        got: 2
        expect: 2
        expect_evaluated: 2
    ...
# Only the branch actually taken is evaluated:
ok  x = 1; If[x != 0, 1/x, Indeterminate]    ==>     1
    ---
    data:
        got: 1
        expect: 1
        expect_evaluated: 1
    ...
# Define a function by cases:
ok  sign[x_] := If[x < 0, -1, 1]; sign /@ {-1, 0, 1, I}    ==>     {-1, 1, 1, If[I < 0, -1, 1]}
    ---
    data:
        got: {-1, 1, 1, If[I < 0, -1, 1]}
        expect: {-1, 1, 1, If[I < 0, -1, 1]}
        expect_evaluated: {-1, 1, 1, If[I < 0, -1, 1]}
    ...
# Alternatively, use several conditional definitions:
not ok  sign2[x_ /; x < 0] := -sign2[x_ /; x >= 0] := x; sign2 /@ {-1, 0, 1, I}    ==>     {-1, 0, 1, sign2[I]}
    ---
    data:
        got: {$Failed, sign2[0], sign2[1], sign2[I]}
        expect: {-1, 0, 1, sign2[I]}
        expect_evaluated: {-1, 0, 1, sign2[I]}
    ...
# Use RefLink[Which,paclet:ref/Which] rather than a nested if-then-elsif chain:
ok  cut[x_] := If[x < -1, -1, If[x < 1, x, 1]]; cut /@ {-2, -1, 0, 1, 2}    ==>     {-1, -1, 0, 1, 1}
    ---
    data:
        got: {-1, -1, 0, 1, 1}
        expect: {-1, -1, 0, 1, 1}
        expect_evaluated: {-1, -1, 0, 1, 1}
    ...
ok  cut2[x_] := Which[x < -1, -1, x < 1, x, True, 1]; cut2 /@ {-2, -1, 0, 1, 2}    ==>     {-1, -1, 0, 1, 1}
    ---
    data:
        got: {-1, -1, 0, 1, 1}
        expect: {-1, -1, 0, 1, 1}
        expect_evaluated: {-1, -1, 0, 1, 1}
    ...
# Use RefLink[PiecewiseExpand,paclet:ref/PiecewiseExpand] to convert RefLink[If,paclet:ref/If] to RefLink[Piecewise,paclet:ref/Piecewise]:
ok  PiecewiseExpand[If[c, a, b]]    ==>     Piecewise[a]*c*b*True # skip
ok  PiecewiseExpand[If[If[c1, a1, b1], a, b]]    ==>     Piecewise[a]*(a1 && c1) || (b1 &&  !c1)*b*True # skip
ok  PiecewiseExpand[If[c, If[c2, a2, b2], b]]    ==>     Piecewise[a2]*c && c2*b!*c*b2*True # skip
