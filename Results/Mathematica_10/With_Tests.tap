#! DOCKER > wolfram -script output/Tests/With_Tests.m
# SYSTEM: Mathematica_10
# TEST: With_Tests
ok  f[a]    ==>     2 + a + (1 + a)^2 # skip
# Use RefLink[With,paclet:ref/With] to insert values into held expressions:
ok  With[{x = y}, Hold[x]]    ==>     Hold[y]
    ---
    data:
        got: y
        expect: Hold[y]
        expect_evaluated: y
    ...
ok  Table[With[{i = j}, Hold[i]], {j, 5}]    ==>     {Hold[1], Hold[2], Hold[3], Hold[4], Hold[5]}
    ---
    data:
        got: {1, 2, 3, 4, 5}
        expect: {Hold[1], Hold[2], Hold[3], Hold[4], Hold[5]}
        expect_evaluated: {1, 2, 3, 4, 5}
    ...
# The variable names can be the same:
ok  x = 5; With[{x = x}, Hold[x]]    ==>     Hold[5]
    ---
    data:
        got: 5
        expect: Hold[5]
        expect_evaluated: 5
    ...
# Use a constant for a value that is needed more than once:
ok  With[{y = Sin[1.]}, Sum[y^i, {i, 0, 10}]]    ==>     5.36323 # skip
# RefLink[With,paclet:ref/With] allows inserting values into unevaluated expressions:
ok  With[{v = {a, b, c}, w = {x, y, z}}, Thread[Unevaluated[v . w]]]    ==>     {a . x, b . y, c . z}
    ---
    data:
        got: {a . 5, b . y, c . z}
        expect: {a . x, b . y, c . z}
        expect_evaluated: {a . 5, b . y, c . z}
    ...
ok  Thread[{a, b, c} . {x, y, z}]    ==>     a*x + b*y + c*z
    ---
    data:
        got: 5*a + b*y + c*z
        expect: a*x + b*y + c*z
        expect_evaluated: 5*a + b*y + c*z
    ...
# RefLink[Module,paclet:ref/Module] introduces local variables to which you can assign values:
ok  Module[{x = 2.}, While[x > 0, x = Log[x]]; x]    ==>     -0.366513 # skip
# RefLink[With,paclet:ref/With] is faster than RefLink[Module,paclet:ref/Module]:
ok  Timing[Do[Module[{x = 5}, x; ], {10^5}]]    ==>     {0.312, Null} # skip
ok  Timing[Do[With[{x = 5}, x; ], {10^5}]]    ==>     {0.093, Null} # skip
# RefLink[Block,paclet:ref/Block] localizes values only; it does not substitute values. RefLink[Module,paclet:ref/Module] creates new symbols:
ok  {Block[{x = 5}, Hold[x]], With[{x = 5}, Hold[x]], Module[{x = 5}, Hold[x]]}    ==>     {Hold[x], Hold[5], Hold[x$100433]} # skip
ok  ReleaseHold[%]    ==>     {x, 5, 5} # skip
# RefLink[With,paclet:ref/With] allows substitution inside an unevaluated expression, preserving nested scopes:
ok  With[{e = x}, Function[x, e]]    ==>     Function[x$, x] # skip
# Ordinary substitution does not preserve scoping:
ok  Function[x, e] /. e :> x    ==>     Function[x, x]
    ---
    data:
        got: Function[x, x]
        expect: Function[x, x]
        expect_evaluated: Function[x, x]
    ...
# RefLink[With,paclet:ref/With] is a scoping construct; variables are renamed in nested scopes:
ok  With[{e = Expand[(1 + x)^5]}, Function[x, e]]    ==>     Function[x$, 1 + 5*x + 10*x^2 + 10*x^3 + 5*x^4 + x^5] # skip
ok  %[10]    ==>     1 + 5*x + 10*x^2 + 10*x^3 + 5*x^4 + x^5 # skip
# Build the function from its elements to avoid the renaming:
ok  With[{e = Expand[(1 + x)^5]}, Function @@ {x, e}]    ==>     Function[x, 1 + 5*x + 10*x^2 + 10*x^3 + 5*x^4 + x^5] # skip
ok  %[10]    ==>     161051 # skip
ok  newton[Cos, 1.`20.]    ==>     1.570796326794896619`18.196119877030153 # skip
# Find a fixed point:
ok  newton[Cos[#1] - #1 & , 1.`20.]    ==>     0.739085133215160642`17.868694466481546 # skip
ok  letrec[{f = Function[n, If[n == 0, 1, n*f[n - 1]]]}, f[10]]    ==>     3628800 # skip
# Here the f inside the function definition is not inside its own scope:
ok  With[{f = Function[n, If[n == 0, 1, n*f[n - 1]]]}, f[10]]    ==>     10*f[9]
    ---
    data:
        got: 10*f[9]
        expect: 10*f[9]
        expect_evaluated: 10*f[9]
    ...
