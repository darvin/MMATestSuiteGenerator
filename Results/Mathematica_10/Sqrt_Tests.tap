# SYSTEM: Mathematica_10
# TEST: Sqrt_Tests
# OUTPUT: output/Results/Mathematica_10/Sqrt_Tests.json
ok  Sqrt[2]    ==>     Sqrt[2]
    ---
    data:
        got: Sqrt[2]
        expect: Sqrt[2]
        expect_evaluated: Sqrt[2]
    ...
# Evaluate numerically to any precision:
ok  N[Sqrt[2], 50]    ==>     1.4142135623730950488016887242096980785696718753769`49.150514997832
    ---
    data:
        got: 1.4142135623730950488016887242096980785696718753769480731766797379907`50.
        expect: 1.4142135623730950488016887242096980785696718753769`49.150514997832
        expect_evaluated: 1.4142135623730950488016887242096980785696718753769`49.150514997832
    ...
# Negative numbers have imaginary square roots:
ok  Sqrt[-25]    ==>     5*I
    ---
    data:
        got: 5*I
        expect: 5*I
        expect_evaluated: 5*I
    ...
# RefLink[Sqrt,paclet:ref/Sqrt] threads element-wise over lists:
ok  Sqrt[{2, 3, 4, 5}]    ==>     {Sqrt[2], Sqrt[3], 2, Sqrt[5]}
    ---
    data:
        got: {Sqrt[2], Sqrt[3], 2, Sqrt[5]}
        expect: {Sqrt[2], Sqrt[3], 2, Sqrt[5]}
        expect_evaluated: {Sqrt[2], Sqrt[3], 2, Sqrt[5]}
    ...
ok  HoldComplete[Plot[Sqrt[x], {x, 0, 10}]]    ==>     $Failed # skip
# Sqrt[x^2] is not automatically replaced by x:
ok  Sqrt[x^2]    ==>     Sqrt[x^2]
    ---
    data:
        got: Sqrt[x^2]
        expect: Sqrt[x^2]
        expect_evaluated: Sqrt[x^2]
    ...
# It can be simplified to x if one assumes x>0:
ok  Simplify[%, x > 0]    ==>     x # skip
# Enter Sqrt[x] using Ctrl+2:
ok  Sqrt[100]    ==>     10
    ---
    data:
        got: 10
        expect: 10
        expect_evaluated: 10
    ...
# Exact roots are factored out when possible:
ok  Sqrt[8]    ==>     2*Sqrt[2]
    ---
    data:
        got: 2*Sqrt[2]
        expect: 2*Sqrt[2]
        expect_evaluated: 2*Sqrt[2]
    ...
# Find square roots of complex numbers:
ok  Sqrt[2.5 + I]    ==>     1.6113 + 0.310308*I # skip
# Roots of a quadratic polynomial:
ok  Reduce[a*x^2 + b*x + c == 0, x]    ==>     (a != 0 && (x == (-b - Sqrt[b^2 - 4*a*c])/(2*a) || x == (-b + Sqrt[b^2 - 4*a*c])/(2*a))) || (a == 0 && b != 0 && x == -(c/b)) || (c == 0 && b == 0 && a == 0)
    ---
    data:
        got: (a != 0 && (x == (-b - Sqrt[b^2 - 4*a*c])/(2*a) || x == (-b + Sqrt[b^2 - 4*a*c])/(2*a))) || (a == 0 && b != 0 && x == -(c/b)) || (c == 0 && b == 0 && a == 0)
        expect: (a != 0 && (x == (-b - Sqrt[b^2 - 4*a*c])/(2*a) || x == (-b + Sqrt[b^2 - 4*a*c])/(2*a))) || (a == 0 && b != 0 && x == -(c/b)) || (c == 0 && b == 0 && a == 0)
        expect_evaluated: (a != 0 && (x == (-b - Sqrt[b^2 - 4*a*c])/(2*a) || x == (-b + Sqrt[b^2 - 4*a*c])/(2*a))) || (a == 0 && b != 0 && x == -(c/b)) || (c == 0 && b == 0 && a == 0)
    ...
# Generate periodic continued fractions:
ok  ContinuedFraction[Sqrt[19]]    ==>     {4, {2, 1, 3, 1, 2, 8}}
    ---
    data:
        got: {4, {2, 1, 3, 1, 2, 8}}
        expect: {4, {2, 1, 3, 1, 2, 8}}
        expect_evaluated: {4, {2, 1, 3, 1, 2, 8}}
    ...
ok  ContinuedFraction[Sqrt[19], 20]    ==>     {4, 2, 1, 3, 1, 2, 8, 2, 1, 3, 1, 2, 8, 2, 1, 3, 1, 2, 8, 2}
    ---
    data:
        got: {4, 2, 1, 3, 1, 2, 8, 2, 1, 3, 1, 2, 8, 2, 1, 3, 1, 2, 8, 2}
        expect: {4, 2, 1, 3, 1, 2, 8, 2, 1, 3, 1, 2, 8, 2, 1, 3, 1, 2, 8, 2}
        expect_evaluated: {4, 2, 1, 3, 1, 2, 8, 2, 1, 3, 1, 2, 8, 2, 1, 3, 1, 2, 8, 2}
    ...
ok  HoldComplete[ListPlot[%, Filling -> Axis]]    ==>     $Failed # skip
# Reduce combinations of square roots:
ok  RootReduce[Sqrt[2] + Sqrt[3]]    ==>     Root[1 - 10*#1^2 + #1^4 & , 4]
    ---
    data:
        got: Root[1 - 10*#1^2 + #1^4 & , 4, 0]
        expect: Root[1 - 10*#1^2 + #1^4 & , 4]
        expect_evaluated: Root[1 - 10*#1^2 + #1^4 & , 4, 0]
    ...
# Evaluate power series involving square roots:
ok  Series[Sqrt[Sin[x]], {x, 0, 5}]    ==>     Sqrt[x] - x^(5/2)/12 + x^(9/2)/1440 + O[x]^(11/2)
    ---
    data:
        got: SeriesData[x, 0, {1, 0, 0, 0, -1/12, 0, 0, 0, 1/1440}, 1, 11, 2]
        expect: Sqrt[x] - x^(5/2)/12 + x^(9/2)/1440 + O[x]^(11/2)
        expect_evaluated: SeriesData[x, 0, {1, 0, 0, 0, -1/12, 0, 0, 0, 1/1440}, 1, 11, 2]
    ...
ok  ComplexExpand[Sqrt[x + I*y]]    ==>     (x^2 + y^2)^(1/4)*Cos[(1/2)*Arg[x + I*y]] + I*(x^2 + y^2)^(1/4)*Sin[(1/2)*Arg[x + I*y]]
    ---
    data:
        got: (x^2 + y^2)^(1/4)*Cos[Arg[x + I*y]/2] + I*(x^2 + y^2)^(1/4)*Sin[Arg[x + I*y]/2]
        expect: (x^2 + y^2)^(1/4)*Cos[(1/2)*Arg[x + I*y]] + I*(x^2 + y^2)^(1/4)*Sin[(1/2)*Arg[x + I*y]]
        expect_evaluated: (x^2 + y^2)^(1/4)*Cos[Arg[x + I*y]/2] + I*(x^2 + y^2)^(1/4)*Sin[Arg[x + I*y]/2]
    ...
# Factor polynomials with square roots in coefficients:
ok  Expand[(x + Sqrt[2])^2]    ==>     2 + 2*Sqrt[2]*x + x^2
    ---
    data:
        got: 2 + 2*Sqrt[2]*x + x^2
        expect: 2 + 2*Sqrt[2]*x + x^2
        expect_evaluated: 2 + 2*Sqrt[2]*x + x^2
    ...
ok  Factor[%, Extension -> Automatic]    ==>     (Sqrt[2] + x)^2 # skip
# RefLink[Simplify,paclet:ref/Simplify] handles expressions involving square roots:
ok  Simplify[Sqrt[1 + Sqrt[x^2]], x > 0]    ==>     Sqrt[1 + x]
    ---
    data:
        got: Sqrt[1 + x]
        expect: Sqrt[1 + x]
        expect_evaluated: Sqrt[1 + x]
    ...
# There are many subtle issues in handling square roots for arbitrary complex arguments:
ok  FunctionExpand[Sqrt[-z^2]]    ==>     Sqrt[-z]*Sqrt[z]
    ---
    data:
        got: Sqrt[-z]*Sqrt[z]
        expect: Sqrt[-z]*Sqrt[z]
        expect_evaluated: Sqrt[-z]*Sqrt[z]
    ...
# RefLink[PowerExpand,paclet:ref/PowerExpand] expands forms involving square roots:
ok  PowerExpand[Sqrt[x*y], Assumptions -> True]    ==>     E^(I*Pi*Floor[1/2 - Arg[x]/(2*Pi) - Arg[y]/(2*Pi)])*Sqrt[x]*Sqrt[y]
    ---
    data:
        got: E^(I*Pi*Floor[1/2 - Arg[x]/(2*Pi) - Arg[y]/(2*Pi)])*Sqrt[x]*Sqrt[y]
        expect: E^(I*Pi*Floor[1/2 - Arg[x]/(2*Pi) - Arg[y]/(2*Pi)])*Sqrt[x]*Sqrt[y]
        expect_evaluated: E^(I*Pi*Floor[1/2 - Arg[x]/(2*Pi) - Arg[y]/(2*Pi)])*Sqrt[x]*Sqrt[y]
    ...
# It generically assumes that all variables are positive:
ok  PowerExpand[Sqrt[x*y]]    ==>     Sqrt[x]*Sqrt[y]
    ---
    data:
        got: Sqrt[x]*Sqrt[y]
        expect: Sqrt[x]*Sqrt[y]
        expect_evaluated: Sqrt[x]*Sqrt[y]
    ...
ok  Element[{1, Sqrt[2], 3 + Sqrt[5]}, Algebraics]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
# Take limits accounting for branch cuts:
ok  Limit[Sqrt[-1 + I*x], x -> 0, Direction -> 1]    ==>     -I
    ---
    data:
        got: -I
        expect: -I
        expect_evaluated: -I
    ...
ok  Limit[Sqrt[-1 + I*x], x -> 0, Direction -> -1]    ==>     I
    ---
    data:
        got: I
        expect: I
        expect_evaluated: I
    ...
# Square root is discontinuous across its branch cut along the negative real axis:
ok  {Sqrt[-1 + 0.01*I], Sqrt[-1 - 0.01*I]}    ==>     {0.00499994 + 1.00001*I, 0.00499994 - 1.00001*I} # skip
ok  HoldComplete[Plot3D[Im[Sqrt[x + I*y]], {x, -1, 1}, {y, -1, 1}]]    ==>     $Failed # skip
# RefLink[Sqrt,paclet:ref/Sqrt][x^2] cannot automatically be reduced to x:
ok  Sqrt[x^2]    ==>     Sqrt[x^2]
    ---
    data:
        got: Sqrt[x^2]
        expect: Sqrt[x^2]
        expect_evaluated: Sqrt[x^2]
    ...
ok  Sqrt[(-4)^2]    ==>     4
    ---
    data:
        got: 4
        expect: 4
        expect_evaluated: 4
    ...
# With x assumed positive, the simplification can be done:
ok  Simplify[Sqrt[x^2], x > 0]    ==>     x
    ---
    data:
        got: x
        expect: x
        expect_evaluated: x
    ...
# Use RefLink[PowerExpand,paclet:ref/PowerExpand] to do the formal reduction:
ok  PowerExpand[Sqrt[x^2]]    ==>     x
    ---
    data:
        got: x
        expect: x
        expect_evaluated: x
    ...
# Along the branch cut, these are not the same:
ok  {1/Sqrt[z], Sqrt[1/z]} /. z -> -1    ==>     {-I, I}
    ---
    data:
        got: {-I, I}
        expect: {-I, I}
        expect_evaluated: {-I, I}
    ...
# Approximation to RefLink[GoldenRatio,paclet:ref/GoldenRatio]:
ok  Nest[Sqrt[1 + #1] & , 1, 10]    ==>     Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[2]]]]]]]]]]
    ---
    data:
        got: Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[2]]]]]]]]]]
        expect: Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[2]]]]]]]]]]
        expect_evaluated: Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[1 + Sqrt[2]]]]]]]]]]
    ...
ok  N[%]    ==>     1.61803 # skip
# Riemann surface for square root:
ok  HoldComplete[ParametricPlot3D[{x^2 - y^2, 2*x*y, x}, {x, -1, 1}, {y, -1, 1}]]    ==>     $Failed # skip
