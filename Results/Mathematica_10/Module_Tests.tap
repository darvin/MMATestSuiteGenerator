#! DOCKER > wolfram -script output/Tests/Module_Tests.m
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
#! x$564
#! 5
#! TextForm[ColonForm[MessageName[Unique, usym], StringForm[`1` is not a symbol or a valid symbol name., Short[HoldForm[InputForm[7]], 3]]]]
#! TextForm[ColonForm[MessageName[$RecursionLimit, reclim], StringForm[Recursion depth of `1` exceeded., Short[HoldForm[1024], 3]]]]
#! TextForm[ColonForm[MessageName[Function, flpar], StringForm[Parameter specification `1` in `2` should be a symbol or a list of symbols., Short[HoldForm[17], 3], Short[HoldForm[Function[17, 1889568]], 3]]]]
#! TextForm[ColonForm[MessageName[Module, lvset], StringForm[Local variable specification `1` contains `2`, which is an assignment to `3`; only assignments to symbols are allowed., Short[HoldForm[{{x, y} = v}], 3], Short[HoldForm[{x, y} = v], 3], Short[HoldForm[{x, y}], 3]]]]
#! TextForm[ColonForm[MessageName[Module, lvset], StringForm[Local variable specification `1` contains `2`, which is an assignment to `3`; only assignments to symbols are allowed., Short[HoldForm[{{x, y} = v}], 3], Short[HoldForm[{x, y} = v], 3], Short[HoldForm[{x, y}], 3]]]]
#! TextForm[ColonForm[MessageName[Module, lvset], StringForm[Local variable specification `1` contains `2`, which is an assignment to `3`; only assignments to symbols are allowed., Short[HoldForm[{{x, y} = v}], 3], Short[HoldForm[{x, y} = v], 3], Short[HoldForm[{x, y}], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[Module, lvset]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: Module_Tests
ok  $Failed    ==>     HoldComplete[-0.366513] # skip
# Dynamic programming with a local function:
ok  fib[n_] := Module[{f}, f[1] = f[2] = 1; f[i_] := f[i] = f[i - 1] + f[i - 2]; f[n]]; fib[5]    ==>     5
    ---
    data:
        got: 5
        expect: 5
        expect_evaluated: 5
    ...
# Euclid's algorithm for the GCD using initialized local variables:
ok  gcd[m0_, n0_] := Module[{m = m0, n = n0}, While[n != 0, {m, n} = {n, Mod[m, n]}]; m]; gcd[18, 21]    ==>     3
    ---
    data:
        got: 3
        expect: 3
        expect_evaluated: 3
    ...
# Every time a module is evaluated, a new temporary symbol is created:
ok  {Module[{x}, x], Module[{x}, x]}    ==>     {x$100, x$101} # skip
# Module symbols are temporary and are removed if they are no longer referenced:
ok  Module[{x}, Print[x]; Attributes[x]]    ==>     {Temporary}
    ---
    data:
        got: {Temporary}
        expect: {Temporary}
        expect_evaluated: {Temporary}
    ...
ok  Names["x$*"]    ==>     {} # skip
# Each use of RefLink[Module,paclet:ref/Module] increments RefLink[$ModuleNumber,paclet:ref/$ModuleNumber]:
ok  {$ModuleNumber, Module[{x}, x], $ModuleNumber}    ==>     {37, x$37, 38} # skip
# If there is no need to assign to a local variable, a constant should be used instead:
ok  With[{x = 2.}, Sqrt[x] + 1]    ==>     2.41421
    ---
    data:
        got: 2.41421
        expect: 2.41421
        expect_evaluated: 2.41421
    ...
# RefLink[With,paclet:ref/With] is faster than RefLink[Module,paclet:ref/Module]:
ok  Timing[Do[Module[{x = 5}, x; ], {10^5}]]    ==>     {0.312, Null} # skip
ok  Timing[Do[With[{x = 5}, x; ], {10^5}]]    ==>     {0.093, Null} # skip
# RefLink[Block,paclet:ref/Block] localizes values only; it does not create new symbols:
ok  x = 7; Block[{x = 5}, Print[x]]; x    ==>     7
    ---
    data:
        got: 7
        expect: 7
        expect_evaluated: 7
    ...
# RefLink[Unique,paclet:ref/Unique] creates new variables in a way similar to RefLink[Module,paclet:ref/Module]:
ok  {Unique[x], Module[{x}, x]}    ==>     {x$949, x$950} # skip
# Local variables are not affected by global ones, and vice versa:
ok  x = 17; Module[{x = x}, x = x + 1; x]    ==>     18
    ---
    data:
        got: 18
        expect: 18
        expect_evaluated: 18
    ...
ok  x    ==>     17
    ---
    data:
        got: 17
        expect: 17
        expect_evaluated: 17
    ...
# A symbol brought into the scope of RefLink[Module,paclet:ref/Module] is not affected by naming conflicts:
ok  y = x^2 ;; Module[{x = 5}, x + y]    ==>     5 + x^2 # skip
# Variables are renamed in nested scopes:
ok  Module[{e = Expand[(1 + x)^5]}, Function[x, e]]    ==>     Function[x$, e$100477] # skip
ok  %[10]    ==>     1 + 5*x + 10*x^2 + 10*x^3 + 5*x^4 + x^5 # skip
# Build the function from its parts to avoid the renaming:
ok  Module[{e = Expand[(1 + x)^5]}, Function @@ {x, e}]    ==>     Function[x, 1 + 5*x + 10*x^2 + 10*x^3 + 5*x^4 + x^5] # skip
ok  %[10]    ==>     161051
    ---
    data:
        got: 161051
        expect: 161051
        expect_evaluated: 161051
    ...
# Parallel assignment is not available for RefLink[Module,paclet:ref/Module] variables:
ok  v = {a, b} ;; Module[{{x, y} = v}, x^2 + y^2]    ==>     Module[{{x, y} = v}, x^2 + y^2] # skip
ok  Module[{x = v[[1]], y = v[[2]]}, x^2 + y^2]    ==>     a^2 + b^2 # skip
