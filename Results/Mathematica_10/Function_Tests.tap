# SYSTEM: Mathematica_10
# TEST: Function_Tests
# OUTPUT: output/Results/Mathematica_10/Function_Tests.json
# Pure function with one parameter:
ok  Function[u, 3 + u][x]    ==>     3 + x
    ---
    data:
        got: 3 + x
        expect: 3 + x
        expect_evaluated: 3 + x
    ...
ok  (3 + #1 & )[x]    ==>     3 + x
    ---
    data:
        got: 3 + x
        expect: 3 + x
        expect_evaluated: 3 + x
    ...
ok  (3 + #1 & )[x]    ==>     3 + x
    ---
    data:
        got: 3 + x
        expect: 3 + x
        expect_evaluated: 3 + x
    ...
# Pure function with two parameters:
ok  Function[{u, v}, u^2 + v^4][x, y]    ==>     x^2 + y^4
    ---
    data:
        got: x^2 + y^4
        expect: x^2 + y^4
        expect_evaluated: x^2 + y^4
    ...
ok  (#1^2 + #2^4 & )[x, y]    ==>     x^2 + y^4
    ---
    data:
        got: x^2 + y^4
        expect: x^2 + y^4
        expect_evaluated: x^2 + y^4
    ...
# Set f to be a pure function:
ok  f = 3 + #1 &     ==>     3 + #1 & 
    ---
    data:
        got: 3 + #1 & 
        expect: 3 + #1 & 
        expect_evaluated: 3 + #1 & 
    ...
# Use the pure function:
ok  {f[a], f[b]}    ==>     {3 + a, 3 + b}
    ---
    data:
        got: {3 + a, 3 + b}
        expect: {3 + a, 3 + b}
        expect_evaluated: {3 + a, 3 + b}
    ...
# Pick out named arguments from an association:
ok  (f[u, v, u] & )[<| "u" -> x, "v" -> y |>]    ==>     f[x, y, x] # skip
# Map a pure function over a list:
ok  (g[#1, #1^2] & ) /@ {x, y, z}    ==>     {g[x, x^2], g[y, y^2], g[z, z^2]}
    ---
    data:
        got: {g[x, x^2], g[y, y^2], g[z, z^2]}
        expect: {g[x, x^2], g[y, y^2], g[z, z^2]}
        expect_evaluated: {g[x, x^2], g[y, y^2], g[z, z^2]}
    ...
# Select with a pure function:
ok  Select[{1, -1, 2, -2, 3}, #1 > 0 & ]    ==>     {1, 2, 3}
    ---
    data:
        got: {1, 2, 3}
        expect: {1, 2, 3}
        expect_evaluated: {1, 2, 3}
    ...
# Use a pure function as a predicate:
ok  Cases[{1, -1, 2, -2, 3}, _Integer?(#1 > 0 & )]    ==>     {1, 2, 3}
    ---
    data:
        got: {1, 2, 3}
        expect: {1, 2, 3}
        expect_evaluated: {1, 2, 3}
    ...
# Create an array from a pure function:
ok  Array[1 + #1^2 & , 10]    ==>     {2, 5, 10, 17, 26, 37, 50, 65, 82, 101}
    ---
    data:
        got: {2, 5, 10, 17, 26, 37, 50, 65, 82, 101}
        expect: {2, 5, 10, 17, 26, 37, 50, 65, 82, 101}
        expect_evaluated: {2, 5, 10, 17, 26, 37, 50, 65, 82, 101}
    ...
# Sort by comparing the second part of each element:
ok  Sort[{{a, 2}, {c, 1}, {d, 3}}, #1[[2]] < #2[[2]] & ]    ==>     {{c, 1}, {a, 2}, {d, 3}}
    ---
    data:
        got: {{c, 1}, {a, 2}, {d, 3}}
        expect: {{c, 1}, {a, 2}, {d, 3}}
        expect_evaluated: {{c, 1}, {a, 2}, {d, 3}}
    ...
# Specify a custom comparison function in RefLink[FixedPoint,paclet:ref/FixedPoint]:
ok  FixedPoint[(#1 + 2/#1)/2 & , 1.`20., SameTest -> (Abs[#1 - #2] < 1/10000000000 & )]    ==>     1.4142135623730950488`19.15051499783199
    ---
    data:
        got: 1.41421356237309504880168962350253024361`20.
        expect: 1.4142135623730950488`19.15051499783199
        expect_evaluated: 1.4142135623730950488`19.15051499783199
    ...
# Specify a custom color function:
ok  HoldComplete[DensityPlot[Sin[x*y], {x, 0, 3}, {y, 0, 3}, ColorFunction -> (RGBColor[1 - #1, #1, 1 - #1] & )]]    ==>     $Failed # skip
# Provide a custom distance function:
ok  Nearest[{1, 2, 4, 8, 16}, 5, DistanceFunction -> ((#1 - #2)^2 & )]    ==>     {4}
    ---
    data:
        got: {4}
        expect: {4}
        expect_evaluated: {4}
    ...
# Derivative of a pure function:
ok  Derivative[1][Function[x, x^2]]    ==>     Function[x, 2*x]
    ---
    data:
        got: Function[x, 2*x]
        expect: Function[x, 2*x]
        expect_evaluated: Function[x, 2*x]
    ...
# Derivative of RefLink[Tan,paclet:ref/Tan]:
ok  Derivative[1][Tan]    ==>     Sec[#1]^2 & 
    ---
    data:
        got: Sec[#1]^2 & 
        expect: Sec[#1]^2 & 
        expect_evaluated: Sec[#1]^2 & 
    ...
# Solutions of differential equations may be expressed as pure functions:
ok  DSolve[{Derivative[1][y][x] == a*y[x], y[0] == 1}, y, x]    ==>     {{y -> Function[{x}, E^(a*x)]}}
    ---
    data:
        got: {{y -> Function[{x}, E^(a*x)]}}
        expect: {{y -> Function[{x}, E^(a*x)]}}
        expect_evaluated: {{y -> Function[{x}, E^(a*x)]}}
    ...
# Difference equations may return pure functions:
ok  RSolve[{a[n + 1] - 2*a[n] == 1, a[0] == 1}, a, n]    ==>     {{a -> Function[{n}, -1 + 2^(1 + n)]}}
    ---
    data:
        got: {{a -> Function[{n}, -1 + 2^(1 + n)]}}
        expect: {{a -> Function[{n}, -1 + 2^(1 + n)]}}
        expect_evaluated: {{a -> Function[{n}, -1 + 2^(1 + n)]}}
    ...
# #name is effectively a short form of #["name"]:
ok  (x & )[<| "x" -> a, "y" -> b |>]    ==>     a # skip
ok  (#1["x"] & )[<| "x" -> a, "y" -> b |>]    ==>     a
    ---
    data:
        got: a
        expect: a
        expect_evaluated: a
    ...
# #name always refers to the association in the first argument:
ok  (y & )[<| "x" -> 1, "y" -> 2 |>, <| "x" -> 3, "y" -> 4 |>]    ==>     2 # skip
# Extract from an association slot other than the first:
ok  (#2["y"] & )[<| "x" -> 1, "y" -> 2 |>, <| "x" -> 3, "y" -> 4 |>]    ==>     4
    ---
    data:
        got: 4
        expect: 4
        expect_evaluated: 4
    ...
# ## stands for all arguments:
ok  (f[##1] & )[a, b, c, d]    ==>     f[a, b, c, d]
    ---
    data:
        got: 3 + a
        expect: f[a, b, c, d]
        expect_evaluated: 3 + a
    ...
ok  (f[X, ##1, Y, ##1] & )[a, b, c, d]    ==>     f[X, a, b, c, d, Y, a, b, c, d]
    ---
    data:
        got: 3 + X
        expect: f[X, a, b, c, d, Y, a, b, c, d]
        expect_evaluated: 3 + X
    ...
# ##n stands for arguments n and onward:
ok  (f[##2] & )[a, b, c, d]    ==>     f[b, c, d]
    ---
    data:
        got: 3 + b
        expect: f[b, c, d]
        expect_evaluated: 3 + b
    ...
ok  (f[##1, X, ##2, Y, ##3, Z, ##4] & )[a, b, c, d]    ==>     f[a, b, c, d, X, b, c, d, Y, c, d, Z, d]
    ---
    data:
        got: 3 + a
        expect: f[a, b, c, d, X, b, c, d, Y, c, d, Z, d]
        expect_evaluated: 3 + a
    ...
# Create a pure function with attribute RefLink[Listable,paclet:ref/Listable]:
ok  Function[{u}, g[u], Listable][{a, b, c}]    ==>     {g[a], g[b], g[c]}
    ---
    data:
        got: {g[a], g[b], g[c]}
        expect: {g[a], g[b], g[c]}
        expect_evaluated: {g[a], g[b], g[c]}
    ...
ok  Function[{u}, g[u]][{a, b, c}]    ==>     g[{a, b, c}]
    ---
    data:
        got: g[{a, b, c}]
        expect: g[{a, b, c}]
        expect_evaluated: g[{a, b, c}]
    ...
# #0 stands for the whole pure function:
ok  (f[#0] & )[x]    ==>     f[f[#0] & ]
    ---
    data:
        got: 3 + (f[#0] & )
        expect: f[f[#0] & ]
        expect_evaluated: 3 + (f[#0] & )
    ...
# A recursive definition for factorial using #0:
ok  f = If[#1 == 1, 1, #1*#0[#1 - 1]] &     ==>     If[#1 == 1, 1, #1*#0[#1 - 1]] & 
    ---
    data:
        got: If[#1 == 1, 1, #1*#0[#1 - 1]] & 
        expect: If[#1 == 1, 1, #1*#0[#1 - 1]] & 
        expect_evaluated: If[#1 == 1, 1, #1*#0[#1 - 1]] & 
    ...
ok  f[10]    ==>     3628800
    ---
    data:
        got: 3628800
        expect: 3628800
        expect_evaluated: 3628800
    ...
# Turn a function that takes several arguments into one that takes a list of arguments:
ok  cplus = Plus @@ #1 &     ==>     Plus @@ #1 & 
    ---
    data:
        got: Plus @@ #1 & 
        expect: Plus @@ #1 & 
        expect_evaluated: Plus @@ #1 & 
    ...
ok  cplus[{a, b, c}]    ==>     a + b + c
    ---
    data:
        got: a + b + c
        expect: a + b + c
        expect_evaluated: a + b + c
    ...
ok  f2 = makef[2]    ==>     Function[x$, 2*x$] # skip
ok  f2[5]    ==>     10 # skip
# Preserve arguments in unevaluated form:
ok  Select[Hold[x, $MaxMachineNumber], Function[symbol, Context[symbol] === "System`", HoldAll]]    ==>     Hold[$MaxMachineNumber]
    ---
    data:
        got: 1.7976931348623157*^308
        expect: Hold[$MaxMachineNumber]
        expect_evaluated: 1.7976931348623157*^308
    ...
# #1 uses only the first argument supplied; the rest are ignored:
ok  (f[#1] & )[x, y, z]    ==>     f[x]
    ---
    data:
        got: If[x == 1, 1, x*(If[#1 == 1, 1, #1*#0[#1 - 1]] & )[x - 1]]
        expect: f[x]
        expect_evaluated: If[x == 1, 1, x*(If[#1 == 1, 1, #1*#0[#1 - 1]] & )[x - 1]]
    ...
# Not using any arguments results in a constant pure function:
ok  (17 & ) /@ {1, 2, 3}    ==>     {17, 17, 17}
    ---
    data:
        got: {17, 17, 17}
        expect: {17, 17, 17}
        expect_evaluated: {17, 17, 17}
    ...
# Replacements can be done inside pure functions:
ok  (p + #1 & ) /. p -> q    ==>     q + #1 & 
    ---
    data:
        got: q + #1 & 
        expect: q + #1 & 
        expect_evaluated: q + #1 & 
    ...
ok  %[x]    ==>     q + x # skip
# Formal parameters are renamed whenever there is a possibility of confusion:
ok  Function[{x}, Function[{y}, f[x, y]]][y]    ==>     Function[{y$}, f[y, y$]]
    ---
    data:
        got: Function[{y$}, f[y, y$]]
        expect: Function[{y$}, f[y, y$]]
        expect_evaluated: Function[{y$}, f[y, y$]]
    ...
ok  Function[{x}, Function[{y}, f[x, y]]][a]    ==>     Function[{y$}, f[a, y$]]
    ---
    data:
        got: Function[{y$}, f[a, y$]]
        expect: Function[{y$}, f[a, y$]]
        expect_evaluated: Function[{y$}, f[a, y$]]
    ...
ok  Function[{x}, Function[{y}, Function[{z}, f[x, y, z]]]][a]    ==>     Function[{y$}, Function[{z$}, f[a, y$, z$]]]
    ---
    data:
        got: Function[{y$}, Function[{z$}, f[a, y$, z$]]]
        expect: Function[{y$}, Function[{z$}, f[a, y$, z$]]]
        expect_evaluated: Function[{y$}, Function[{z$}, f[a, y$, z$]]]
    ...
# The names of the parameters do not matter:
ok  Function[x, Function[y, x^y]][x][y]    ==>     x^y
    ---
    data:
        got: x^y
        expect: x^y
        expect_evaluated: x^y
    ...
ok  Function[y, Function[x, y^x]][x][y]    ==>     x^y
    ---
    data:
        got: x^y
        expect: x^y
        expect_evaluated: x^y
    ...
# However, reusing a name introduces a new scope:
ok  Function[x, Function[x, x^x]][x][y]    ==>     y^y
    ---
    data:
        got: y^y
        expect: y^y
        expect_evaluated: y^y
    ...
# Nested functions take their arguments one at a time:
ok  Function[x, Function[y, x^y]][a][b]    ==>     a^b
    ---
    data:
        got: a^b
        expect: a^b
        expect_evaluated: a^b
    ...
ok  Function[{x, y}, x^y][a, b]    ==>     a^b
    ---
    data:
        got: a^b
        expect: a^b
        expect_evaluated: a^b
    ...
# f[#]& is the same as simply f in the univariate case:
ok  (f[#1] & )[a]    ==>     f[a]
    ---
    data:
        got: If[a == 1, 1, a*(If[#1 == 1, 1, #1*#0[#1 - 1]] & )[a - 1]]
        expect: f[a]
        expect_evaluated: If[a == 1, 1, a*(If[#1 == 1, 1, #1*#0[#1 - 1]] & )[a - 1]]
    ...
# In general f[##]& is the same as f:
ok  (f[##1] & )[a, b, c]    ==>     f[a, b, c]
    ---
    data:
        got: If[a == 1, 1, a*(If[#1 == 1, 1, #1*#0[#1 - 1]] & )[a - 1]]
        expect: f[a, b, c]
        expect_evaluated: If[a == 1, 1, a*(If[#1 == 1, 1, #1*#0[#1 - 1]] & )[a - 1]]
    ...
ok  Function[x, Evaluate[formula]]    ==>     Function[x, (1 + x)^2] # skip
# Use a formula in RefLink[Table,paclet:ref/Table]:
ok  Table[i^2, {i, 10}]    ==>     {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}
    ---
    data:
        got: {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}
        expect: {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}
        expect_evaluated: {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}
    ...
# Use the corresponding pure function in an equivalent RefLink[Array,paclet:ref/Array] expression:
ok  Array[#1^2 & , 10]    ==>     {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}
    ---
    data:
        got: {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}
        expect: {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}
        expect_evaluated: {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}
    ...
# Special-purpose function constructs include RefLink[InterpolatingFunction,paclet:ref/InterpolatingFunction]:
ok  HoldComplete[f = Interpolation[{1, 2, 4, 5, 6}]]    ==>     $Failed # skip
not ok  f[4]    ==>     5
    ---
    data:
        got: 24
        expect: 5
        expect_evaluated: 5
    ...
# RefLink[CompiledFunction,paclet:ref/CompiledFunction]:
ok  HoldComplete[f = Compile[{x}, x^2]]    ==>     $Failed # skip
not ok  f[5.]    ==>     25.
    ---
    data:
        got: 120.
        expect: 25.
        expect_evaluated: 25.
    ...
# RefLink[NearestFunction,paclet:ref/NearestFunction]:
ok  HoldComplete[f = Nearest[{1, 2, 3, 4, 5}]]    ==>     $Failed # skip
not ok  f[3.1]    ==>     {3}
    ---
    data:
        got: inExpr$828
        expect: {3}
        expect_evaluated: {3}
    ...
# RefLink[LinearSolveFunction,paclet:ref/LinearSolveFunction]:
ok  HoldComplete[f = LinearSolve[{{1, 2}, {3, 4}}]]    ==>     $Failed # skip
not ok  f[{5, 6}]    ==>     {-4, 9/2}
    ---
    data:
        got: If[{5, 6} == 1, 1, {5, 6}*(If[#1 == 1, 1, #1*#0[#1 - 1]] & )[{5, 6} - 1]]
        expect: {-4, 9/2}
        expect_evaluated: {-4, 9/2}
    ...
# & binds more loosely than ->, so it usually needs parentheses in rules:
ok  FullForm[x -> y & ]    ==>     x -> y &  # skip
ok  FullForm[x -> (y & )]    ==>     x -> (y & ) # skip
# & binds more loosely than ?, so it usually needs parentheses in pattern tests:
ok  Cases[{1, 2, 3, 4}, _?(OddQ[#1/2] & )]    ==>     {2}
    ---
    data:
        got: {2}
        expect: {2}
        expect_evaluated: {2}
    ...
# RefLink[Function,paclet:ref/Function] does not evaluate its body until the function is applied:
ok  #1 + #1 + #1 &     ==>     #1 + #1 + #1 & 
    ---
    data:
        got: #1 + #1 + #1 & 
        expect: #1 + #1 + #1 & 
        expect_evaluated: #1 + #1 + #1 & 
    ...
ok  %[a]    ==>     3*a # skip
# Supplying fewer than the required number of arguments generates an error:
ok  (#2 & )[x]    ==>     #2
    ---
    data:
        got: #2
        expect: #2
        expect_evaluated: #2
    ...
# Define the recursion operator of recursion theory [WebLink[more info,http://www.wolframscience.com/nksonline/page-907b-text]]:
ok  r[g_, h_] = If[#1 == 0, g[##2], h[#0[#1 - 1, ##2], #1 - 1, ##2]] &     ==>     If[#1 == 0, g[##2], h[#0[#1 - 1, ##2], #1 - 1, ##2]] & 
    ---
    data:
        got: If[#1 == 0, g[##2], h[#0[#1 - 1, ##2], #1 - 1, ##2]] & 
        expect: If[#1 == 0, g[##2], h[#0[#1 - 1, ##2], #1 - 1, ##2]] & 
        expect_evaluated: If[#1 == 0, g[##2], h[#0[#1 - 1, ##2], #1 - 1, ##2]] & 
    ...
# Use it to define the factorial function:
ok  r[1 & , #1*(#2 + 1) & ][10]    ==>     3628800
    ---
    data:
        got: 3628800
        expect: 3628800
        expect_evaluated: 3628800
    ...
ok  NewtonZero[BesselJ[2, #1] & , 5.]    ==>     5.13562 # skip
