#! DOCKER > wolfram -script output/Tests/PolynomialRemainder_Tests.m
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
#! TextForm[ColonForm[MessageName[Power, infy], StringForm[Infinite expression `1` encountered., Short[HoldForm[0^(-1)], 3]]]]
#! TextForm[ColonForm[MessageName[Set, write], StringForm[Tag `1` in `2` is Protected., Short[HoldForm[Span], 3], Short[HoldForm[Span[{1 + 4*x + x^2, 2 + x}, q]], 3]]]]
#! TextForm[ColonForm[MessageName[Set, shape], StringForm[Lists `1` and `2` are not the same shape., Short[HoldForm[{f, g}], 3], Short[HoldForm[f/g], 3]]]]
# SYSTEM: Mathematica_10
# TEST: PolynomialRemainder_Tests
# Find the remainder after dividing one polynomial by another:
ok  PolynomialRemainder[x^2, x + a, x]    ==>     a^2
    ---
    data:
        got:  2
#! a
        expect: a^2
        expect_evaluated:  2
#! a
    ...
# The resulting polynomial will have coefficients that are rational expressions of input coefficients:
ok  PolynomialRemainder[x^2 + x + 1, 2*x + 1, x]    ==>     3/4
    ---
    data:
        got: 3
#! -
#! 4
        expect: 3/4
        expect_evaluated: 3
#! -
#! 4
    ...
ok  PolynomialRemainder[x^2 + b*x + 1, a*x + 1, x]    ==>     1 + 1/a^2 - b/a
    ---
    data:
        got:      -2   b
#! 1 + a   - -
#!           a
        expect: 1 + 1/a^2 - b/a
        expect_evaluated:      -2   b
#! 1 + a   - -
#!           a
    ...
ok  PolynomialRemainder[x^2 + x + 1, Pi*x + 1, x]    ==>     1 + 1/Pi^2 - 1/Pi
    ---
    data:
        got:       -2   1
#! 1 + Pi   - --
#!            Pi
        expect: 1 + 1/Pi^2 - 1/Pi
        expect_evaluated:       -2   1
#! 1 + Pi   - --
#!            Pi
    ...
# RefLink[PolynomialRemainder,paclet:ref/PolynomialRemainder] also works for rational functions:
ok  PolynomialRemainder[(x + 1)/(x + 2), (x + 1)/(x + 3), x]    ==>     0
    ---
    data:
        got: 0
        expect: 0
        expect_evaluated: 0
    ...
# Use a prime modulus:
ok  PolynomialRemainder[x^2 + 4*x + 1, 2*x + 1, x, Modulus -> 2]    ==>     0
    ---
    data:
        got: 0
        expect: 0
        expect_evaluated: 0
    ...
ok  PolynomialRemainder[x^2 + 4*x + 1, 2*x + 1, x, Modulus -> 5]    ==>     3
    ---
    data:
        got: 3
        expect: 3
        expect_evaluated: 3
    ...
# Euclid's algorithm for the greatest common divisor:
ok  Euclid[f_, g_, x_] /; Exponent[f, x] < Exponent[g, x] := Euclid[g, f, x]; Euclid[f_, (g_)?NumericQ, x_] := If[PossibleZeroQ[g], f, 1]; Euclid[f_, g_, x_] := Euclid[g, PolynomialRemainder[f, g, x], x]; Euclid[(x + 1)*(x + 2), (x + 2)*(x + 3), x]    ==>     -4 - 2*x
    ---
    data:
        got: -4 - 2 x
        expect: -4 - 2*x
        expect_evaluated: -4 - 2 x
    ...
# Divide by the leading coefficient:
ok  Expand[%/Coefficient[%, x, 1]]    ==>     2 + x # skip
ok  PolynomialGCD[(x + 1)*(x + 2), (x + 2)*(x + 3)]    ==>     2 + x
    ---
    data:
        got: 2 + x
        expect: 2 + x
        expect_evaluated: 2 + x
    ...
# For a polynomial f, f==qg+r, where q is given by RefLink[PolynomialQuotient,paclet:ref/PolynomialQuotient]:
ok  {f, g} = {x^2 + 4*x + 1, x + 2} ;; q = PolynomialQuotient[f, g, x]    ==>     2 + x # skip
ok  r = PolynomialRemainder[f, g, x]    ==>     -3 # skip
# Use RefLink[Expand,paclet:ref/Expand] to verify identity:
ok  Expand[q*g + r] == f    ==>     True # skip
# To get both quotient and remainder use RefLink[PolynomialQuotientRemainder,paclet:ref/PolynomialQuotientRemainder]:
ok  PolynomialQuotientRemainder[f, g, x]    ==>     {2 + x, -3} # skip
# RefLink[PolynomialReduce,paclet:ref/PolynomialReduce] generalizes RefLink[PolynomialRemainder,paclet:ref/PolynomialRemainder] for multivariate polynomials:
ok  PolynomialReduce[x^2 + 4*x + 1, {x + 2}, {x}]    ==>     {{2 + x}, -3}
    ---
    data:
        got: {{2 + x}, -3}
        expect: {{2 + x}, -3}
        expect_evaluated: {{2 + x}, -3}
    ...
ok  PolynomialRemainder[x^2, x + a, x]    ==>     a^2
    ---
    data:
        got:  2
#! a
        expect: a^2
        expect_evaluated:  2
#! a
    ...
ok  PolynomialMod[x^2, x + a]    ==>     x^2
    ---
    data:
        got:  2
#! x
        expect: x^2
        expect_evaluated:  2
#! x
    ...
# The variable assumed for the polynomials matters:
ok  {PolynomialRemainder[x + y, x - y, x], PolynomialRemainder[x + y, x - y, y]}    ==>     {2*y, 2*x}
    ---
    data:
        got: {2 y, 2 x}
        expect: {2*y, 2*x}
        expect_evaluated: {2 y, 2 x}
    ...
