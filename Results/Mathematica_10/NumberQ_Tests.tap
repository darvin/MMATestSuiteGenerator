#! DOCKER > wolfram -script output/Tests/NumberQ_Tests.m
#! TextForm[ColonForm[MessageName[Power, infy], StringForm[Infinite expression `1` encountered., Short[HoldForm[0^(-1)], 3]]]]
#! TextForm[ColonForm[MessageName[General, ovfl], StringForm[Overflow occurred in computation.]]]
#! TextForm[ColonForm[MessageName[General, unfl], StringForm[Underflow occurred in computation.]]]
# SYSTEM: Mathematica_10
# TEST: NumberQ_Tests
# RefLink[NumberQ,paclet:ref/NumberQ] tests whether an object is explicitly a number:
ok  NumberQ[5.6]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
ok  NumberQ[x]    ==>     False
    ---
    data:
        got: False
        expect: False
        expect_evaluated: False
    ...
# The expression must be manifestly a number:
ok  NumberQ[Sqrt[2]]    ==>     False
    ---
    data:
        got: False
        expect: False
        expect_evaluated: False
    ...
# You can test if a quantity represents a number with RefLink[NumericQ,paclet:ref/NumericQ]:
ok  NumericQ[Sqrt[2]]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
# On numerical coercion with RefLink[N,paclet:ref/N] such quantities generally become numbers:
ok  NumberQ[N[Sqrt[2]]]    ==>     True
    ---
    data:
        got: True
        expect: True
        expect_evaluated: True
    ...
# RefLink[NumberQ,paclet:ref/NumberQ][RefLink[Infinity,paclet:ref/Infinity]] gives RefLink[False,paclet:ref/False]. 
ok  NumberQ[Infinity]    ==>     False
    ---
    data:
        got: False
        expect: False
        expect_evaluated: False
    ...
# The same is true for complex and directed infinities:
ok  {c, d} = {(1 + I)/0, Infinity*(1 + I)}    ==>     {ComplexInfinity, DirectedInfinity[(1 + I)/Sqrt[2]]}
    ---
    data:
        got: {ComplexInfinity, DirectedInfinity[(1 + I)/Sqrt[2]]}
        expect: {ComplexInfinity, DirectedInfinity[(1 + I)/Sqrt[2]]}
        expect_evaluated: {ComplexInfinity, DirectedInfinity[(1 + I)/Sqrt[2]]}
    ...
ok  {NumberQ[c], NumberQ[d]}    ==>     {False, False}
    ---
    data:
        got: {False, False}
        expect: {False, False}
        expect_evaluated: {False, False}
    ...
# RefLink[NumberQ,paclet:ref/NumberQ][RefLink[Overflow,paclet:ref/Overflow][]] and RefLink[NumberQ,paclet:ref/NumberQ][RefLink[Underflow,paclet:ref/Underflow][]] give RefLink[True,paclet:ref/True]:
ok  {o, u} = {$MaxNumber*2, $MinNumber/2}    ==>     {Overflow[], Underflow[]}
    ---
    data:
        got: {Overflow[], Underflow[]}
        expect: {Overflow[], Underflow[]}
        expect_evaluated: {Overflow[], Underflow[]}
    ...
ok  {NumberQ[o], NumberQ[u]}    ==>     {True, True}
    ---
    data:
        got: {True, True}
        expect: {True, True}
        expect_evaluated: {True, True}
    ...
# They are both treated as RefLink[Real,paclet:ref/Real]:
ok  {Head[o], Head[u]}    ==>     {Real, Real}
    ---
    data:
        got: {Real, Real}
        expect: {Real, Real}
        expect_evaluated: {Real, Real}
    ...
ok  MatrixQ[m, NumberQ]    ==>     True # skip
# It does not evaluate with a symbolic argument:
ok  f[xp0]    ==>     f[xp0]
    ---
    data:
        got: f[xp0]
        expect: f[xp0]
        expect_evaluated: f[xp0]
    ...
# It does evaluate when the argument is a number:
ok  HoldComplete[Plot[f[xp0], {xp0, 0, 2}]]    ==>     $Failed # skip
# Use RefLink[FindRoot,paclet:ref/FindRoot] to find all the solutions of the boundary value problem with x(0)=x(10)=0:
ok  xps = xp0 /. {FindRoot[f[xp0], {xp0, 0.5, 1}], FindRoot[f[xp0], {xp0, 1., 1.9}], FindRoot[f[xp0], {xp0, 1.9, 2.}]}    ==>     {0.924845, 1.87817, 1.99927} # skip
# Plot the solutions:
ok  HoldComplete[sols = Table[First[x[t] /. NDSolve[{Derivative[1][Derivative[1][x]][t] + Sin[x[t]] == 0, x[0] == 0, Derivative[1][x][0] == xp0}, x, {t, 0, 10}]], {xp0, xps}]]    ==>     $Failed # skip
ok  HoldComplete[Plot[sols, {t, 0, 10}]]    ==>     $Failed # skip
# RefLink[NumberQ,paclet:ref/NumberQ] is equivalent to RefLink[MatchQ,paclet:ref/MatchQ][#,_Integer|_Rational|_Real|_Complex]&:
ok  TableForm[Table[{x, NumberQ[x], (MatchQ[#1, _Integer | _Rational | _Real | _Complex] & )[x]}, {x, {1, 3/2, 1.5, 1 + I, E, Sin[1], Underflow[], Overflow[], Infinity}}], TableHeadings -> {{}, {"x", "NumberQ", "match"}}]    ==>     *x*NumberQ*match**1*True*True**(3/2)*True*True**1.5*True*True**1 + I*True*True**E*False*False**Sin[1]*False*False**Underflow[]*True*True**Overflow[]*True*True**Infinity*False*False # skip
# If RefLink[NumberQ,paclet:ref/NumberQ][x] is RefLink[True,paclet:ref/True], then RefLink[NumericQ,paclet:ref/NumericQ][x] is also RefLink[True,paclet:ref/True]:
ok  TableForm[Table[{x, NumberQ[x], NumericQ[x]}, {x, {1, 3/2, 1.5, 1 + I, E, Sin[1], Underflow[], Overflow[], Infinity}}], TableHeadings -> {{}, {"x", "NumberQ", "NumericQ"}}]    ==>     *x*NumberQ*NumericQ**1*True*True**(3/2)*True*True**1.5*True*True**1 + I*True*True**E*False*True**Sin[1]*False*True**Underflow[]*True*True**Overflow[]*True*True**Infinity*False*False # skip
