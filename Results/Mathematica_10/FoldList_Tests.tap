# SYSTEM: Mathematica_10
# TEST: FoldList_Tests
# OUTPUT: output/Results/Mathematica_10/FoldList_Tests.json
ok  FoldList[f, x, {a, b, c, d}]    ==>     {x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c], f[f[f[f[x, a], b], c], d]}
    ---
    data:
        got: {x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c], f[f[f[f[x, a], b], c], d]}
        expect: {x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c], f[f[f[f[x, a], b], c], d]}
        expect_evaluated: {x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c], f[f[f[f[x, a], b], c], d]}
    ...
# Cumulative sums of the elements of the list:
ok  FoldList[Plus, 0, {a, b, c, d}]    ==>     {0, a, a + b, a + b + c, a + b + c + d}
    ---
    data:
        got: {0, a, a + b, a + b + c, a + b + c + d}
        expect: {0, a, a + b, a + b + c, a + b + c + d}
        expect_evaluated: {0, a, a + b, a + b + c, a + b + c + d}
    ...
# Cumulative powers:
ok  FoldList[#1^#2 & , x, {a, b, c, d}]    ==>     {x, x^a, (x^a)^b, ((x^a)^b)^c, (((x^a)^b)^c)^d}
    ---
    data:
        got: {x, x^a, (x^a)^b, ((x^a)^b)^c, (((x^a)^b)^c)^d}
        expect: {x, x^a, (x^a)^b, ((x^a)^b)^c, (((x^a)^b)^c)^d}
        expect_evaluated: {x, x^a, (x^a)^b, ((x^a)^b)^c, (((x^a)^b)^c)^d}
    ...
# The head need not be RefLink[List,paclet:ref/List]:
ok  FoldList[f, x, p[a, b, c, d]]    ==>     p[x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c], f[f[f[f[x, a], b], c], d]]
    ---
    data:
        got: p[x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c], f[f[f[f[x, a], b], c], d]]
        expect: p[x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c], f[f[f[f[x, a], b], c], d]]
        expect_evaluated: p[x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c], f[f[f[f[x, a], b], c], d]]
    ...
# Fold to the right:
ok  FoldList[g[#2, #1] & , x, {a, b, c, d}]    ==>     {x, g[a, x], g[b, g[a, x]], g[c, g[b, g[a, x]]], g[d, g[c, g[b, g[a, x]]]]}
    ---
    data:
        got: {x, g[a, x], g[b, g[a, x]], g[c, g[b, g[a, x]]], g[d, g[c, g[b, g[a, x]]]]}
        expect: {x, g[a, x], g[b, g[a, x]], g[c, g[b, g[a, x]]], g[d, g[c, g[b, g[a, x]]]]}
        expect_evaluated: {x, g[a, x], g[b, g[a, x]], g[c, g[b, g[a, x]]], g[d, g[c, g[b, g[a, x]]]]}
    ...
# Compute successive factorials:
ok  FoldList[Times, 1, Range[10]]    ==>     {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800}
    ---
    data:
        got: {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800}
        expect: {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800}
        expect_evaluated: {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800}
    ...
# Compute products of successive primes:
ok  FoldList[Times, 1, Array[Prime, 10]]    ==>     {1, 2, 6, 30, 210, 2310, 30030, 510510, 9699690, 223092870, 6469693230}
    ---
    data:
        got: {1, 2, 6, 30, 210, 2310, 30030, 510510, 9699690, 223092870, 6469693230}
        expect: {1, 2, 6, 30, 210, 2310, 30030, 510510, 9699690, 223092870, 6469693230}
        expect_evaluated: {1, 2, 6, 30, 210, 2310, 30030, 510510, 9699690, 223092870, 6469693230}
    ...
# Cumulative sums:
ok  FoldList[Plus, 0, {a, b, c, d}]    ==>     {0, a, a + b, a + b + c, a + b + c + d}
    ---
    data:
        got: {0, a, a + b, a + b + c, a + b + c + d}
        expect: {0, a, a + b, a + b + c, a + b + c + d}
        expect_evaluated: {0, a, a + b, a + b + c, a + b + c + d}
    ...
# Build up a continued fraction:
ok  FoldList[1/(#2 + #1) & , x, Reverse[{a, b, c}]]    ==>     {x, 1/(c + x), 1/(b + 1/(c + x)), 1/(a + 1/(b + 1/(c + x)))}
    ---
    data:
        got: {x, (c + x)^(-1), (b + (c + x)^(-1))^(-1), (a + (b + (c + x)^(-1))^(-1))^(-1)}
        expect: {x, 1/(c + x), 1/(b + 1/(c + x)), 1/(a + 1/(b + 1/(c + x)))}
        expect_evaluated: {x, (c + x)^(-1), (b + (c + x)^(-1))^(-1), (a + (b + (c + x)^(-1))^(-1))^(-1)}
    ...
# Build up a nested polynomial (Horner form):
ok  FoldList[x*#1 + #2 & , 0, {a, b, c, d}]    ==>     {0, a, b + a*x, c + x*(b + a*x), d + x*(c + x*(b + a*x))}
    ---
    data:
        got: {0, a, b + a*x, c + x*(b + a*x), d + x*(c + x*(b + a*x))}
        expect: {0, a, b + a*x, c + x*(b + a*x), d + x*(c + x*(b + a*x))}
        expect_evaluated: {0, a, b + a*x, c + x*(b + a*x), d + x*(c + x*(b + a*x))}
    ...
# Build up a number from digits:
ok  FoldList[10*#1 + #2 & , 0, {4, 5, 1, 6, 7, 8}]    ==>     {0, 4, 45, 451, 4516, 45167, 451678}
    ---
    data:
        got: {0, 4, 45, 451, 4516, 45167, 451678}
        expect: {0, 4, 45, 451, 4516, 45167, 451678}
        expect_evaluated: {0, 4, 45, 451, 4516, 45167, 451678}
    ...
# Form alternating sums:
ok  FoldList[#2 - #1 & , 0, {a, b, c, d, e}]    ==>     {0, a, -a + b, a - b + c, -a + b - c + d, a - b + c - d + e}
    ---
    data:
        got: {0, a, -a + b, a - b + c, -a + b - c + d, a - b + c - d + e}
        expect: {0, a, -a + b, a - b + c, -a + b - c + d, a - b + c - d + e}
        expect_evaluated: {0, a, -a + b, a - b + c, -a + b - c + d, a - b + c - d + e}
    ...
# Generate a random walk:
ok  FoldList[Plus, 0, Table[(-1)^RandomInteger[], {20}]]    ==>     {0, 1, 2, 3, 2, 1, 0, 1, 2, 1, 2, 3, 4, 5, 6, 7, 6, 5, 6, 7, 6} # skip
# Find the running maximum of a list:
ok  FoldList[Max, 0, {1, 3, 1, 2, 4, 1, 5, 3, 6, 2, 8, 11}]    ==>     {0, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 8, 11}
    ---
    data:
        got: {0, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 8, 11}
        expect: {0, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 8, 11}
        expect_evaluated: {0, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 8, 11}
    ...
ok  DeleteDuplicates[%]    ==>     {0, 1, 3, 4, 5, 6, 8, 11} # skip
# Find successively deeper parts in an expression:
ok  FoldList[#1[[#2]] & , (a + b)*(x^2 + y^2), {2, 1, 1}]    ==>     {(a + b)*(x^2 + y^2), x^2 + y^2, x^2, x}
    ---
    data:
        got: {(a + b)*(x^2 + y^2), x^2 + y^2, x^2, x}
        expect: {(a + b)*(x^2 + y^2), x^2 + y^2, x^2, x}
        expect_evaluated: {(a + b)*(x^2 + y^2), x^2 + y^2, x^2, x}
    ...
ok  FoldList[Part, (a + b)*(x^2 + y^2), {2, 1, 1}]    ==>     {(a + b)*(x^2 + y^2), x^2 + y^2, x^2, x}
    ---
    data:
        got: {(a + b)*(x^2 + y^2), x^2 + y^2, x^2, x}
        expect: {(a + b)*(x^2 + y^2), x^2 + y^2, x^2, x}
        expect_evaluated: {(a + b)*(x^2 + y^2), x^2 + y^2, x^2, x}
    ...
# Successively append to a list:
ok  FoldList[Append, {x}, {a, b, c, d}]    ==>     {{x}, {x, a}, {x, a, b}, {x, a, b, c}, {x, a, b, c, d}}
    ---
    data:
        got: {{x}, {x, a}, {x, a, b}, {x, a, b, c}, {x, a, b, c, d}}
        expect: {{x}, {x, a}, {x, a, b}, {x, a, b, c}, {x, a, b, c, d}}
        expect_evaluated: {{x}, {x, a}, {x, a, b}, {x, a, b, c}, {x, a, b, c, d}}
    ...
# Build up a binary tree:
ok  FoldList[List, x, {a, b, c, d}]    ==>     {x, {x, a}, {{x, a}, b}, {{{x, a}, b}, c}, {{{{x, a}, b}, c}, d}}
    ---
    data:
        got: {x, {x, a}, {{x, a}, b}, {{{x, a}, b}, c}, {{{{x, a}, b}, c}, d}}
        expect: {x, {x, a}, {{x, a}, b}, {{{x, a}, b}, c}, {{{{x, a}, b}, c}, d}}
        expect_evaluated: {x, {x, a}, {{x, a}, b}, {{{x, a}, b}, c}, {{{{x, a}, b}, c}, d}}
    ...
# Build up a left-branching binary tree:
ok  FoldList[{#2, #1} & , x, {a, b, c, d}]    ==>     {x, {a, x}, {b, {a, x}}, {c, {b, {a, x}}}, {d, {c, {b, {a, x}}}}}
    ---
    data:
        got: {x, {a, x}, {b, {a, x}}, {c, {b, {a, x}}}, {d, {c, {b, {a, x}}}}}
        expect: {x, {a, x}, {b, {a, x}}, {c, {b, {a, x}}}, {d, {c, {b, {a, x}}}}}
        expect_evaluated: {x, {a, x}, {b, {a, x}}, {c, {b, {a, x}}}, {d, {c, {b, {a, x}}}}}
    ...
# Make function compositions:
ok  FoldList[#2[#1] & , x, {a, b, c, d}]    ==>     {x, a[x], b[a[x]], c[b[a[x]]], d[c[b[a[x]]]]}
    ---
    data:
        got: {x, a[x], b[a[x]], c[b[a[x]]], d[c[b[a[x]]]]}
        expect: {x, a[x], b[a[x]], c[b[a[x]]], d[c[b[a[x]]]]}
        expect_evaluated: {x, a[x], b[a[x]], c[b[a[x]]], d[c[b[a[x]]]]}
    ...
# Compute a power using a power tree with successive squaring:
ok  With[{m = x, t = 85}, FoldList[#1^2*m^#2 & , 1, IntegerDigits[t, 2]]]    ==>     {1, x, x^2, x^5, x^10, x^21, x^42, x^85}
    ---
    data:
        got: {1, x, x^2, x^5, x^10, x^21, x^42, x^85}
        expect: {1, x, x^2, x^5, x^10, x^21, x^42, x^85}
        expect_evaluated: {1, x, x^2, x^5, x^10, x^21, x^42, x^85}
    ...
ok  With[{m = 3, t = 85}, FoldList[#1^2*m^#2 & , 1, IntegerDigits[t, 2]]]    ==>     {1, 3, 9, 243, 59049, 10460353203, 109418989131512359209, 35917545547686059365808220080151141317043}
    ---
    data:
        got: {1, 3, 9, 243, 59049, 10460353203, 109418989131512359209, 35917545547686059365808220080151141317043}
        expect: {1, 3, 9, 243, 59049, 10460353203, 109418989131512359209, 35917545547686059365808220080151141317043}
        expect_evaluated: {1, 3, 9, 243, 59049, 10460353203, 109418989131512359209, 35917545547686059365808220080151141317043}
    ...
# RefLink[FoldList,paclet:ref/FoldList] makes a list of length n+1:
ok  Length[FoldList[f, x, Range[10]]]    ==>     11
    ---
    data:
        got: 11
        expect: 11
        expect_evaluated: 11
    ...
# RefLink[Rest,paclet:ref/Rest] gives a result of length n:
ok  Rest[FoldList[Plus, 0, {a, b, c, d, e}]]    ==>     {a, a + b, a + b + c, a + b + c + d, a + b + c + d + e}
    ---
    data:
        got: {a, a + b, a + b + c, a + b + c + d, a + b + c + d + e}
        expect: {a, a + b, a + b + c, a + b + c + d, a + b + c + d + e}
        expect_evaluated: {a, a + b, a + b + c, a + b + c + d, a + b + c + d + e}
    ...
# Folding with an empty list does not apply the function at all:
ok  FoldList[f, x, {}]    ==>     {x}
    ---
    data:
        got: {x}
        expect: {x}
        expect_evaluated: {x}
    ...
# RefLink[Fold,paclet:ref/Fold] gives the last element of RefLink[FoldList,paclet:ref/FoldList]:
ok  FoldList[f, x, {a, b, c}]    ==>     {x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c]}
    ---
    data:
        got: {x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c]}
        expect: {x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c]}
        expect_evaluated: {x, f[x, a], f[f[x, a], b], f[f[f[x, a], b], c]}
    ...
ok  Fold[f, x, {a, b, c}]    ==>     f[f[f[x, a], b], c]
    ---
    data:
        got: f[f[f[x, a], b], c]
        expect: f[f[f[x, a], b], c]
        expect_evaluated: f[f[f[x, a], b], c]
    ...
# Functions that ignore their second argument give the same result as in RefLink[NestList,paclet:ref/NestList]:
ok  FoldList[f[#1] & , x, Range[5]]    ==>     {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]], f[f[f[f[f[x]]]]]}
    ---
    data:
        got: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]], f[f[f[f[f[x]]]]]}
        expect: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]], f[f[f[f[f[x]]]]]}
        expect_evaluated: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]], f[f[f[f[f[x]]]]]}
    ...
ok  NestList[f, x, 5]    ==>     {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]], f[f[f[f[f[x]]]]]}
    ---
    data:
        got: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]], f[f[f[f[f[x]]]]]}
        expect: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]], f[f[f[f[f[x]]]]]}
        expect_evaluated: {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]], f[f[f[f[f[x]]]]]}
    ...
# RefLink[Accumulate,paclet:ref/Accumulate] is equivalent to RefLink[FoldList,paclet:ref/FoldList] with RefLink[Plus,paclet:ref/Plus]:
ok  Rest[FoldList[Plus, 0, {a, b, c, d}]]    ==>     {a, a + b, a + b + c, a + b + c + d}
    ---
    data:
        got: {a, a + b, a + b + c, a + b + c + d}
        expect: {a, a + b, a + b + c, a + b + c + d}
        expect_evaluated: {a, a + b, a + b + c, a + b + c + d}
    ...
ok  Accumulate[{a, b, c, d}]    ==>     {a, a + b, a + b + c, a + b + c + d}
    ---
    data:
        got: {a, a + b, a + b + c, a + b + c + d}
        expect: {a, a + b, a + b + c, a + b + c + d}
        expect_evaluated: {a, a + b, a + b + c, a + b + c + d}
    ...
ok  makeChange[1.63]    ==>     {6, 1, 0, 3} # skip
