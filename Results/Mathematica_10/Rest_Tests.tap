#! DOCKER > wolfram -script output/Tests/Rest_Tests.m
# SYSTEM: Mathematica_10
# TEST: Rest_Tests
ok  Rest[{a, b, c, d}]    ==>     {b, c, d}
    ---
    data:
        got: {b, c, d}
        expect: {b, c, d}
        expect_evaluated: {b, c, d}
    ...
ok  Rest[<| 1 :> a, 2 -> b, 3 :> c |>]    ==>     <| 2 -> b, 3 :> c |>
    ---
    data:
        got: <|2 -> b, 3 -> c|>
        expect: <| 2 -> b, 3 :> c |>
        expect_evaluated: <|2 -> b, 3 -> c|>
    ...
# The head need not be RefLink[List,paclet:ref/List]:
ok  Rest[a + b + c + d]    ==>     b + c + d
    ---
    data:
        got: b + c + d
        expect: b + c + d
        expect_evaluated: b + c + d
    ...
ok  Rest[f[a, b, c, d]]    ==>     f[b, c, d]
    ---
    data:
        got: f[b, c, d]
        expect: f[b, c, d]
        expect_evaluated: f[b, c, d]
    ...
# RefLink[Rest,paclet:ref/Rest] works on RefLink[SparseArray,paclet:ref/SparseArray] objects:
ok  HoldComplete[Rest[SparseArray[Range[100]]]]    ==>     $Failed # skip
# Nest the operation of finding the rest of a list:
ok  NestList[Rest, {a, b, c, d, e}, 3]    ==>     {{a, b, c, d, e}, {b, c, d, e}, {c, d, e}, {d, e}}
    ---
    data:
        got: {{a, b, c, d, e}, {b, c, d, e}, {c, d, e}, {d, e}}
        expect: {{a, b, c, d, e}, {b, c, d, e}, {c, d, e}, {d, e}}
        expect_evaluated: {{a, b, c, d, e}, {b, c, d, e}, {c, d, e}, {d, e}}
    ...
# RefLink[Rest,paclet:ref/Rest][expr] is equivalent to RefLink[Drop,paclet:ref/Drop][expr,1]. 
ok  Rest[{a, b, c, d}]    ==>     {b, c, d}
    ---
    data:
        got: {b, c, d}
        expect: {b, c, d}
        expect_evaluated: {b, c, d}
    ...
ok  Drop[{a, b, c, d}, 1]    ==>     {b, c, d}
    ---
    data:
        got: {b, c, d}
        expect: {b, c, d}
        expect_evaluated: {b, c, d}
    ...
# The expression is evaluated before RefLink[Rest,paclet:ref/Rest] is applied:
ok  Rest[c + a + b]    ==>     b + c
    ---
    data:
        got: b + c
        expect: b + c
        expect_evaluated: b + c
    ...
# RefLink[Rest,paclet:ref/Rest] always operates on the RefLink[FullForm,paclet:ref/FullForm] of expressions:
ok  Rest[1/b]    ==>     -1
    ---
    data:
        got: -1
        expect: -1
        expect_evaluated: -1
    ...
ok  FullForm[1/b]    ==>     b^(-1) # skip
