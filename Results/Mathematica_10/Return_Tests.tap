#! DOCKER > wolfram -script output/Tests/Return_Tests.m
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[$IterationLimit, itlim], StringForm[Iteration limit of `1` exceeded., Short[HoldForm[4096], 3]]]]
#! TextForm[ColonForm[MessageName[General, stop], StringForm[Further output of `1` will be suppressed during this calculation., Short[HoldForm[MessageName[$IterationLimit, itlim]], 3]]]]
# SYSTEM: Mathematica_10
# TEST: Return_Tests
# Return from a function:
ok  f[x_] := (If[x > 5, Return[a]]; x + 3); f[6]    ==>     a
    ---
    data:
        got: a
        expect: a
        expect_evaluated: a
    ...
# RefLink[Return,paclet:ref/Return] exits only the innermost construct in which it is invoked:
ok  f[x_] := (If[x > 5, Return[a]]; x); f[6]    ==>     a
    ---
    data:
        got: a
        expect: a
        expect_evaluated: a
    ...
# Here it exits the RefLink[Do,paclet:ref/Do] loop, but not the function g:
ok  g[x_] := (Do[If[x > 5, Return[a]], {3}]; x); g[6]    ==>     6
    ---
    data:
        got: 6
        expect: 6
        expect_evaluated: 6
    ...
# Use RefLink[Catch,paclet:ref/Catch] and RefLink[Throw,paclet:ref/Throw] for explicit flow control:
ok  h[x_] := Catch[Do[If[x > 5, Throw[a]], {3}]; x]; h[6]    ==>     a
    ---
    data:
        got: a
        expect: a
        expect_evaluated: a
    ...
